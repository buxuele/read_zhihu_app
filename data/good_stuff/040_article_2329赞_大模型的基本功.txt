标题: 大模型的基本功
类型: article
赞数: 2329
链接: https://zhuanlan.zhihu.com/p/716344766
创建时间: 1724551387
--------------------------------------------------

这篇文章给大家推荐几个大模型的练手程序，也就是所谓的“基本功”。先问个问题，除了 transformer、rope、swiglu、rms_norm，大家觉着大模型的基本功都有哪些呢？flash_attention 的原理？megatron 的各种 parallel 策略？量化和推理加速技术？cuda编程？怎么说呢，这些“有技术含量的大模型的核心技术”确实很重要，但我个人还是觉着大多数人在实际工作中并不需要完全理解它们。因为它们追求的是模型性能的极限优化，对我们做个简单的 SFT、PPO 并无太大助力。往往我们的需求只是使用它们，而不是去优化它们。所以，我会给出一些我个人认为工作中很常用，但却“没有技术含量”的一些基本功（刷面经的同学可以不用看了哈，我推荐的基本功面试官不会考的）。trans_XX_to_llama.py在开源社区，llama 的网络结构已经一统江湖了，那也就是说 modeling_llama.py 理论上可以 load 起来任何一个开源模型。OK，请自行完成以下脚本，使得我们可以用 modeling_llama.py 加载任何一个其他开源模型。trans_qwen_to_llama.pytrans_llama_to_qwen.py……完成这些工作，你会理解每个开源模型的独特之处，比如，qwen2 的 q、k、v 的线性变换是有 bias 的，baichuan 的 lm_head 之前有一个 normalize() 的操作，甚至每个开源模型你都能观察到一些 attention 的魔改。再然后，对着他们的论文去找，为什么他们的作者要做这些改动？能不能从这个过程中学到知识就看各自悟性了。进阶篇：trans_llama_to_megatron.py (给定参数 tp 和 pp）trans_megatron_to_llama.py并不是所有同学都用 megatron 训代码，但用 megatron 训代码的同学，这两个脚本是基本功中的基本功了。这里只提醒一下，megatron_checkpoint 的 pp_size 实现 merge 和 split 非常简单，但在对 tp_size 进行 merge 和 split 的时候，一定要留意 megatron 的 gqa 的实现方式。modeling_XX.py即然我们已经可以万物转 llama 了，那为什么我还一定要使用 modeling_llama.py 呢？毕竟：modeling_llama.py 在加载模型的时候没有 skip_build ；modeling_llama.py 缺少 stream_generate；modeling_llama.py 文件不支持 sequence_parallel ；modeling_llama.py 默认使用 flash_attention；modeling_llama.py 并没有一个可以作为 reward_model 的 lm_head；……因此，实现一个属于自己的 modeling_XX.py 吧，集百家之长，先去收集 modeling_llama.py、 modeling_qwen.py、 modeling_baichuan.py、 modeling_yi.py、 modeling_deepseek.py、modeling_glm.py 等所有的开源文件，再把各家公司实现的比较好用的 def 加入到自己的 modeling_XX.py 中。这样，当市面上出现任何一个新的开源模型，我们就都可以通过“trans_newModel_to_myModel.py”，快速的对该模型进行微调操作，而不用修改任何训练代码。进阶篇：我们还可以给自己的 modeling 文件加入很多有趣的东西来助力日常的 debug，比如：def show_cos_distance(self, layer)：输出某个 layer 的 input_hidden_states 和 output_hidden_states 的余弦距离；def show_topk_token(self, layer, K=10)：输出用某个 layer 去预测 next token 时的最大 K 个 token；def show_attention(self, layer, tokenA, tokenB)：输出第 layer 层的某两个 token 之间的 attention_value。multi_infer.pymodel.generate() 我们都再熟悉不过了。在不考虑推理加速等技术时，一个客观事实是：“8 卡 load 1 个模型、开大 batch_size ”的推理速度，远远小于 “8 卡 load 8 个模型、开小 batch_size ”的推理速度。那么有需求了，实现一个 class infer (model_path, data_path, output_path, num_workers)，根据自己的喜欢，可以用 torch_run，也可以用 multiprocessing，亦或是其他 python 库。达成下面这个目的即可：在推理的时候让 1 机 8 卡 load 8 / 4 / 2 / 1 个模型，来快速的推理完一大批数据。tips：一些写法可能需要给 modeling_XX.py 加入一个 def set_device(self, device_list) 函数，毕竟如果每次都用 os.environ["CUDA_VISIBLE_DEVICES"]="3,4" 来控制使用哪些卡来 load 模型，有点不太优雅。进阶篇：单机的并行推理已经实现了，不妨试试多机的；学会用 vllm 等更快的推理框架，而不是 model.generate()。Channel Loss在介绍领域模型 post-pretrain 的时候，我说过一句话：做 domain post-pretrain 不看 channel loss，你不如别开 tensorboard。基本大部分情况下，post-pretrain 的 loss 曲线都呈“缓慢下降”或“持平”的变化趋势，sft 的 loss 曲线都呈“快速下降”且“阶梯状”的变化趋势，这个时候除了初始 loss 和最终 loss是否符合预期外，我们能从中得到的信息微乎其微。因此，把数据划分成不同的数据源，对每个数据源的 loss 曲线单独观察，就显得尤为有意义，这也是研究跷跷板问题的必要环节。题目来了：改进训练代码，给自己的 sft 数据随机赋予一个 channel，然后在训练过程中绘制出每个 channel 的 loss 曲线。tips：考虑通过 all_gather_object 实现。进阶篇：megatron 由于有 tp 和 pp 存在，实现起来难度远大于 deepspeed；model.trainer() 的训练方式封装的很死，如何加入 channel_loss 呢？先列出这些吧，这些基本功可能对求职没有任何帮助，但拿来优化开发效率应该蛮好用的！此外，以上提到的所有程序 ChatGPT 都会写（不包括进阶篇，进阶篇有些我也没调通过），不会的话就问问 Chat 老师。