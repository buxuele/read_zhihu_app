{
  "data": [
    {
      "id": "138_1767705716.843",
      "type": "feed",
      "offset": 138,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705716,
      "updated_time": 1767705716,
      "target": {
        "type": "answer",
        "url": "https://api.zhihu.com/answers/1991975257091892436",
        "reshipment_settings": "allowed",
        "comment_count": 0,
        "question": {
          "follower_count": 0,
          "bound_topic_ids": [
            6859,
            7371,
            26008,
            177935,
            582151
          ],
          "relationship": {
            "is_author": false
          },
          "author": {
            "headline": "公众号:歌部落群多多",
            "is_org": false,
            "gender": 1,
            "followers_count": 12,
            "url_token": "31-26-66-50",
            "name": "歌部",
            "user_type": "people",
            "avatar_url": "https://pic1.zhimg.com/50/v2-325fbb665e4d175bdd1e86cfaf7cf53e_l.jpg?source=b6762063",
            "is_following": false,
            "is_followed": false,
            "id": "5e607ede0cf809dabb51ca6f2b6e624d",
            "url": "https://api.zhihu.com/people/5e607ede0cf809dabb51ca6f2b6e624d"
          },
          "title": "有什么线上靠谱的兼职？",
          "created": 1719825265,
          "excerpt": "",
          "detail": "",
          "url": "https://api.zhihu.com/questions/660448421",
          "answer_count": 0,
          "comment_count": 0,
          "question_type": "normal",
          "id": "660448421",
          "type": "question",
          "is_following": false
        },
        "thumbnail": "https://pic1.zhimg.com/50/v2-3eb0c1146b622f5715f972a20ed50366_720w.jpg?source=b6762063",
        "visited_count": 4,
        "excerpt_new": "携程搬砖，每天30分钟，月收益1500，超低门槛，附教程大家好！我是拾阶，一个在互联网上摸爬滚打5年的轻创从业者，见过各式各样的副业，踩过很多坑也捡过一些宝，现在就认准一个事：把事情做扎实，把生活过成自己喜欢的样子！ 说到携程，我想大家应该都不陌生吧？订机票、订酒店、查攻略，简直是旅行必备神器。但是，我敢肯定，95%的人都不知道，这个常用软件，藏着一个0成本挣钱的路子！   我身边就有这样一个宝妈朋友，平时要带…",
        "answer_type": "normal",
        "id": "1991975257091892436",
        "is_copyable": true,
        "preview_type": "default",
        "is_navigator": false,
        "created_time": 1767703910,
        "updated_time": 1767703910,
        "voteup_count": 0,
        "content": "<h2>携程搬砖，每天30分钟，月收益1500，超低门槛，附教程</h2><p data-pid=\"yFWJZgQz\">大家好！我是拾阶，一个在互联网上摸爬滚打5年的轻创从业者，见过各式各样的副业，踩过很多坑也捡过一些宝，现在就认准一个事：把事情做扎实，把生活过成自己喜欢的样子！</p><p data-pid=\"IbrtU07M\">说到携程，我想大家应该都不陌生吧？订机票、订酒店、查攻略，简直是旅行必备神器。但是，我敢肯定，95%的人都不知道，这个常用软件，藏着一个0成本挣钱的路子！</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-fc300ea9bfd0559ad85f9555c625bf2c_1440w.jpg\" data-rawwidth=\"1264\" data-rawheight=\"806\" data-size=\"normal\" data-original-token=\"v2-3eb0c1146b622f5715f972a20ed50366\" class=\"origin_image zh-lightbox-thumb\" width=\"1264\" data-original=\"https://pic1.zhimg.com/v2-fc300ea9bfd0559ad85f9555c625bf2c_r.jpg\"/></figure><p data-pid=\"bEIs5smE\">我身边就有这样一个宝妈朋友，平时要带娃，根本没时间出去打工，偶然刷到我分享的携程创作激励计划，抱着试试看的心态自己研究着做。她每天趁娃午睡的半小时，捣鼓一篇旅行笔记，第一个月就挣了1200多，给娃买奶粉和玩具4算是够了，别提多开心了！这里没有夸张吹嘘，30天1200多，算下来一天也就40多块，但这都是实打实进自己口袋的。而且利用的都是自己碎片化时间！今天，我也把这个副业分享给大家。有感兴趣的朋友可以上手试试。</p><p data-pid=\"yEJ6mcvh\">携程创作激励计划，说白了就是发旅行笔记获得现金奖励！单篇最高能拿100元，一个账号每月上限1500元！不用专业技能，不用投一分钱本金，每天抽出半小时“搬砖”，单账号月入上千不是梦，要是时间充裕多搞几个号，收益翻番真的不难！</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-6d885ffdfc4216dd17e319fe61af29e9_1440w.jpg\" data-rawwidth=\"1264\" data-rawheight=\"1434\" data-size=\"normal\" data-original-token=\"v2-6c5eed6116972da0bb0ca442c13c6850\" class=\"origin_image zh-lightbox-thumb\" width=\"1264\" data-original=\"https://pic2.zhimg.com/v2-6d885ffdfc4216dd17e319fe61af29e9_r.jpg\"/></figure><p data-pid=\"rzU_CzXG\">下面我就手把手，从报名到变现，从技巧到避坑，全程干货，没时间看完的小伙伴可以收藏起来，有时间再看，直接跟着做就行！</p><p data-pid=\"v0z0lhiZ\"><b>一、项目原理</b></p><p data-pid=\"Z18o9Gn4\">有句话说得好：“信息差就是赚钱核心”。携程这个激励计划，就是平台为了丰富旅行内容，专门给咱们普通人准备的“挣钱路径”，挣钱原理很简单！</p><p data-pid=\"OOAkxwZ7\">只要你发布和旅行相关的原创笔记，不管是景点保姆级攻略（例如怎么避开人流、哪个位置拍照最好看）、酒店真实入住体验（例如隔音好不好、早餐值不值得吃），还有超实用的行程分享（例如3天2晚怎么玩最省钱），都能拿到现金奖励！</p><p data-pid=\"ZMUetcGO\">收益规则更是清清楚楚，一点没有套路：单篇笔记最高奖励100元，一个账号一个月最多能拿1500元，要是你有精力多运营几个账号，那收益非常可观！</p><p data-pid=\"g_wLJDLs\">这个项目的本质，就是做个“旅行内容改造手”，不需要你亲自去旅行拍图写稿，只需要把别人的优质素材二次整理、加工，变成自己的原创内容发布就可以了。零成本，高性价比，相比薅羊毛的零撸项目要好多了！</p><p data-pid=\"BX0n04G_\"><b>二、实操流程</b></p><p data-pid=\"saUYCtHJ\">第一步：报名激励计划，5分钟搞定，秒通过！ 这是携程官方活动，完全没门槛，5分钟就能搞定！</p><p data-pid=\"gnSrSR2S\"> 1. 常规操作法：打开携程APP，点击右下角的「我的」，在顶部搜索框直接输入「激励计划」，找到对应的入口，点进去就能报名，基本上提交之后秒通过！</p><p data-pid=\"7UCloruX\">​2. 备用找法：要是你运气不好，没搜到入口也别急！先点底部中间的「+」号，假装要发一篇旅行笔记，然后直接退出，再进入「创作中心」，点击「更多功能」，就能找到「激励计划」的报名通道啦！亲测有效！</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-f8576e91af38a6caa154d6c5f8f80011_1440w.jpg\" data-rawwidth=\"1264\" data-rawheight=\"512\" data-size=\"normal\" data-original-token=\"v2-fe30fb4b140b36d296da0275e33bb7ad\" class=\"origin_image zh-lightbox-thumb\" width=\"1264\" data-original=\"https://pic2.zhimg.com/v2-f8576e91af38a6caa154d6c5f8f80011_r.jpg\"/></figure><p data-pid=\"dKiLWNQR\">第二步：制作笔记，10分钟出一篇，不会写也能做！</p><p data-pid=\"dq1hi-JN\">核心秘诀就四个字：图文结合+文案原创！不用你自己拍图、不用你绞尽脑汁写文案，搬运改造就能搞定！</p><p data-pid=\"AiIHIdZ4\"> 1. 找素材：瞄准小红书，专挑“近期高赞”。打开小红书，搜索你想做的景点关键词，例如“西安兵马俑攻略”“西双版纳民宿推荐”等，然后切换到「最新」排序，优先选2小时内发布的笔记！为啥？因为新内容重复度低，平台更容易推荐，过审也快，这是踩了无数坑总结出来的经验！</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-a61959898c0c9661457f9d1bda148f2c_1440w.jpg\" data-rawwidth=\"1264\" data-rawheight=\"1703\" data-size=\"normal\" data-original-token=\"v2-6ed6bd6f7115c8cc22640cc35f47feb1\" class=\"origin_image zh-lightbox-thumb\" width=\"1264\" data-original=\"https://pic3.zhimg.com/v2-a61959898c0c9661457f9d1bda148f2c_r.jpg\"/></figure><p data-pid=\"PmkdTpPD\">2. 素材二创：三步变身原创，避免侵权。</p><p data-pid=\"_w-14PjA\">图片二创：把小红书上的旅行图保存下来，用美图秀秀或者醒图，先裁剪成携程喜欢的比例（3:4竖图或者16:9横图），然后加个简单的滤镜，调个亮度对比度，要是能加个可爱的贴纸或者文字标注就更好了，这样一改，和原图的相似度直接降到最低！</p><p data-pid=\"k8VRuh1o\">​文案二创：这一步是关键！绝对不能直接复制粘贴！先通读原文，提炼出核心信息：例如门票价格、开放时间、游玩路线、景点亮点、避坑提示，然后用自己的话重新组织语言，例如原文说“这家酒店性价比很高”，你可以改成“家人们！这家酒店我真的吹爆！人均100+就能住到市中心，出门就是地铁站，性价比直接拉满！”，这样一改，口语化又接地气，原创度直接拉满！</p><p data-pid=\"6Stqi_U0\">​3. 发布笔记：关键词+标签是关键</p><p data-pid=\"yvr3Pbcn\">上传3-9张你改造好的图片，粘贴改写后的文案，标题一定要带关键词，例如“北京3天2晚穷游攻略，学生党必看”“厦门网红酒店真实测评，避坑指南”，然后选上对应的话题标签，例如#携程旅行攻略 #小众旅行地 #酒店推荐，最后点击发布，整个流程就做好了！</p><p data-pid=\"J7Bdiz2K\"><b> 三、增加收益技巧：从月入500到1500+，就靠这3个方式</b>！</p><p data-pid=\"4bXUEQFs\">很多伙伴刚开始做，一个月只能赚几百块，别着急！通过这3个技巧，收益直接翻番！</p><p data-pid=\"SPn_NHVG\"> 1. 选题选对，事半功倍！选题直接决定你的笔记能不能爆！优先选热门旅行地（云南、三亚、迪士尼、成都这些永远不会错）、节假日专属攻略（如春节去哪玩、国庆避堵路线）、高性价比酒店/民宿，这类内容用户需求高，平台给的奖励也更高！重点：大众喜欢的，才是能赚钱的！</p><p data-pid=\"5wfmqjc5\">​2. 保持更新，账号活跃是王道！平台都喜欢勤快的创作者！每天坚持发2-3条笔记，保持账号活跃，平台会把你的内容优先推荐给更多人，阅读量上去了，收益自然蹭蹭涨！别三天打鱼两天晒网，搞副业和搞主业一样，贵在坚持！</p><p data-pid=\"ywCJ0zie\">​3. 优化排版，提升阅读体验！好的排版能让用户愿意多看几秒！文案记得分点排版，用数字或者表情符号隔开，重点信息比如价格、路线、避坑提示，一定要加粗突出！图片排列也有讲究，按照“封面吸睛图+景点细节图+实用攻略图”的顺序来，封面图要选最漂亮、最有吸引力的，这样才能让人忍不住点进来！</p><p data-pid=\"3B_7U0lx\"><b> 四、避坑指南</b></p><p data-pid=\"3dHrdAVF\">挣钱路上，踩坑比赚钱容易太多！这2个雷区，大家记得避开！</p><p data-pid=\"xv5cmhKM\"> 1. 绝对不能直接搬运！这是最致命的错误！有人偷懒，直接把别人的图片和文案复制粘贴就发布，结果要么被判违规，要么没有收益，白忙活一场！文案必须原创改写，图片一定要裁剪加滤镜，哪怕改一点点，也比直接搬运强！</p><p data-pid=\"oy8Hg_dR\">​2. 违规内容坚决不碰！虚假攻略（例如明明不好玩，非要吹上天）、敏感话题、侵权图片（例如没授权就用别人的原创图），这些都别碰！遵守平台规范，账号才能稳定赚钱，要是账号被封了，之前的努力就全白费了！</p><p data-pid=\"8vaA7QNk\">这个携程创作激励计划，是我见过最比较适合普通人的副业之一：零成本、低门槛、稳收益，每天只需要半小时，单账号就能月入1500，时间多的朋友批量操作，收入会翻倍！</p><p data-pid=\"iZl_RsYx\">现在携程也在大力扶持内容创作，正是流量红利期，早入场早赚钱！就像那句话说的：“种一棵树最好的时间是十年前，其次是现在”，想搞钱就别犹豫！</p><p data-pid=\"kE6g2YUU\">做了不一定有，但不做肯定没有！现在就打开携程APP，报名激励计划，跟着流程发你的第一条笔记，慢慢跑通收益闭环！</p><p data-pid=\"C9ybWlTg\">接下来，我每天都会分享各种副业干货，感兴趣的朋友可以专注我。如果对上面的操作流程还有不明白的地方，我也准备了资料库，可以找我领取，免费分享，绝无套路。</p><p data-pid=\"t2163sYz\">好啦，今天的分享就到这儿，记得点赞收藏，感谢支持！下期再见！</p>",
        "navigator_vote": false,
        "allow_segment_interaction": true,
        "preview_text": "",
        "relationship": {
          "is_nothelp": false,
          "voting": 0,
          "is_thanked": false
        },
        "is_labeled": false,
        "thumbnails": [
          "https://picx.zhimg.com/50/v2-3eb0c1146b622f5715f972a20ed50366_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-6c5eed6116972da0bb0ca442c13c6850_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-6ed6bd6f7115c8cc22640cc35f47feb1_720w.jpg?source=b6762063"
        ],
        "favorite_count": 0,
        "author": {
          "id": "269de77df5b211173eb5df48db1b0938",
          "name": "拾级而上",
          "avatar_url": "https://picx.zhimg.com/50/v2-330ca6d8d9e088be67f2707132b7d53e_l.jpg?source=b6762063",
          "is_org": false,
          "gender": 1,
          "is_followed": false,
          "url": "https://api.zhihu.com/people/269de77df5b211173eb5df48db1b0938",
          "user_type": "people",
          "url_token": "lll131415",
          "headline": "持续分享互联网干货，详细、实操、能上手。",
          "followers_count": 321,
          "is_following": false
        },
        "thanks_count": 0,
        "vote_next_step": "vote",
        "excerpt": "携程搬砖，每天30分钟，月收益1500，超低门槛，附教程大家好！我是拾阶，一个在互联网上摸爬滚打5年的轻创从业者，见过各式各样的副业，踩过很多坑也捡过一些宝，现在就认准一个事：把事情做扎实，把生活过成自己喜欢的样子！ 说到携程，我想大家应该都不陌生吧？订机票、订酒店、查攻略，简直是旅行必备神器。但是，我敢肯定，95%的人都不知道，这个常用软件，藏着一个0成本挣钱的路子！   我身边就有这样一个宝妈朋友，平时要带…"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1991975257091892436}",
      "attached_info": "CqsHCO/Ln9uNj/b0nQEQBBoJNzY0MzAyNjg4IOaK9MoGKAAwAECKAUokChlUU19TT1VSQ0VfV0FSTV9VUF9OT1JNQUwxEgEwGAAgADoASiwKIVRTX1NPVVJDRV9XQVJNVVBfWkhJX0ZJTkVUVU5FX0kySRIBMBgAIAA6AFoJMTA5MDQ0MTM3YiBlYWVhNTQwNjZjODE5YTZhNzliOWZjYmUxZDkyMjMzNHITMTk5MTk3NTI1NzA5MTg5MjQzNooBCTY2MDQ0ODQyMaoBCXJlY29tbWVuZMIBIDI2OWRlNzdkZjViMjExMTczZWI1ZGY0OGRiMWIwOTM48gEKCAwSBk5vcm1hbPIBKAgKEiQ4NzI5YzI5YS01ZTYyLTQzNTctOTc5YS1kNWU5Mzk2YTBhZmXyAQYICxICMjSCAgCIAvHJ4pu5M5ICIDI2OWRlNzdkZjViMjExMTczZWI1ZGY0OGRiMWIwOTM4mgIAygIURmlyc3RCcnVzaFdlaWdodFJ1bGXKAhZTaG9ySW50ZXJlc3RXZWlnaHRSdWxlygIbSW50ZXJhY3Rpb25TaG9ySW50ZXJlc3RSdWxl2gIZVFNfU09VUkNFX1dBUk1fVVBfTk9STUFMMegCA/oCC05PUk1BTF9GTE9XigMgZWNjYTExYjZhZThlNGQ5NjgxYTBmY2JjNDkzMzg3ZTWaAw0KAnYyEAAaBW90aGVyqAME2AMA6gMaYWlfemhpX2ZpbmV0dW5yX2kyaV9yZWNhbGz6A9sBEgxVTktOT1dOX01PREUgACoNTk9fSU1BR0VfTU9ERTotCAAQ8AkYpgYiI3YyLTNlYjBjMTE0NmI2MjJmNTcxNWY5NzJhMjBlZDUwMzY2Oi0IABDwCRiaCyIjdjItNmM1ZWVkNjExNjk3MmRhMGJiMGNhNDQyYzEzYzY4NTA6LQgAEPAJGIAEIiN2Mi1mZTMwZmI0YjE0MGIzNmQyOTZkYTAyNzVlMzNiYjdhZDotCAAQ8AkYpw0iI3YyLTZlZDZiZDZmNzExNWM4Y2MyMjY0MGNjMzVmNDdmZWIxgAQAiAQAkgQGTm9ybWFsmgQBM6AEAKgEALAEALoEAmFpwgQDNDAwyAQA0gQP5o6o6I2Q5bey5pu05paw2AQA8AQA+QQAAADALLqQP4EFAAAAAAAAAACJBUICbd62jLI/kgUAmgUDZGZ0ogUDZGZ0sgUBMbkFAAAAAAAAAADQBQDgBQDoBQDwBRiQBgCgBosBqAYBkgIuCgk3NjQzMDI2ODgSEzE5OTE5NzUyNTcwOTE4OTI0MzYYBCIKSU1BR0VfVEVYVA==",
      "action_card": false
    },
    {
      "id": "139_1767705716.535",
      "type": "feed",
      "offset": 139,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705716,
      "updated_time": 1767705716,
      "target": {
        "excerpt": "简单点说就是，服从性不高的人不会入利益关系不大的局... 因为服从性不高的人都有一个特点，那就是能看见事件的本质。 这类人能看得清自己与事件发生的关系，明白对自己来说，什么是重点、什么不是重点。 这也叫主体性，通常这类人都是以不反驳争辩来表现的。 或者你看看那些服从性高的人都是什么样的？ 那些服从性高的人，大概率往往以吵架争执的形式呈现，这就是一种隐晦的服从性的证明。 好比说当你有一个非常相信的想法，却…",
        "url": "https://api.zhihu.com/answers/1990184916487538579",
        "thanks_count": 9,
        "preview_type": "default",
        "is_labeled": false,
        "is_copyable": false,
        "preview_text": "",
        "reshipment_settings": "disallowed",
        "segment_infos": [
          {
            "pid": "sn9Yrgk8",
            "text": "这本质就是为了获得领导认可的反驳与争吵...",
            "marks": [
              {
                "start_index": 0,
                "end_index": 22,
                "seg_info": {
                  "seg_ids": [
                    "1991136088698418498"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          }
        ],
        "visited_count": 23238,
        "vote_next_step": "vote",
        "id": "1990184916487538579",
        "excerpt_new": "简单点说就是，服从性不高的人不会入利益关系不大的局... 因为服从性不高的人都有一个特点，那就是能看见事件的本质。 这类人能看得清自己与事件发生的关系，明白对自己来说，什么是重点、什么不是重点。 这也叫主体性，通常这类人都是以不反驳争辩来表现的。 或者你看看那些服从性高的人都是什么样的？ 那些服从性高的人，大概率往往以吵架争执的形式呈现，这就是一种隐晦的服从性的证明。 好比说当你有一个非常相信的想法，却…",
        "content": "<p data-pid=\"MTeJw6lu\">简单点说就是，服从性不高的人不会入利益关系不大的局...</p><p data-pid=\"YGPQtgBJ\">因为服从性不高的人都有一个特点，那就是能看见事件的本质。</p><p data-pid=\"A2plPaQj\">这类人能看得清自己与事件发生的关系，明白对自己来说，什么是重点、什么不是重点。</p><p data-pid=\"YaMt_DEo\">这也叫主体性，通常这类人都是以不反驳争辩来表现的。</p><p data-pid=\"GSpzg5g4\">或者你看看那些服从性高的人都是什么样的？</p><p data-pid=\"Y9fiPavg\">那些服从性高的人，大概率往往以吵架争执的形式呈现，这就是一种隐晦的服从性的证明。</p><p data-pid=\"7pGzBjXy\">好比说当你有一个非常相信的想法，却在和那些与你持反对意见的争执对错的时候。</p><p data-pid=\"fERXJMRQ\">你在表达的就是隐形的去对对方思考逻辑的服从...</p><p data-pid=\"wFpA1r2K\">因为这个行为的本质，是在获得对方的认可。</p><p data-pid=\"yC9RPqec\">在工作中我见过很这样的情况，员工a在工作，领导路过顺口提了一句，要细心， 这个非常重要。</p><p data-pid=\"9YC1dvET\">这时候a就好像炸毛了一样，立马反驳，说已经很细心了。</p><p data-pid=\"sn9Yrgk8\">这本质就是为了获得领导认可的反驳与争吵...</p><p data-pid=\"IL96aeXA\">往往这类人，被认可一下，那就会唯你马首是瞻。</p><p data-pid=\"8LkNfGxt\">有的段位高的领导，如果他知道你是上述的人，他不会轻易给予你认可。</p><p data-pid=\"w-Gr4LY4\">会让你有种若即若离的感觉，等累积到一定量级后...</p><p data-pid=\"IfXgK_fl\">再给予你认可或褒奖，你就会死心塌地，这就是什么驭人之术。</p><p data-pid=\"OOTXaAbW\">而这种驭人之术产生的本质是对方心里的脆弱...</p><p data-pid=\"DoI1AuRX\">当你在没察觉到的情况下，头脑被社会给你的知识与信息塞满的时候。</p><p data-pid=\"3fettIhl\">你的思想体系立足于外界对你的培养，而不是自己的内生智慧，或自己主动求取和思考的内容。</p><p data-pid=\"3TsEsER5\">这是一种更为隐形的服从...</p><p data-pid=\"wuLlZipj\">当你在面对各类威胁和暴力的时候，短暂性的服从后，却在事情没发生的时候，为了避免下一次再次发生，从而规训自己的需求。</p><p data-pid=\"xqMZ8Unk\">将对自己的压抑形成习惯，以换取平安，这也是服从。</p><p data-pid=\"BsXTKvOO\">好比有人在每次都找准了最适合摧毁你自信的时机打压你，那巨大的自我否定侵袭而来。</p><p data-pid=\"gCGkjFrF\">而为了保护好自己，就会直接消磨了自己对自己的信任。</p><p data-pid=\"5sZbPNSn\">于是哪怕对方不这样了，你也在相同的事情下否认自己。</p><p data-pid=\"Q6xSfIFa\">最后就形成了习惯，而早早忘了原本那个自信的自己。</p><p data-pid=\"EsPCEJcs\">而服从性不仅仅是在人际交往中点头哈腰，也不是在面对其他人的诉求时总说yes。</p><p data-pid=\"dy5nISK0\">服从性非常广泛...</p><p data-pid=\"_tp8m21y\">这种服从性谁都会有，本质上是人性对于未知的恐惧来寻求盟友，进而产生依赖。</p><p data-pid=\"gBnDziAV\">多强大的人都会有...</p><p data-pid=\"Vt-nhj8V\">你看看那些大人物面对段位比他高，实力比他强，资源比他广，有所相求和依恋的时候，有没有服从性？</p><p data-pid=\"7D8aGjUg\">也有的...\t</p><p data-pid=\"zLWVwzwB\">但区别在于他们在一次一次做事的过程中会克服了这些服从性，不管是通过一件事挣到钱抑或者是拿到了成就，他们用成绩完成了对自身价值的认可。</p><p data-pid=\"hii6db-P\">然后在一次又一次对自身价值的认可的过程中，会慢慢克服这种服从性。</p><p data-pid=\"3F6nODrE\">不再依赖他人认可，而是会客观根据市场来矫正自身。</p><p data-pid=\"Re7pbso7\">以上~ <a class=\"member_mention\" href=\"https://www.zhihu.com/people/7da508b3129cef2b0105fc704dd7249d\" data-hash=\"7da508b3129cef2b0105fc704dd7249d\" data-hovercard=\"p$b$7da508b3129cef2b0105fc704dd7249d\">@知乎职场</a> </p>",
        "answer_type": "normal",
        "navigator_vote": false,
        "type": "answer",
        "favorite_count": 266,
        "is_navigator": false,
        "created_time": 1767277059,
        "voteup_count": 216,
        "question": {
          "is_following": false,
          "question_type": "normal",
          "answer_count": 0,
          "follower_count": 0,
          "comment_count": 55,
          "created": 1723329113,
          "type": "question",
          "url": "https://api.zhihu.com/questions/663984850",
          "author": {
            "user_type": "people",
            "url_token": "54-1-56-68",
            "name": "馬鹿宇鹏",
            "avatar_url": "https://picx.zhimg.com/50/v2-ea2fcb687cf633035c63790331eb0f7e_l.jpg?source=b6762063",
            "is_following": false,
            "is_followed": false,
            "id": "789a09b5095683583dbfafc42b9c7709",
            "headline": "",
            "is_org": false,
            "gender": 0,
            "followers_count": 49,
            "url": "https://api.zhihu.com/people/789a09b5095683583dbfafc42b9c7709"
          },
          "detail": "",
          "title": "服从性不高的都是什么人呢？",
          "bound_topic_ids": [
            404,
            1576,
            13740,
            15317,
            26529
          ],
          "relationship": {
            "is_author": false
          },
          "id": "663984850",
          "excerpt": ""
        },
        "allow_segment_interaction": true,
        "author": {
          "id": "efb57a875adee58192841ab2ba81bc3e",
          "url": "https://api.zhihu.com/people/efb57a875adee58192841ab2ba81bc3e",
          "user_type": "people",
          "url_token": "71-28-41-13",
          "is_org": false,
          "gender": 0,
          "followers_count": 5003,
          "is_following": false,
          "name": "小鸟伏特加",
          "headline": "喜欢~我的话，可以赞同关注友善交流❤️",
          "avatar_url": "https://picx.zhimg.com/50/v2-0424164192feca0dae48c810dc1f8c44_l.jpg?source=b6762063",
          "is_followed": false
        },
        "updated_time": 1767277059,
        "comment_count": 13,
        "relationship": {
          "is_thanked": false,
          "is_nothelp": false,
          "voting": 0
        }
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1990184916487538579}",
      "attached_info": "Cu0FCO/Ln9uNj/b0nQEQBBoJNzYzNjEzOTE5IIOE2soGKNgBMA1AiwFKKAoTVFNfU09VUkNFX0ZFRURSRV9WNRIBMBgAIAA6CnsicmF3IjoiIn1KKwoWVFNfU09VUkNFX0ZFRURSRV9NU19WMxIBMBgAIAA6CnsicmF3IjoiIn1aCTEwOTgyOTg3OWIgZWFlYTU0MDY2YzgxOWE2YTc5YjlmY2JlMWQ5MjIzMzRyEzE5OTAxODQ5MTY0ODc1Mzg1NzmKAQk2NjM5ODQ4NTCqAQlyZWNvbW1lbmTCASBlZmI1N2E4NzVhZGVlNTgxOTI4NDFhYjJiYTgxYmMzZfIBCggMEgZOb3JtYWzyASgIChIkNDU2OGU5MjgtNWYwYS00YWY3LTg1ODYtMjRjNzIzMmM4ZDQ38gEGCAsSAjI0ggIAiALxyeKbuTOSAiBlZmI1N2E4NzVhZGVlNTgxOTI4NDFhYjJiYTgxYmMzZZoCAMoCFEZpcnN0QnJ1c2hXZWlnaHRSdWxlygIWU2hvckludGVyZXN0V2VpZ2h0UnVsZcoCG0ludGVyYWN0aW9uU2hvckludGVyZXN0UnVsZdoCE1RTX1NPVVJDRV9GRUVEUkVfVjXoAgP6AgtOT1JNQUxfRkxPV4oDIGVjY2ExMWI2YWU4ZTRkOTY4MWEwZmNiYzQ5MzM4N2U1mgMNCgJ2MhAAGgVvdGhlcqgDxrUB2AMA6gMZZmVlZHJlV2FybVN1Y2Nlc3NSZWNhbGxlcvoDHxIMVU5LTk9XTl9NT0RFIAAqDU5PX0lNQUdFX01PREWABACIBACSBAZOb3JtYWyaBAEzoAQAqAQAsAQAugQCYWnCBAM0MDDIBADSBA/mjqjojZDlt7Lmm7TmlrDYBADwBAD5BAAAAAASaJg/gQUAAAAAAAAAAIkFQgJt3raMsj+SBQCaBQNkZnSiBQNkZnSyBQExuQUAAAAAAAAAANAFAOAFAOgFAPAFGJAGAKAGjAGoBgOSAi4KCTc2MzYxMzkxORITMTk5MDE4NDkxNjQ4NzUzODU3ORgEIgpJTUFHRV9URVhU",
      "action_card": false
    },
    {
      "id": "140_1767705716.545",
      "type": "feed",
      "offset": 140,
      "verb": "TOPIC_ACKNOWLEDGED_ARTICLE",
      "created_time": 1767705716,
      "updated_time": 1767705716,
      "target": {
        "excerpt_new": "本文深入剖析 Go 语言中多种锁（Mutex、RWMutex、WaitGroup、Once、Cond）的底层实现原理，结合 atomic 原子操作与 sema 信号量机制，揭示锁的本质和并发安全保障机制，帮助读者以第一性原理理解 Go 并发锁的内部运作。 本篇将进入 Go 语言中关于锁的底层原理的探讨，笔者有幸阅读过 Mara Bos 的 《Rust Atomics and Locks》 ，该书对锁这一概念和底层原理进行了非常详尽的探讨，并且给出了 Rust 中 SpinLock、Mutex、RWMutex、Ch…",
        "navigator_vote": false,
        "title": "深入 Go 语言核心：锁",
        "comment_permission": "all",
        "created": 1765852673,
        "linkbox": {
          "category": "",
          "pic": "",
          "title": "",
          "url": ""
        },
        "content": "<hr/><p data-pid=\"OTYLD8Cu\">本文深入剖析 Go 语言中多种锁（Mutex、RWMutex、WaitGroup、Once、Cond）的底层实现原理，结合 atomic 原子操作与 sema 信号量机制，揭示锁的本质和并发安全保障机制，帮助读者以第一性原理理解 Go 并发锁的内部运作。 </p><hr/><p data-pid=\"cYQKP_f1\">本篇将进入 Go 语言中关于锁的底层原理的探讨，笔者有幸阅读过 Mara Bos 的 <a href=\"https://link.zhihu.com/?target=https%3A//marabos.nl/atomics/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《Rust Atomics and Locks》</a>，该书对锁这一概念和底层原理进行了非常详尽的探讨，并且给出了 Rust 中 SpinLock、Mutex、RWMutex、Channel 和 Arc 等基础并发工具的手写实战案例，对于想更加深入理解并发编程尤其那些想手写并发工具的读者，非常推荐阅读该书。我在我的专栏 <a href=\"https://zhuanlan.zhihu.com/column/c_1749021366719090688\" class=\"internal\" target=\"_blank\">Rust 修炼之路</a>也分享了我阅读该书的一些笔记，欢迎阅读👏🏻。</p><blockquote data-pid=\"bacGUctD\">特此声明，本篇是笔者基于 Go 1.25.3 版本源码、并与 Google Gemini 3Pro 共创所作，非常庆幸在当今 AI 时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</blockquote><h2>结论先行</h2><p data-pid=\"RyTyWRai\">本篇我们将探讨 Go 语言中的各种”锁”的底层实现原理，包括 <code>Mutex</code>、<code>RWMutex</code>、<code>WaitGroup</code> 和 <code>Once</code> 。它们都离不开两个核心基础：<code>atomic</code> 和 <code>sema</code>：</p><ul><li data-pid=\"5bSdRnDo\"><code>atomic</code> 即原子变量，是一种硬件层面加锁的机制，可以保证基本类型在高并发下的并发安全性，实现原子操作。</li><li data-pid=\"f3uaniUY\"><code>sema</code> 全称 semaphore，也叫信号锁 / 信号量锁，它的核心是一个 <code>uint32</code> 类型的值，含义是同时可并发的协程数量。在 Go 语言里面，每个 <code>seam</code> 背后都对应一个 <code>semaRoot</code>结构体。</li></ul><p data-pid=\"qLBwhcpu\">我们先给出上述几种并发工具的简要概述，后文再进行详细阐述：</p><ul><li data-pid=\"yIdjnvzX\"><code>Mutex</code>：互斥锁，只能有一个持有者。  </li><ul><li data-pid=\"8Fdijkig\">正常模式：得到锁返回，得不到锁自旋，自旋多了就饥饿。</li><li data-pid=\"WrpZwUjg\">饥饿模式：不自选，直接入队等待。依次从队里唤醒协程并授予锁。</li></ul><li data-pid=\"QsxFRxCB\"><code>RWMutex</code>：读写锁，只能一个写，可以同时多个读。</li><li data-pid=\"Jg8ZxqYG\"><code>WaitGroup</code>：一组协程等待另外一组协程全部执行完毕再执行。</li><li data-pid=\"h1bee7DE\"><code>Once</code>：控制一段代码在并发中只执行一次。</li><li data-pid=\"X-pOgo5i\"><code>Cond</code>：条件变量，允许多个 Goroutine 等待某个条件成立后被唤醒，常用于处理生产者-消费者模型。 </li></ul><h2>1. Go 锁的两大基础</h2><h3>1.1 原子操作</h3><p data-pid=\"6kQ1IoI0\">Go 在 <code>sync/atomic</code> 包提供了一系列基本类型的原子操作，使用这些操作，可以保证基本类型在高并发下的并发安全性，实现原子操作。</p><ul><li data-pid=\"vBuhNlt0\">SwapInt32</li><li data-pid=\"U_IqE84E\">CompareAndSwapInt32</li><li data-pid=\"dJspnxkF\">AddInt32</li><li data-pid=\"cV6eu2jo\">LoadInt32</li><li data-pid=\"rMv213lw\">StoreInt32</li></ul><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// AddInt32 atomically adds delta to *addr and returns the new value.\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"nf\">AddInt32</span><span class=\"p\">(</span><span class=\"nx\">addr</span> <span class=\"o\">*</span><span class=\"kt\">int32</span><span class=\"p\">,</span> <span class=\"nx\">delta</span> <span class=\"kt\">int32</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nx\">new</span> <span class=\"kt\">int32</span><span class=\"p\">)</span>\n</code></pre></div><p data-pid=\"ky4_3JYA\">查看 AMD64 的汇编时，我们会发现其中有一个 <code>LOCK</code> 指令：</p><div class=\"highlight\"><pre><code class=\"language-text\">// uint32 Xadd(uint32 volatile *val, int32 delta)\n// Atomically:\n//\t*val += delta;\n//\treturn *val;\nTEXT ·Xadd(SB), NOSPLIT, $0-20\n\tMOVQ\tptr+0(FP), BX\n\tMOVL\tdelta+8(FP), AX\n\tMOVL\tAX, CX\n\tLOCK\n\tXADDL\tAX, 0(BX)\n\tADDL\tCX, AX\n\tMOVL\tAX, ret+16(FP)\n\tRET</code></pre></div><p data-pid=\"LNX49TvA\">可以再看一下 ARM64 的汇编代码，我们会发现其中有：<code>LDADDALW</code>、<code>LDAXRW</code> 和 <code>STLXRW</code> 指令：</p><div class=\"highlight\"><pre><code class=\"language-text\">TEXT ·Xadd(SB), NOSPLIT, $0-20\n\tMOVD\tptr+0(FP), R0\n\tMOVW\tdelta+8(FP), R1\n#ifndef GOARM64_LSE\n\tMOVBU\tinternal∕cpu·ARM64+const_offsetARM64HasATOMICS(SB), R4\n\tCBZ \tR4, load_store_loop\n#endif\n\tLDADDALW\tR1, (R0), R2\n\tADD \tR1, R2\n\tMOVW\tR2, ret+16(FP)\n\tRET\n#ifndef GOARM64_LSE\nload_store_loop:\n\tLDAXRW\t(R0), R2\n\tADDW\tR2, R1, R2\n\tSTLXRW\tR2, (R0), R3\n\tCBNZ\tR3, load_store_loop\n\tMOVW\tR2, ret+16(FP)\n\tRET\n#endif</code></pre></div><p data-pid=\"KKr6z94Q\">概括来说：</p><blockquote data-pid=\"_q1vBFCv\">原子操作的底层实现依赖于 86 的 <code>lock</code> 前缀或 ARM 的 <code>LL/SC</code>，而这二者又依赖于硬件级别的协同机制，其核心是通过 <b>缓存一致性协议</b>、<b>总线仲裁</b> 和 <b>指令集层面的特殊支持</b> 来保证多核环境下的原子性和内存顺序。</blockquote><p data-pid=\"Qy-xn5Pz\">对于原子操作的底层原理和硬件层面的细节，感兴趣的读者可以阅读我这两篇笔记：</p><a href=\"https://zhuanlan.zhihu.com/p/6403936954\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a><a href=\"https://zhuanlan.zhihu.com/p/1921885256602072084\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">Rust 原理丨从汇编角度看原子操作</a><h3>1.2 sema 锁</h3><h3>1.2.1 概述</h3><ul><li data-pid=\"N21maK2G\">sema 锁全称 semaphore，也叫信号锁 / 信号量锁。</li><li data-pid=\"5k5Kw6vC\">sema 的核心是一个 <code>uint32</code> 类型的值，含义是同时可并发的协程数量。</li><li data-pid=\"FJb1v_rg\">每一个 sema 锁都对应一个 <code>semaRoot</code>结构体。</li><li data-pid=\"hG3vvfrp\"><code>semaRoot</code> 中有一个平衡二叉树用于协程排队。</li></ul><h3>1.2.2 数据结构</h3><p data-pid=\"jA7I6aT8\">在 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go%23L20\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">internal/sync/mutex.go#L20</a> 定义了 <code>Mutex</code> 的数据结构，如下：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// A Mutex is a mutual exclusion lock.\n</span><span class=\"c1\">//\n</span><span class=\"c1\">// See package [sync.Mutex] documentation.\n</span><span class=\"c1\"></span><span class=\"kd\">type</span> <span class=\"nx\">Mutex</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">state</span> <span class=\"kt\">int32</span>\n\t<span class=\"nx\">sema</span>  <span class=\"kt\">uint32</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"3hoNeF6z\">其中第二个元素 <code>sema</code>，便是一个 sema 锁，它本质上是一个 <code>semaRoot</code> 结构体的值。</p><p data-pid=\"5qUwEv6H\"><code>semaRoot</code> 定义在 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/runtime/sema.go%23L40\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">runtime/sema.go#L40</a>：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// Asynchronous semaphore for sync.Mutex.\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// A semaRoot holds a balanced tree of sudog with distinct addresses (s.elem).\n</span><span class=\"c1\">// Each of those sudog may in turn point (through s.waitlink) to a list\n</span><span class=\"c1\">// of other sudogs waiting on the same address.\n</span><span class=\"c1\">// The operations on the inner lists of sudogs with the same address\n</span><span class=\"c1\">// are all O(1). The scanning of the top-level semaRoot list is O(log n),\n</span><span class=\"c1\">// where n is the number of distinct addresses with goroutines blocked\n</span><span class=\"c1\">// on them that hash to the given semaRoot.\n</span><span class=\"c1\">// See golang.org/issue/17953 for a program that worked badly\n</span><span class=\"c1\">// before we introduced the second level of list, and\n</span><span class=\"c1\">// BenchmarkSemTable/OneAddrCollision/* for a benchmark that exercises this.\n</span><span class=\"c1\"></span><span class=\"kd\">type</span> <span class=\"nx\">semaRoot</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">lock</span>  <span class=\"nx\">mutex</span>          <span class=\"c1\">// 保护整个数据结构的锁\n</span><span class=\"c1\"></span>    <span class=\"nx\">treap</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span>         <span class=\"c1\">// Treap 的根节点\n</span><span class=\"c1\"></span>    <span class=\"nx\">nwait</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nx\">Uint32</span>  <span class=\"c1\">// 等待者数量（可无锁读取，用于快速判断）\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"c1\">// 简单理解：Runtime 内部专用锁\n</span><span class=\"c1\">// 通过一个 uintptr 字段同时存储状态标志位和等待 M 线程的指针栈（低 10 位是状态，高位是 M 链表头），\n</span><span class=\"c1\">// 直接用 OS 信号量阻塞 M 线程，禁用抢占，零分配，不触发 GC。\n</span><span class=\"c1\"></span><span class=\"kd\">type</span> <span class=\"nx\">mutex</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">lockRankStruct</span>\n\t<span class=\"nx\">key</span> <span class=\"kt\">uintptr</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// sudog (pseudo-g) 代表的是一个在等待队列中的 goroutine\n</span><span class=\"c1\"></span><span class=\"kd\">type</span> <span class=\"nx\">sudog</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">g</span> <span class=\"o\">*</span><span class=\"nx\">g</span>                <span class=\"c1\">// 指向等待的 goroutine\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// === Treap 二叉树指针 ===\n</span><span class=\"c1\"></span>    <span class=\"nx\">parent</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span>       <span class=\"c1\">// 父节点\n</span><span class=\"c1\"></span>    <span class=\"nx\">prev</span>   <span class=\"o\">*</span><span class=\"nx\">sudog</span>       <span class=\"c1\">// 左子节点\n</span><span class=\"c1\"></span>    <span class=\"nx\">next</span>   <span class=\"o\">*</span><span class=\"nx\">sudog</span>       <span class=\"c1\">// 右子节点\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// === 同地址等待链表 ===\n</span><span class=\"c1\"></span>    <span class=\"nx\">waitlink</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span>     <span class=\"c1\">// 链表中的下一个等待者\n</span><span class=\"c1\"></span>    <span class=\"nx\">waittail</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span>     <span class=\"c1\">// 链表尾部（只在头节点有效）\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// === 地址和优先级 ===\n</span><span class=\"c1\"></span>    <span class=\"nx\">elem</span>   <span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nx\">Pointer</span>  <span class=\"c1\">// 等待的地址（如 &amp;mutex.sema）\n</span><span class=\"c1\"></span>    <span class=\"nx\">ticket</span> <span class=\"kt\">uint32</span>          <span class=\"c1\">// Treap 的堆优先级（随机数）\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// === 统计和性能分析 ===\n</span><span class=\"c1\"></span>    <span class=\"nx\">waiters</span>     <span class=\"kt\">uint16</span>  <span class=\"c1\">// 链表中其他等待者的数量（头节点）\n</span><span class=\"c1\"></span>    <span class=\"nx\">acquiretime</span> <span class=\"kt\">int64</span>   <span class=\"c1\">// 开始等待的时间\n</span><span class=\"c1\"></span>    <span class=\"nx\">releasetime</span> <span class=\"kt\">int64</span>   <span class=\"c1\">// 被唤醒的时间\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-8e9aa0280b749f56b39d2cf5dbb022f4_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1884\" data-rawheight=\"818\" data-original-token=\"v2-bcbf864ecb3698ef917bda1afd000202\" class=\"origin_image zh-lightbox-thumb\" width=\"1884\" data-original=\"https://pic3.zhimg.com/v2-8e9aa0280b749f56b39d2cf5dbb022f4_r.jpg\"/></figure><h3>1.2.3 操作</h3><p data-pid=\"NB6Ln23U\"><b>当 unit32 &gt; 0 时，表示可以并发的协程个数</b></p><ul><li data-pid=\"dEr1W4ph\">获取锁：sema - 1， 获得锁成功</li><li data-pid=\"5XfSRBqF\">释放锁：sema + 1，释放锁成功</li></ul><p data-pid=\"l46Yqyty\"><b>当 unit32 = 0 时，表示没锁了，sema 锁退化成一个专用的休眠队列</b></p><ul><li data-pid=\"cWxP1Vmx\">获取锁：进入堆树等待，协程休眠；</li><li data-pid=\"7ka9kbd7\">释放锁：从堆树中取出一个协程并唤醒</li></ul><h3>1.2.4 semeacquire()</h3><p data-pid=\"OKexaVRY\"><a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/runtime/sema.go%23L146\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">semaacuqire()</a> 尝试递减计数器，失败则创建 <code>sudog</code> 加入等待队列并休眠，等待被唤醒。</p><ul><li data-pid=\"Q1xn0QQk\">sema &gt; 0：sema –</li><li data-pid=\"C72Zb2ba\">sema = 0：将协程放入堆树中等待，并休眠</li></ul><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-30daf50516ddeccb8eb3673ec3e2260c_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2713\" data-rawheight=\"1080\" data-original-token=\"v2-b5f87a4a5f8157f1bc5f27295f3aec7a\" class=\"origin_image zh-lightbox-thumb\" width=\"2713\" data-original=\"https://pica.zhimg.com/v2-30daf50516ddeccb8eb3673ec3e2260c_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"nf\">semacquire1</span><span class=\"p\">(</span><span class=\"nx\">addr</span> <span class=\"o\">*</span><span class=\"kt\">uint32</span><span class=\"p\">,</span> <span class=\"nx\">lifo</span> <span class=\"kt\">bool</span><span class=\"p\">,</span> <span class=\"nx\">profile</span> <span class=\"nx\">semaProfileFlags</span><span class=\"p\">,</span> <span class=\"nx\">skipframes</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"nx\">reason</span> <span class=\"nx\">waitReason</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">gp</span> <span class=\"o\">:=</span> <span class=\"nf\">getg</span><span class=\"p\">()</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">gp</span> <span class=\"o\">!=</span> <span class=\"nx\">gp</span><span class=\"p\">.</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">curg</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">throw</span><span class=\"p\">(</span><span class=\"s\">&#34;semacquire not on the G stack&#34;</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 快捷路径，先进行一次简单的原子操作尝试获取锁，成功则直接返回\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nf\">cansemacquire</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span>\n\t<span class=\"p\">}</span>\n\n        <span class=\"c1\">// 慢速路径：\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// Harder case:\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//\tincrement waiter count\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//\ttry cansemacquire one more time, return if succeeded\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//\tenqueue itself as a waiter\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//\tsleep\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//\t(waiter descriptor is dequeued by signaler)\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 获取 sema 底层的 semaRoot，并为它赋初始值\n</span><span class=\"c1\"></span>\t<span class=\"nx\">s</span> <span class=\"o\">:=</span> <span class=\"nf\">acquireSudog</span><span class=\"p\">()</span>\n\t<span class=\"nx\">root</span> <span class=\"o\">:=</span> <span class=\"nx\">semtable</span><span class=\"p\">.</span><span class=\"nf\">rootFor</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span>\n\t<span class=\"k\">for</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">lockWithRank</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">lockRankRoot</span><span class=\"p\">)</span>\n\t\t<span class=\"c1\">// 1. 自增等待者数量\n</span><span class=\"c1\"></span>\t\t<span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">nwait</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\t\t<span class=\"c1\">// 2. 再次尝试获取锁，成功则可以返回了\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nf\">cansemacquire</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">nwait</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\t\t\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\t\t\t<span class=\"k\">break</span>\n\t\t<span class=\"p\">}</span>\n    <span class=\"c1\">// 3. 还是失败，则进入休眠队列\n</span><span class=\"c1\"></span>\t\t<span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nf\">queue</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">,</span> <span class=\"nx\">s</span><span class=\"p\">,</span> <span class=\"nx\">lifo</span><span class=\"p\">)</span>\n    <span class=\"c1\">// 4. 调用 gopark() 休眠协程（不了解 gopark 可以先去了解一下 GMP 底层原理）\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">goparkunlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">reason</span><span class=\"p\">,</span> <span class=\"nx\">traceBlockSync</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"o\">+</span><span class=\"nx\">skipframes</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">ticket</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"nf\">cansemacquire</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"k\">break</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">blockevent</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span><span class=\"o\">-</span><span class=\"nx\">t0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">+</span><span class=\"nx\">skipframes</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"nf\">releaseSudog</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 判断是否可以获取 sema 锁\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"nf\">cansemacquire</span><span class=\"p\">(</span><span class=\"nx\">addr</span> <span class=\"o\">*</span><span class=\"kt\">uint32</span><span class=\"p\">)</span> <span class=\"kt\">bool</span> <span class=\"p\">{</span>\n\t<span class=\"k\">for</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">v</span> <span class=\"o\">:=</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span>\n    <span class=\"c1\">// sema 为 0，表示没锁了，这个时候是一个等待队列，无法直接获取锁\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">v</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"k\">return</span> <span class=\"kc\">false</span>\n\t\t<span class=\"p\">}</span>\n    <span class=\"c1\">// sema 大于 0，说明这个时候有可以并发的协程个数，尝试进行 cas 获取锁，成功则返回 true\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Cas</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">,</span> <span class=\"nx\">v</span><span class=\"p\">,</span> <span class=\"nx\">v</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"k\">return</span> <span class=\"kc\">true</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>1.2.5 semarelease()</h3><p data-pid=\"xa7kD0hl\"><a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/runtime/sema.go%23L207\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">semarelease()</a> 递增计数器，如果有等待者则从队列中取出一个 <code>sudog</code> 并唤醒对应的 goroutine，<b>handoff</b> 模式下直接移交锁并让出 CPU。</p><ul><li data-pid=\"_xznXOyA\">无等待中的协程：直接返回</li><li data-pid=\"ybaDOVfx\">有等待中的协程：从堆树中出队一个协程，唤醒，并调度到当前 P 的 runq 中</li></ul><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-b2cbca695e2cc5243921d27f551a6f5f_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1098\" data-original-token=\"v2-509b714103ed94955366a694031f4163\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-b2cbca695e2cc5243921d27f551a6f5f_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// semrelease1 释放一个信号量，如果有等待者则唤醒一个 goroutine\n</span><span class=\"c1\">// addr: 信号量地址（如 &amp;mutex.sema）\n</span><span class=\"c1\">// handoff: 是否直接移交（饥饿模式下为 true，直接把锁交给被唤醒者）\n</span><span class=\"c1\">// skipframes: 用于性能分析时跳过的栈帧数\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"nf\">semrelease1</span><span class=\"p\">(</span><span class=\"nx\">addr</span> <span class=\"o\">*</span><span class=\"kt\">uint32</span><span class=\"p\">,</span> <span class=\"nx\">handoff</span> <span class=\"kt\">bool</span><span class=\"p\">,</span> <span class=\"nx\">skipframes</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// 通过 addr 的哈希值找到对应的 semaRoot\n</span><span class=\"c1\"></span>\t<span class=\"nx\">root</span> <span class=\"o\">:=</span> <span class=\"nx\">semtable</span><span class=\"p\">.</span><span class=\"nf\">rootFor</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span>\n\n\t<span class=\"c1\">// ===== 关键操作：先递增信号量计数器 =====\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 无论有没有等待者，都原子地将 *addr 加 1\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 这相当于传统信号量的 V 操作，释放一个&#34;资源&#34;\n</span><span class=\"c1\"></span>\t<span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Xadd</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n\t<span class=\"c1\">// ===== Fast Path：快速检查是否有等待者 =====\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 注意顺序很重要！必须先执行 Xadd，再检查 nwait\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 原因：防止 &#34;错过唤醒&#34; 的竞态条件\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// - semacquire 的顺序是：先 nwait++，再 cansemacquire，最后 gopark\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// - 如果我们先检查 nwait 再 Xadd，可能在两步之间 semacquire 刚好 nwait++\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//   导致我们误以为没有等待者而不唤醒，但 goroutine 已经睡眠了\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">nwait</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span>  <span class=\"c1\">// 没有等待者，直接返回（信号量值已经被递增了）\n</span><span class=\"c1\"></span>\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// ===== Slow Path：有等待者，需要唤醒一个 =====\n</span><span class=\"c1\"></span>        <span class=\"c1\">//\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 获取 semaRoot 的锁，保护等待队列的并发访问\n</span><span class=\"c1\"></span>\t<span class=\"nf\">lockWithRank</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">lockRankRoot</span><span class=\"p\">)</span>\n\n\t<span class=\"c1\">// 持锁后再次检查 nwait，因为可能在获取锁之前已经被其他人消费了\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">nwait</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 场景：我们在获取锁期间，另一个 goroutine 可能：\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 1. 调用了 semacquire 并通过 cansemacquire 成功获取（消费了我们递增的值）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 2. 减少了 nwait 计数\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 所以不需要再唤醒任何人了\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 从等待队列中取出一个等待者（sudog）\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// s: 要唤醒的 sudog\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// t0: 当前时间（用于性能统计）\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// tailtime: 队尾等待者的开始等待时间（用于计算平均等待时间）\n</span><span class=\"c1\"></span>\t<span class=\"nx\">s</span><span class=\"p\">,</span> <span class=\"nx\">t0</span><span class=\"p\">,</span> <span class=\"nx\">tailtime</span> <span class=\"o\">:=</span> <span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nf\">dequeue</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span>\n\n\t<span class=\"k\">if</span> <span class=\"nx\">s</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 成功取出一个等待者，减少等待者计数\n</span><span class=\"c1\"></span>\t\t<span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">nwait</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 尽快释放锁，因为后续操作可能很慢（甚至可能让出 CPU）\n</span><span class=\"c1\"></span>\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">root</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">s</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// ===== Handoff 模式：直接移交锁 =====\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">handoff</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nf\">cansemacquire</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// handoff=true 表示饥饿模式\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 尝试提前消费信号量（将 *addr 减 1）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 如果成功，设置 ticket=1，告诉被唤醒的 goroutine：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// &#34;你不需要竞争了，锁已经是你的了&#34;\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">ticket</span> <span class=\"p\">=</span> <span class=\"mi\">1</span>\n\t\t<span class=\"p\">}</span>\n\n\t\t<span class=\"c1\">// ===== 唤醒 goroutine =====\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 将 sudog 对应的 goroutine 标记为可运行\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 并将其加入到当前 P 的 runnext 位置（优先运行）\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">readyWithTime</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"o\">+</span><span class=\"nx\">skipframes</span><span class=\"p\">)</span>\n\n\t\t<span class=\"c1\">// ===== Direct G Handoff：直接切换到被唤醒者 =====\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">ticket</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nf\">getg</span><span class=\"p\">().</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">locks</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nf\">getg</span><span class=\"p\">()</span> <span class=\"o\">!=</span> <span class=\"nf\">getg</span><span class=\"p\">().</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">g0</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// 条件满足时，主动让出 CPU 给被唤醒者立即运行：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - s.ticket == 1：已经直接移交了锁\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - getg().m.locks == 0：当前没有持有其他 runtime 锁\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - getg() != getg().m.g0：不在系统栈上\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// readyWithTime 已经把被唤醒者放到了 P 的 runnext 位置\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 现在调用 goyield() 主动让出时间片：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 被唤醒者继承我们的时间片，立即开始运行\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 避免高竞争场景下某个 goroutine 霸占 P\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - goyield 会把当前 G 放到本地队列（不是全局队列）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 只在饥饿模式（handoff=true）下这样做，因为：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 正常模式：被唤醒者可能竞争失败，让出 CPU 会浪费\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 饥饿模式：已经直接移交，保证能获取锁，不会浪费\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 相关讨论见 issue 33747\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nf\">goyield</span><span class=\"p\">()</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>1.2.6 深度理解</h3><p data-pid=\"R5dJjDZg\"><code>sema</code> 是 Go <code>sync.Mutex</code> 连接 <b>Go 运行时 (Runtime)</b> 和 <b>操作系统 (OS)</b> 的关键枢纽。 <code>sema</code> 就是用来解决”<b><u>拿不到锁的 Goroutine 到底去了哪里、怎么睡、怎么醒</u></b>“的关键问题。</p><p data-pid=\"ZjUnztkx\">我们要从以下三个层次由浅入深地理解 <code>sema</code>：</p><ol><li data-pid=\"nmj4Yum8\"><b>数据结构层</b>：它是怎么存储等待者的？</li><li data-pid=\"4bE9luwb\"><b>运行时层 (Runtime)</b>：Go 如何高效管理成千上万个锁？</li><li data-pid=\"NfRBkNXV\"><b>操作系统层 (OS)</b>：底层的 <code>futex</code> 到底在做什么？</li></ol><h3>1.2.6.1 第一层：它在内存中是什么？</h3><p data-pid=\"TgOhvVgt\">在 <code>sync.Mutex</code> 的定义中：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Mutex</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">state</span> <span class=\"kt\">int32</span>\n    <span class=\"nx\">sema</span>  <span class=\"kt\">uint32</span> <span class=\"c1\">// &lt;--- 就是它\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"JQrA7VxX\">前面我们讨论过，<b><code>sema</code> 本质上只是一个内存地址（Address）</b>。</p><ul><li data-pid=\"YsVGV3OF\"><b>作为 Key</b>：Go 运行时并不关心 <code>sema</code> 变量里存的具体数值是多少（虽然它确实会变），运行时真正关心的是 <code>&amp;sema</code>（这个变量在内存中的地址）。</li><li data-pid=\"f17SogR8\"><b>全局哈希表</b>：Go 运行时维护了一个全局的哈希表（<code>semTable</code>），在这个表中：  </li><ul><li data-pid=\"_G91B8IQ\"><b>Key</b> <code>&amp;sema</code> (Mutex 中 sema 字段的内存地址)。</li><li data-pid=\"UmTqsVxj\"><b>Value</b> 一个等待队列（平衡二叉树），里面躺着一个个正在睡觉的 Goroutine。</li></ul></ul><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">var</span> <span class=\"nx\">semtable</span> <span class=\"nx\">semTable</span>\n\n<span class=\"c1\">// Prime to not correlate with any user patterns.\n</span><span class=\"c1\"></span><span class=\"kd\">const</span> <span class=\"nx\">semTabSize</span> <span class=\"p\">=</span> <span class=\"mi\">251</span>\n\n<span class=\"kd\">type</span> <span class=\"nx\">semTable</span> <span class=\"p\">[</span><span class=\"nx\">semTabSize</span><span class=\"p\">]</span><span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">root</span> <span class=\"nx\">semaRoot</span>\n\t<span class=\"nx\">pad</span>  <span class=\"p\">[</span><span class=\"nx\">cpu</span><span class=\"p\">.</span><span class=\"nx\">CacheLinePadSize</span> <span class=\"o\">-</span> <span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nf\">Sizeof</span><span class=\"p\">(</span><span class=\"nx\">semaRoot</span><span class=\"p\">{})]</span><span class=\"kt\">byte</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">t</span> <span class=\"o\">*</span><span class=\"nx\">semTable</span><span class=\"p\">)</span> <span class=\"nf\">rootFor</span><span class=\"p\">(</span><span class=\"nx\">addr</span> <span class=\"o\">*</span><span class=\"kt\">uint32</span><span class=\"p\">)</span> <span class=\"o\">*</span><span class=\"nx\">semaRoot</span> <span class=\"p\">{</span>\n\t<span class=\"k\">return</span> <span class=\"o\">&amp;</span><span class=\"nx\">t</span><span class=\"p\">[(</span><span class=\"nb\">uintptr</span><span class=\"p\">(</span><span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nf\">Pointer</span><span class=\"p\">(</span><span class=\"nx\">addr</span><span class=\"p\">))</span><span class=\"o\">&gt;&gt;</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"nx\">semTabSize</span><span class=\"p\">].</span><span class=\"nx\">root</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"kLVv-RVj\"><b>为什么这么设计？</b> 如果每个 Mutex 都向操作系统申请一个专门的内核信号量对象，开销太大了。Go 程序中可能有数百万个 Mutex，通过把它们映射到一个固定大小的全局哈希表中，Go 实现了极高的扩展性。</p><h3>1.2.6.2 第二层：运行时调度 (GMP)</h3><p data-pid=\"s2zy6a5D\">当 <code>state</code> 字段判断需要阻塞时，Go 会调用 <code>runtime_SemacquireMutex(&amp;m.sema, ...)</code>（其实背后就是上面提到的 <code>semacuqire()</code>）。这背后发生了什么？这是与 <b>GMP 模型</b> 交互的核心。</p><p data-pid=\"PkZlQbMn\">当 <code>state</code> 字段判断需要阻塞时，Go 会调用 <code>runtime_SemacquireMutex(&amp;m.sema, ...)</code>。这背后发生了什么？这是与 <b>GMP 模型</b> 交互的核心。</p><p data-pid=\"yhI1xE0m\"><b>1. 包装：从 G 到 Sudog</b></p><p data-pid=\"AvBTQ5Us\">Goroutine (<code>G</code>) 是不能直接挂在链表上的。Go 使用了一个中间结构体叫 <code>sudog</code>。</p><ul><li data-pid=\"mzTaVDkQ\">当一个 G 需要阻塞时，运行时会创建一个 <code>sudog</code>，把这个 G 包装进去。</li><li data-pid=\"quwh4mzp\">这个 <code>sudog</code> 代表了”一个在特定信号量上等待的 G”。</li></ul><p data-pid=\"XHVR4dZ6\"><b>2. 入队与休眠</b></p><ol><li data-pid=\"gH61Gtez\"><b>计算哈希</b>：根据 <code>&amp;sema</code> 的地址，算出它在全局 <code>semTable</code> 中的位置。</li><li data-pid=\"EnL4DC7T\"><b>挂载</b>：把包装好的 <code>sudog</code> 挂到该位置的 Treap 尾部。</li><li data-pid=\"rmjZ7Zhr\"><b>切出 (Park)</b>：  </li></ol><ul><li data-pid=\"FGvhyy_C\">调用 <code>goparkunlock</code>。</li><li data-pid=\"gTUy9H7V\"><b>关键点</b>：当前的 <b>M (系统线程)</b> 会断开与当前 <b>G</b> 的关系。</li><li data-pid=\"esXbWJFi\">G 的状态从 <code>Running</code> 变为 <code>Waiting</code>。</li><li data-pid=\"GYR-f0Nl\"><b>M</b> 并没有睡觉，它会去 <b>P (处理器)</b> 的本地队列里找<b>下一个</b>可运行的 G 来执行。</li><li data-pid=\"8ivbluLj\"><b>这就是 Go 高并发的精髓</b>：用户层面的阻塞锁，并没有阻塞底层的系统线程（除非没有其他工作可做）。</li></ul><p data-pid=\"nV9dzqUc\"><b>3. 唤醒 (Handoff)</b></p><p data-pid=\"N8y9ZK_n\">当 <code>Unlock</code> 调用 <code>runtime_Semrelease(&amp;m.sema)</code> （即 <code>semarelease()</code>）时：</p><ol><li data-pid=\"CBUgm29e\"><b>查找</b>：再次根据 <code>&amp;sema</code> 地址去全局哈希表里找。</li><li data-pid=\"sLH0lYez\"><b>出队</b>：取出链表头部的 <code>sudog</code>。</li><li data-pid=\"sYRzqWK7\"><b>调度</b>：  </li></ol><ul><li data-pid=\"bnWA6EO4\">把 <code>sudog</code> 里的 G 取出来。</li><li data-pid=\"rpd25igf\">将 G 的状态从 <code>Waiting</code> 改为 <code>Runnable</code>。</li><li data-pid=\"IhCgzaTg\">把它扔到当前 P 的运行队列或者全局运行队列中，等待被 M 执行。</li></ul><h3>1.2.6.3 第三层：操作系统原语</h3><p data-pid=\"qZ9sZMB_\">这就到了物理实现的底座了。如果 M 发现没有别的 G 可以执行了，或者 Go 运行时本身的某些同步需要，它最终必须依赖操作系统的能力来让 CPU 停下来。</p><p data-pid=\"CXb27DkF\">在 Linux 平台上，<code>sema</code> 的底层实现依赖于 <b>Futex (Fast Userspace Mutex)</b>。</p><p data-pid=\"5xcLy4g3\"><code>Futex</code> 是 Linux 内核提供的一种机制，它的核心理念是：<b>即使需要内核介入，也要尽量减少陷入内核的次数。</b></p><p data-pid=\"PjvNfAoc\">它包含两个操作：</p><ol><li data-pid=\"barcmXOx\"><b>User Space Check (用户态检查)</b>：先检查内存中的一个整数（就是 <code>sema</code> 的值）。如果条件满足（比如有信号），直接走人，完全不涉及内核。</li><li data-pid=\"kqvEZbVl\"><b>Kernel Wait (内核态等待)</b>：只有当条件不满足时，才发起系统调用（System Call），让内核把线程挂起。</li></ol><p data-pid=\"bcGx_kf9\">在 <code>runtime/os_linux.go</code> 中，你会看到类似这样的汇编或封装调用：</p><ul><li data-pid=\"BASiGqm-\"><b>休眠 (<code>futexsleep</code>)</b>： 调用 <code>futex(addr, FUTEX_WAIT, val, ...)</code>。 意思就是：<i>“内核老兄，请你看看 <code>addr</code> 这个内存地址的值是不是 <code>val</code>？如果是，就把我（当前线程 M）挂起；如果不是，说明中间有人改过（可能有信号了），那我就不睡了，直接返回。”</i></li><li data-pid=\"jsSk9FWa\"><b>唤醒 (<code>futexwakeup</code>)</b>： 调用 <code>futex(addr, FUTEX_WAKE, count, ...)</code>。 意思就是：<i>“内核老兄，在这个地址上睡觉的线程，请帮我叫醒 <code>count</code> 个。”</i></li></ul><p data-pid=\"r5_Lg5kY\">关于 Futex 的更多细节，推荐阅读笔者整理的：</p><a href=\"https://zhuanlan.zhihu.com/p/1922970692120479111\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">Rust 原理丨操作系统并发原语</a><h3>1.3 总结</h3><p data-pid=\"jK7zyv6h\">atomic 和 sema 是 Go 并发的”阴阳二元”：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th></th><th>atomic</th><th>sema</th></tr><tr><td>哲学</td><td>乐观（假设无竞争）</td><td>悲观（接受竞争）</td></tr><tr><td>机制</td><td>硬件指令</td><td>OS/Runtime 调度</td></tr><tr><td>速度</td><td>极快（纳秒）</td><td>较慢（微秒）</td></tr><tr><td>能力</td><td>状态变更</td><td>休眠/唤醒</td></tr><tr><td>使用</td><td>所有路径</td><td>慢速路径</td></tr><tr><td>目标</td><td>性能</td><td>正确性 + 公平性</td></tr></tbody></table><p data-pid=\"u6oX81B6\">所有 Go 的同步原语都是这两者的不同组合方式，遵循 “Fast Path with Atomic, Slow Path with Semaphore” 的设计模式！🎯</p><p data-pid=\"I4Yj4xVR\">用一句话总结就是：</p><blockquote data-pid=\"dXT0xW-R\">Atomic 提供无锁的快速状态管理（CAS、加减），sema 提供有竞争时的 goroutine 休眠/唤醒机制，两者组合实现”乐观尝试 + 悲观等待”的高效并发模型。</blockquote><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-5995811e74b1a5dd8076303270b6d8a0_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1737\" data-rawheight=\"1850\" data-original-token=\"v2-fed24a999f0e065f834be2dccaf25b81\" class=\"origin_image zh-lightbox-thumb\" width=\"1737\" data-original=\"https://pica.zhimg.com/v2-5995811e74b1a5dd8076303270b6d8a0_r.jpg\"/></figure><h2>2. sync.Mutex</h2><h3>2.1 概述</h3><p data-pid=\"hmIYcpXl\">Go 语言的 <code>sync.Mutex</code> 是一种并发原语，旨在保证同一时间只有一个 Goroutine 可以访问共享资源，从而实现互斥（Mutual Exclusion）。它的底层实现是基于两个核心字段和一套复杂的自旋、排队和唤醒逻辑，以在性能和公平性之间取得平衡。</p><p data-pid=\"ro5Mjzpc\"><code>sync.Mutex</code> 类型只有两个公开的指针方法：<code>Lock()</code> 和 <code>Unlock()</code>。</p><ul><li data-pid=\"Yo4vHQ-H\"><code>m.Lock()</code>：锁定当前的共享资源</li><li data-pid=\"XL-V_AxL\"><code>m.Unlock()</code>：进行解锁</li></ul><h3>2.2 数据结构</h3><p data-pid=\"Kuz7BM5H\">前面我们已经展示过 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go%23L20\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync.Mutex</a> 的数据结构了：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Mutex</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">state</span> <span class=\"kt\">int32</span>\n\t<span class=\"nx\">sema</span>  <span class=\"kt\">uint32</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"zyopxrhP\">Go 语言的 sync.Mutex 结构体非常精简，仅包含两个字段：</p><ul><li data-pid=\"9VZaY-HI\"><code>state (int32)</code>：这是一个 32 位整数，用于原子地表示互斥锁的当前状态。通过不同的位（Bit）来编码多种信息，实现了极高的效率。</li><li data-pid=\"_Acvp3Le\"><code>sema (uint32)</code>：这是我们前面提到的 sema 锁，用于实现 Goroutine 的阻塞和唤醒机制。当 Goroutine 无法立即获取锁时，它会在该信号量上阻塞休眠，等待锁的持有者释放信号量将其唤醒。</li></ul><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-5bb4e0b00c8fd89c6a52d62e289649bb_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1478\" data-rawheight=\"758\" data-original-token=\"v2-a3d5b9581725cfe1a487b9bc7beca975\" class=\"origin_image zh-lightbox-thumb\" width=\"1478\" data-original=\"https://picx.zhimg.com/v2-5bb4e0b00c8fd89c6a52d62e289649bb_r.jpg\"/></figure><p data-pid=\"VkXAaxZV\">如何理解这 2 个字段呢？在我看来：</p><ul><li data-pid=\"DJlMA3Wo\"><code>state</code> 字段是在用户态（User Space）解决”谁拿到锁”的逻辑。</li><li data-pid=\"IQx9EqX2\"><code>sema</code> 字段是用来解决”拿不到锁的 Goroutine 到底去了哪里、怎么睡、怎么醒”的物理问题。</li></ul><h3>2.3 state 字段</h3><p data-pid=\"YDBqaxNJ\"><code>sema</code> 前面已经介绍得非常清楚了，下面我们重点来分析一下 <code>state</code> 字段。</p><p data-pid=\"lLpXsgmZ\">为了最大化性能，<code>state</code> 字段通过位运算存储了四个关键信息，这些信息共同决定了锁的运行模式和竞争程度：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>位 (Bit)</th><th>含义</th><th>解释</th></tr><tr><td>0</td><td>Locked</td><td>1 表示已加锁，0 表示未加锁。</td></tr><tr><td>1</td><td>Woken</td><td>1 表示已有 Goroutine 被唤醒（正在尝试获取锁），此时不需要再唤醒其他人。</td></tr><tr><td>2</td><td>Starvation</td><td>1 表示进入饥饿模式（Go 1.9+ 引入的关键优化）。</td></tr><tr><td>3-31</td><td>WaiterCount</td><td>记录当前有多少个 Goroutine 在排队等待。</td></tr></tbody></table><p data-pid=\"Pwl2b1ps\">如下图所示：</p><div class=\"highlight\"><pre><code class=\"language-text\">31                           3  2  1  0\n┌─────────────────────────────┬──┬──┬──┐\n│    等待者数量 29 bits         │S │W │L │\n└─────────────────────────────┴──┴──┴──┘\n                               │  │  └─ mutexLocked (锁定状态)\n                               │  └──── mutexWoken (唤醒标志)\n                               └─────── mutexStarving (饥饿模式)</code></pre></div><p data-pid=\"6q5BPs1n\">使用一个 int32 来存储这么多信息有三大好处：</p><ol><li data-pid=\"eAi8Q2HN\"><b>满足多个状态修改的原子性</b>：所有状态必须在一个原子操作中一起更新，避免状态不一致。</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">// 错误的设计（如果分开存储）\n   mutex.locked = true      // ← 这里可能被中断\n   mutex.waiterCount++      // ← 状态不一致的窗口期\n\n   // 正确的设计（单个原子操作）\n   atomic.CompareAndSwapInt32(&amp;m.state, old, new)  // 一次性更新所有状态</code></pre></div><p data-pid=\"GCzlvLEr\"><b>2. CPU Cache Line 效率</b>：一个 int32 只占 4 字节，极度缓存友好，所有状态信息在同一个 cache line 中，读取/修改只需要一次内存访问，避免 false sharing。</p><p data-pid=\"cJ56kqVv\"><b>3. Fast Path 快速路径优化</b>：在无竞争情况下，即 state == 0 表示完全空闲（无锁、无等待、无标志），一次 CAS 就能完成加锁，编译器可以内联这段代码，这是 99% 无竞争场景的关键优化。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">m</span> <span class=\"o\">*</span><span class=\"nx\">Mutex</span><span class=\"p\">)</span> <span class=\"nf\">Lock</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   \t<span class=\"c1\">// Fast path: grab unlocked mutex.\n</span><span class=\"c1\"></span>   \t<span class=\"k\">if</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">CompareAndSwapInt32</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">mutexLocked</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n   \t\t<span class=\"k\">if</span> <span class=\"nx\">race</span><span class=\"p\">.</span><span class=\"nx\">Enabled</span> <span class=\"p\">{</span>\n   \t\t\t<span class=\"nx\">race</span><span class=\"p\">.</span><span class=\"nf\">Acquire</span><span class=\"p\">(</span><span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nf\">Pointer</span><span class=\"p\">(</span><span class=\"nx\">m</span><span class=\"p\">))</span>\n   \t\t<span class=\"p\">}</span>\n   \t\t<span class=\"k\">return</span>\n   \t<span class=\"p\">}</span>\n   \t<span class=\"c1\">// Slow path (outlined so that the fast path can be inlined)\n</span><span class=\"c1\"></span>   \t<span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nf\">lockSlow</span><span class=\"p\">()</span>\n</code></pre></div><p data-pid=\"6SRmMa2p\"><code>state</code> 的状态转换示例：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// 初始状态\n</span><span class=\"c1\"></span><span class=\"nx\">state</span> <span class=\"p\">=</span> <span class=\"mi\">0</span><span class=\"nx\">b00000000_00000000_00000000_00000000</span>\n\n<span class=\"c1\">// goroutine A 获取锁\n</span><span class=\"c1\"></span><span class=\"nx\">state</span> <span class=\"p\">=</span> <span class=\"mi\">0</span><span class=\"nx\">b00000000_00000000_00000000_00000001</span>  <span class=\"c1\">// L=1\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// goroutine B 尝试获取，进入等待队列\n</span><span class=\"c1\"></span><span class=\"nx\">state</span> <span class=\"p\">=</span> <span class=\"mi\">0</span><span class=\"nx\">b00000000_00000000_00000000_00001001</span>  <span class=\"c1\">// L=1, waiter=1\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// goroutine B 设置了 woken 标志（自旋中）\n</span><span class=\"c1\"></span><span class=\"nx\">state</span> <span class=\"p\">=</span> <span class=\"mi\">0</span><span class=\"nx\">b00000000_00000000_00000000_00001011</span>  <span class=\"c1\">// L=1, W=1, waiter=1\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 等待超过 1ms，进入饥饿模式\n</span><span class=\"c1\"></span><span class=\"nx\">state</span> <span class=\"p\">=</span> <span class=\"mi\">0</span><span class=\"nx\">b00000000_00000000_00000000_00001101</span>  <span class=\"c1\">// L=1, S=1, waiter=1\n</span></code></pre></div><h3>2.4 上锁</h3><ul><li data-pid=\"iAeOzTI_\">正常模式：获得锁直接返回，得不到锁就自旋，自旋多次后进入 sema 队列中休眠，超过 1ms 就转为饥饿模式；</li><li data-pid=\"FG-Szmbc\">饥饿模式：  </li><ul><li data-pid=\"y0aCyKKl\">新来的协程不自旋，直接今年入 sema 队列中；</li><li data-pid=\"-42Xkipc\">依次从 sema 队列中唤醒协程，并直接获得锁，当 sema 队列为空时，跳回正常模式</li></ul></ul><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-4a95305a3a2792568da1be42dd7c3b94_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2960\" data-rawheight=\"1080\" data-original-token=\"v2-b679c92015962cce0cf9b73e05e49351\" class=\"origin_image zh-lightbox-thumb\" width=\"2960\" data-original=\"https://pic1.zhimg.com/v2-4a95305a3a2792568da1be42dd7c3b94_r.jpg\"/></figure><p data-pid=\"IA7hyQlF\">上锁的源码位于 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go%23L61\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync/mutex.go#L61</a>，代码如下所示：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">m</span> <span class=\"o\">*</span><span class=\"nx\">Mutex</span><span class=\"p\">)</span> <span class=\"nf\">lockSlow</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// ===== 初始化局部变量 =====\n</span><span class=\"c1\"></span>\t<span class=\"kd\">var</span> <span class=\"nx\">waitStartTime</span> <span class=\"kt\">int64</span>  <span class=\"c1\">// 开始等待的时间戳（用于判断是否饥饿）\n</span><span class=\"c1\"></span>\t<span class=\"nx\">starving</span> <span class=\"o\">:=</span> <span class=\"kc\">false</span>        <span class=\"c1\">// 当前 goroutine 是否处于饥饿状态\n</span><span class=\"c1\"></span>\t<span class=\"nx\">awoke</span> <span class=\"o\">:=</span> <span class=\"kc\">false</span>           <span class=\"c1\">// 当前 goroutine 是否从休眠中被唤醒\n</span><span class=\"c1\"></span>\t<span class=\"nx\">iter</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>                <span class=\"c1\">// 自旋迭代次数\n</span><span class=\"c1\"></span>\t<span class=\"nx\">old</span> <span class=\"o\">:=</span> <span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span>           <span class=\"c1\">// 保存当前 mutex 的状态\n</span><span class=\"c1\"></span>\n\t<span class=\"c1\">// ===== 主循环：不断尝试获取锁 =====\n</span><span class=\"c1\"></span>\t<span class=\"k\">for</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 第一阶段：自旋尝试（Active Spinning）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 自旋条件：\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 1. old&amp;mutexLocked != 0：锁已被持有\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 2. old&amp;mutexStarving == 0：不在饥饿模式（饥饿模式下新来的不能竞争）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 3. runtime_canSpin(iter)：满足自旋条件（多核、迭代次数 &lt; 4、有其他 P 等）\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"nx\">mutexLocked</span><span class=\"p\">|</span><span class=\"nx\">mutexStarving</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nx\">mutexLocked</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nf\">runtime_canSpin</span><span class=\"p\">(</span><span class=\"nx\">iter</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// 尝试设置 mutexWoken 标志，条件：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 1. !awoke：我们还没设置过\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 2. old&amp;mutexWoken == 0：当前没有其他 goroutine 设置\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 3. old&gt;&gt;mutexWaiterShift != 0：有等待者（不然设置 woken 没意义）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 目的：告诉 Unlock &#34;有人在自旋，不要唤醒休眠的 goroutine&#34;，减少不必要的唤醒开销\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">awoke</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"nx\">mutexWoken</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">old</span><span class=\"o\">&gt;&gt;</span><span class=\"nx\">mutexWaiterShift</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span>\n\t\t\t\t<span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">CompareAndSwapInt32</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"nx\">old</span><span class=\"p\">,</span> <span class=\"nx\">old</span><span class=\"p\">|</span><span class=\"nx\">mutexWoken</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"nx\">awoke</span> <span class=\"p\">=</span> <span class=\"kc\">true</span>\n\t\t\t<span class=\"p\">}</span>\n\n\t\t\t<span class=\"c1\">// 执行实际的自旋（CPU 级别的忙等待）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nf\">runtime_doSpin</span><span class=\"p\">()</span>\n\t\t\t<span class=\"nx\">iter</span><span class=\"o\">++</span>\n\t\t\t<span class=\"nx\">old</span> <span class=\"p\">=</span> <span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span>  <span class=\"c1\">// 重新读取状态\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">continue</span>       <span class=\"c1\">// 继续下一轮尝试\n</span><span class=\"c1\"></span>\t\t<span class=\"p\">}</span>\n\n\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 第二阶段：准备新的状态值（CAS 更新）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\n\t\t<span class=\"nx\">new</span> <span class=\"o\">:=</span> <span class=\"nx\">old</span>  <span class=\"c1\">// 基于旧状态构造新状态\n</span><span class=\"c1\"></span>\n\t\t<span class=\"c1\">// 如果不在饥饿模式，尝试设置 mutexLocked 位\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// （在饥饿模式下，新来的 goroutine 不能直接抢锁，必须排队）\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"nx\">mutexStarving</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"nx\">new</span> <span class=\"o\">|=</span> <span class=\"nx\">mutexLocked</span>\n\t\t<span class=\"p\">}</span>\n\n\t\t<span class=\"c1\">// 如果锁已被持有或处于饥饿模式，增加等待者计数（即将进入等待队列）\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"nx\">mutexLocked</span><span class=\"p\">|</span><span class=\"nx\">mutexStarving</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"nx\">new</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nx\">mutexWaiterShift</span>  <span class=\"c1\">// 等待者数量 +1\n</span><span class=\"c1\"></span>\t\t<span class=\"p\">}</span>\n\n\t\t<span class=\"c1\">// 如果当前 goroutine 已经饥饿（等待超过 1ms），并且锁还被持有\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 则尝试将 mutex 切换到饥饿模式\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 注意：只在锁被持有时切换，因为 Unlock 期望饥饿模式必有等待者\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">starving</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"nx\">mutexLocked</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"nx\">new</span> <span class=\"o\">|=</span> <span class=\"nx\">mutexStarving</span>\n\t\t<span class=\"p\">}</span>\n\n\t\t<span class=\"c1\">// 如果当前 goroutine 是被唤醒的，需要清除 mutexWoken 标志\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">awoke</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// 清除 mutexWoken 标志（用 &amp;^ 位清除操作）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">new</span> <span class=\"o\">&amp;^=</span> <span class=\"nx\">mutexWoken</span>\n\t\t<span class=\"p\">}</span>\n\n\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 第三阶段：CAS 更新状态\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\n\t\t<span class=\"c1\">// 尝试用 CAS 将状态从 old 更新为 new\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">CompareAndSwapInt32</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"nx\">old</span><span class=\"p\">,</span> <span class=\"nx\">new</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// CAS 成功！\n</span><span class=\"c1\"></span>\n\t\t\t<span class=\"c1\">// 检查是否成功获取了锁\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 条件：旧状态既没锁定也不在饥饿模式\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"nx\">mutexLocked</span><span class=\"p\">|</span><span class=\"nx\">mutexStarving</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"k\">break</span> <span class=\"c1\">// 成功获取锁，退出循环！\n</span><span class=\"c1\"></span>\t\t\t<span class=\"p\">}</span>\n\n\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 第四阶段：进入等待队列并休眠\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\n\t\t\t<span class=\"c1\">// 如果之前已经等待过（被唤醒后重新竞争失败），插入队首（LIFO）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 否则插入队尾（FIFO）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">queueLifo</span> <span class=\"o\">:=</span> <span class=\"nx\">waitStartTime</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span>\n\n\t\t\t<span class=\"c1\">// 记录开始等待的时间（只记录一次）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"nx\">waitStartTime</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"nx\">waitStartTime</span> <span class=\"p\">=</span> <span class=\"nf\">runtime_nanotime</span><span class=\"p\">()</span>\n\t\t\t<span class=\"p\">}</span>\n\n                        <span class=\"c1\">// 调用 semacuqire 进入休眠 &lt;--- 阻塞在这里，直到被唤醒\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nf\">runtime_SemacquireMutex</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">sema</span><span class=\"p\">,</span> <span class=\"nx\">queueLifo</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\n\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 被唤醒了！从这里继续执行\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\n\t\t\t<span class=\"c1\">// 检查是否应该进入饥饿模式\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 条件：之前已经饥饿 || 等待时间超过 1ms\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">starving</span> <span class=\"p\">=</span> <span class=\"nx\">starving</span> <span class=\"o\">||</span> <span class=\"nf\">runtime_nanotime</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"nx\">waitStartTime</span> <span class=\"p\">&gt;</span> <span class=\"nx\">starvationThresholdNs</span>\n\n\t\t\t<span class=\"c1\">// 重新读取当前状态\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">old</span> <span class=\"p\">=</span> <span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span>\n\n\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 饥饿模式的特殊处理\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\n\t\t\t<span class=\"k\">if</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"nx\">mutexStarving</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"c1\">// 饥饿模式下被唤醒，说明锁被直接移交给我们了\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// 但此时状态还不一致：\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// - mutexLocked 还没设置（需要我们设置）\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// - 我们还被计入等待者（需要减 1）\n</span><span class=\"c1\"></span>\n\n\t\t\t\t<span class=\"c1\">// 计算状态变化：\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// +mutexLocked：设置锁定标志\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// -1&lt;&lt;mutexWaiterShift：等待者数量减 1\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"nx\">delta</span> <span class=\"o\">:=</span> <span class=\"nb\">int32</span><span class=\"p\">(</span><span class=\"nx\">mutexLocked</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">&lt;&lt;</span><span class=\"nx\">mutexWaiterShift</span><span class=\"p\">)</span>\n\n\t\t\t\t<span class=\"c1\">// 决定是否退出饥饿模式\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// 条件：\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// 1. 当前 goroutine 不再饥饿（等待时间 &lt; 1ms）\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// 2. 或者我们是最后一个等待者\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">starving</span> <span class=\"o\">||</span> <span class=\"nx\">old</span><span class=\"o\">&gt;&gt;</span><span class=\"nx\">mutexWaiterShift</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"p\">{</span>\n\t\t\t\t\t<span class=\"c1\">// 退出饥饿模式（清除 mutexStarving 标志）\n</span><span class=\"c1\"></span>\t\t\t\t\t<span class=\"c1\">// 注意：必须在这里退出，考虑实际等待时间\n</span><span class=\"c1\"></span>\t\t\t\t\t<span class=\"c1\">// 饥饿模式效率低，如果不及时退出，两个 goroutine\n</span><span class=\"c1\"></span>\t\t\t\t\t<span class=\"c1\">// 可能会无限期地在饥饿模式下来回切换\n</span><span class=\"c1\"></span>\t\t\t\t\t<span class=\"nx\">delta</span> <span class=\"o\">-=</span> <span class=\"nx\">mutexStarving</span>\n\t\t\t\t<span class=\"p\">}</span>\n\n\t\t\t\t<span class=\"c1\">// 原子更新状态\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">AddInt32</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"nx\">delta</span><span class=\"p\">)</span>\n\t\t\t\t<span class=\"k\">break</span>  <span class=\"c1\">// 成功获取锁，退出循环！\n</span><span class=\"c1\"></span>\t\t\t<span class=\"p\">}</span>\n\n\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 正常模式被唤醒：重新开始竞争\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\n\t\t\t<span class=\"nx\">awoke</span> <span class=\"p\">=</span> <span class=\"kc\">true</span>   <span class=\"c1\">// 标记为已唤醒\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">iter</span> <span class=\"p\">=</span> <span class=\"mi\">0</span>       <span class=\"c1\">// 重置自旋计数器（可以重新自旋）\n</span><span class=\"c1\"></span>\n\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// CAS 失败：状态被其他 goroutine 改变了\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 重新读取状态，继续下一轮循环\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">old</span> <span class=\"p\">=</span> <span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"c1\">// ===== 成功获取锁，退出循环 =====\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"X8qcGTdC\">关键步骤：</p><ol><li data-pid=\"cH7AV1Tz\">自旋（Spinning）：在正常模式且满足条件时自旋等待</li><li data-pid=\"1O-I6dr9\">设置 mutexWoken：告诉 Unlock 不要唤醒其他 goroutine</li><li data-pid=\"KTUrRfui\">更新等待者计数：增加 waiter 数量</li><li data-pid=\"Wl3c0EYZ\">进入信号量等待：调用 runtime_SemacquireMutex</li><li data-pid=\"9LAKCt-c\">饥饿模式切换：等待时间超过 1ms 切换到饥饿模式</li></ol><p data-pid=\"u2PtZUIx\">自旋条件：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">const</span> <span class=\"p\">(</span>\n\t<span class=\"nx\">active_spin</span>     <span class=\"p\">=</span> <span class=\"mi\">4</span>  <span class=\"c1\">// referenced in proc.go for sync.Mutex implementation\n</span><span class=\"c1\"></span>\t<span class=\"nx\">active_spin_cnt</span> <span class=\"p\">=</span> <span class=\"mi\">30</span> <span class=\"c1\">// referenced in proc.go for sync.Mutex implementation\n</span><span class=\"c1\"></span><span class=\"p\">)</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">internal_sync_runtime_canSpin</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">bool</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 必须同时满足：\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// \t- 自旋次数 &lt; 4\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// \t- 多核 CPU（numCPU &gt; 1）\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//  - 有其他运行的 P\n</span><span class=\"c1\"></span>        <span class=\"c1\">//  - 本地运行队列为空\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">i</span> <span class=\"o\">&gt;=</span> <span class=\"nx\">active_spin</span> <span class=\"o\">||</span> <span class=\"nx\">numCPUStartup</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span> <span class=\"o\">||</span> <span class=\"nx\">gomaxprocs</span> <span class=\"o\">&lt;=</span> <span class=\"nx\">sched</span><span class=\"p\">.</span><span class=\"nx\">npidle</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span><span class=\"o\">+</span><span class=\"nx\">sched</span><span class=\"p\">.</span><span class=\"nx\">nmspinning</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"kc\">false</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">p</span> <span class=\"o\">:=</span> <span class=\"nf\">getg</span><span class=\"p\">().</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">p</span><span class=\"p\">.</span><span class=\"nf\">ptr</span><span class=\"p\">();</span> <span class=\"p\">!</span><span class=\"nf\">runqempty</span><span class=\"p\">(</span><span class=\"nx\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"kc\">false</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>2.5 解锁</h3><ul><li data-pid=\"3KjQiMP8\">正常模式：解锁后新来的协程和 sema 队列中的协程一起竞争；</li><li data-pid=\"2zzqDaNN\">饥饿模式：新来的协程直接入 sema 队列，依次从 sema 队列中唤醒协程并直接交付锁；</li></ul><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-0840f4501967b77c313ad31da9e1d6f9_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2208\" data-rawheight=\"796\" data-original-token=\"v2-f4f79180103e96d2e986199a6be37b41\" class=\"origin_image zh-lightbox-thumb\" width=\"2208\" data-original=\"https://picx.zhimg.com/v2-0840f4501967b77c313ad31da9e1d6f9_r.jpg\"/></figure><p data-pid=\"MWU8e-aP\">上锁的源码位于 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go%23L202\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync/mutex.go#L202</a>，代码如下所示：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">m</span> <span class=\"o\">*</span><span class=\"nx\">Mutex</span><span class=\"p\">)</span> <span class=\"nf\">Unlock</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// ===== Fast Path：快速路径（无竞争情况）=====\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 原子地将 state 减去 mutexLocked（即清除锁定标志位）\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 如果 mutex 完全空闲（无等待者、无其他标志），new 将等于 0\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 如果 new == 0，说明没有等待者，直接返回（最快路径）\n</span><span class=\"c1\"></span>\t<span class=\"nx\">new</span> <span class=\"o\">:=</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">AddInt32</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"nx\">mutexLocked</span><span class=\"p\">)</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">new</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// new != 0 说明还有其他信息（等待者、标志位等）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 需要进入慢速路径处理\n</span><span class=\"c1\"></span>\t\t<span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nf\">unlockSlow</span><span class=\"p\">(</span><span class=\"nx\">new</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// unlockSlow 是 Unlock 的慢速路径，处理有等待者或特殊标志的情况\n</span><span class=\"c1\">// 参数 new：已经减去 mutexLocked 后的新状态值\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">m</span> <span class=\"o\">*</span><span class=\"nx\">Mutex</span><span class=\"p\">)</span> <span class=\"nf\">unlockSlow</span><span class=\"p\">(</span><span class=\"nx\">new</span> <span class=\"kt\">int32</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// 不允许对未加锁的 mutex 进行 unlock!\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">new</span><span class=\"o\">+</span><span class=\"nx\">mutexLocked</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"nx\">mutexLocked</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"s\">&#34;sync: unlock of unlocked mutex&#34;</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 分支 1：正常模式（Normal Mode）\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">new</span><span class=\"o\">&amp;</span><span class=\"nx\">mutexStarving</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 正常模式下的唤醒逻辑：不保证被唤醒者一定能获取锁\n</span><span class=\"c1\"></span>\t\t<span class=\"nx\">old</span> <span class=\"o\">:=</span> <span class=\"nx\">new</span>\n\n\t\t<span class=\"k\">for</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"c1\">// ===== 检查是否需要唤醒等待者 =====\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 以下任一条件满足，都无需唤醒：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 1. old&gt;&gt;mutexWaiterShift == 0\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//    → 没有等待者\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 2. old&amp;mutexLocked != 0\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//    → 锁已经被其他 goroutine 抢走了\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//       （在我们 Unlock 之后，有新来的 goroutine 直接 CAS 获取了锁）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 3. old&amp;mutexWoken != 0\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//    → 已经有一个 goroutine 被标记为唤醒状态\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//       （可能在自旋，或者已经被其他 Unlock 唤醒）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 4. old&amp;mutexStarving != 0\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//    → 进入饥饿模式了\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//       （虽然我们检查的是 new&amp;mutexStarving == 0 才进这个分支，\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//        但在循环中 old 可能被其他 goroutine 更新了）\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//       饥饿模式有专门的处理逻辑，我们不应该干预\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"nx\">old</span><span class=\"o\">&gt;&gt;</span><span class=\"nx\">mutexWaiterShift</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"nx\">old</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"nx\">mutexLocked</span><span class=\"p\">|</span><span class=\"nx\">mutexWoken</span><span class=\"p\">|</span><span class=\"nx\">mutexStarving</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"k\">return</span>  <span class=\"c1\">// 不需要唤醒，直接返回\n</span><span class=\"c1\"></span>\t\t\t<span class=\"p\">}</span>\n\n\t\t\t<span class=\"c1\">// ===== 准备唤醒一个等待者 =====\n</span><span class=\"c1\"></span>\n\t\t\t<span class=\"c1\">// 构造新状态：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 1. old - 1&lt;&lt;mutexWaiterShift：等待者数量减 1\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 2. | mutexWoken：设置 mutexWoken 标志\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// mutexWoken 的作用：\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 告诉正在 Lock 的 goroutine：&#34;已经有人被唤醒了&#34;\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 避免多个 Unlock 重复唤醒\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// - 被唤醒的 goroutine 会清除这个标志\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">new</span> <span class=\"p\">=</span> <span class=\"p\">(</span><span class=\"nx\">old</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"o\">&lt;&lt;</span><span class=\"nx\">mutexWaiterShift</span><span class=\"p\">)</span> <span class=\"p\">|</span> <span class=\"nx\">mutexWoken</span>\n\n\t\t\t<span class=\"c1\">// 用 CAS 更新状态\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">if</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">CompareAndSwapInt32</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"nx\">old</span><span class=\"p\">,</span> <span class=\"nx\">new</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"c1\">// CAS 成功！我们获得了唤醒的权利\n</span><span class=\"c1\"></span>\n\t\t\t\t<span class=\"c1\">// 调用 runtime 的信号量释放操作，唤醒一个等待者\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// 参数：\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// - &amp;m.sema：信号量地址\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// - false：handoff=false，正常模式，不直接移交\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">//          被唤醒的 goroutine 需要重新竞争锁\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"c1\">// - 2：skipframes（用于性能分析）\n</span><span class=\"c1\"></span>\t\t\t\t<span class=\"nf\">runtime_Semrelease</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">sema</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\t\t\t\t<span class=\"k\">return</span>\n\t\t\t<span class=\"p\">}</span>\n\n\t\t\t<span class=\"c1\">// CAS 失败：状态被其他 goroutine 改变了\n</span><span class=\"c1\"></span>\t\t\t<span class=\"c1\">// 重新读取状态，继续下一轮循环\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nx\">old</span> <span class=\"p\">=</span> <span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">state</span>\n\t\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// 分支 2：饥饿模式（Starvation Mode）\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</span><span class=\"c1\"></span>\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 饥饿模式的特殊处理：\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 1. 直接移交所有权（handoff=true）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 被唤醒的 goroutine 保证能获取锁\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 不需要重新竞争\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 2. mutexLocked 位不设置\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 被唤醒的 goroutine 会自己设置\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 见 lockSlow 中 old&amp;mutexStarving != 0 分支\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 3. mutexStarving 标志保持\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 新来的 goroutine 看到这个标志，知道不能竞争\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 必须排队等待\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 4. 当前 goroutine 会主动让出 CPU（在 semrelease1 中 goyield）\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 让被唤醒者立即运行\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//    - 避免延迟\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 调用 semarelease() 释放操作\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// 参数：\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// - &amp;m.sema：信号量地址\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// - true：handoff=true，饥饿模式，直接移交\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">//         semrelease1 会设置 ticket=1，并调用 goyield()\n</span><span class=\"c1\"></span>\t\t<span class=\"c1\">// - 2：skipframes（用于性能分析）\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">runtime_Semrelease</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">sema</span><span class=\"p\">,</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"DP85Wjo5\">关键步骤：</p><ol><li data-pid=\"eL34x5BI\">原子清除锁定位：atomic.AddInt32(&amp;state, -mutexLocked)，结果为 0 则直接返回</li><li data-pid=\"na_Grj-F\">检查是否需要唤醒：无等待者/已有锁持有者/已有被唤醒者则跳过</li><li data-pid=\"5MbYJvcB\">正常模式：设置 mutexWoken 标志 + 减少等待者计数 + semrelease(handoff=false) 唤醒但需重新竞争</li><li data-pid=\"V6wIjzZ3\">饥饿模式：semrelease(handoff=true) 直接移交所有权 + goyield() 让出 CPU</li></ol><h3>2.6 总结</h3><p data-pid=\"y7OBd6Fk\">到这里，我们已经深入探析了 <code>sync.Mutex</code> 的核心机制和底层数据结构。归纳下来，Go 的 <code>Mutex</code> 实现，<b>本质上是通过 atomic 乐观抢占为主、sema 信号量排队休眠为辅，辅以饥饿/公平模式动态切换</b>，来最大化锁的性能与公平性。</p><p data-pid=\"FkThLaoG\"><b>精髓：抢得快靠 “atomic”，等得稳靠 “sema”。</b></p><ul><li data-pid=\"8ll3JZfO\"><b>快速路径（Fast Path）：</b> 绝大多数情况下，goroutine 利用 <code>atomic</code> 硬件指令快速抢占锁，纳秒级切换，无需操作内核。</li><li data-pid=\"lk_lqm05\"><b>慢速路径（Slow Path）：</b> 发生竞争时，goroutine 通过 <code>sema</code> 跳入排队睡眠，只有唤醒才参与下一轮抢占。这部分涉及用户/内核态切换，耗时微秒级，但能极大减少资源消耗与 CPU 干扰。</li><li data-pid=\"FS9n1WFQ\"><b>三层状态编码：</b> 利用一个 <code>int32</code> 整数位操作，节省空间同时高效追踪锁的”持有”“等待”“唤醒”“饥饿”等复杂状态。</li><li data-pid=\"V39bBFNF\"><b>饥饿模式保障公平性：</b> 当长时间得不到锁时，自动切换到饥饿模式，保证队列排头的人下一次必定抢到锁，杜绝饥饿和“惊群”。</li></ul><h2>3. sync.RWMutex</h2><h3>3.1 概述</h3><ul><li data-pid=\"RyXy_hjL\">同时只能有一个 Goroutine 能够获得写锁</li><li data-pid=\"BGt_Hg1s\">同时可以有任意多个 Gorouinte 获得读锁</li><li data-pid=\"P8Ubmmpl\">同时只能存在写锁或读锁（读和写互斥）</li></ul><p data-pid=\"PF9hiwQg\"><code>sync.RWMutex</code> 提供了 4 个方法：</p><ul><li data-pid=\"VFX_uYDt\"><code>rwm.RLock()</code>：上读锁</li><li data-pid=\"R1N-qJYe\"><code>rwm.RUnlock()</code>：解读锁</li><li data-pid=\"M30KyGE7\"><code>rwm.Lock()</code>：上写锁</li><li data-pid=\"vrP7n4tB\"><code>rwm.Unlock()</code>：解读锁</li></ul><h3>3.2 数据结构</h3><p data-pid=\"_xlCvXIn\"><code>sync.RWMutex</code> 定义在 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/sync/rwmutex.go%23L39\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync/rwmutex.go#L39</a>，如下所示：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">RWMutex</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">w</span>           <span class=\"nx\">Mutex</span>        <span class=\"c1\">// held if there are pending writers\n</span><span class=\"c1\"></span>\t<span class=\"nx\">writerSem</span>   <span class=\"kt\">uint32</span>       <span class=\"c1\">// semaphore for writers to wait for completing readers\n</span><span class=\"c1\"></span>\t<span class=\"nx\">readerSem</span>   <span class=\"kt\">uint32</span>       <span class=\"c1\">// semaphore for readers to wait for completing writers\n</span><span class=\"c1\"></span>\t<span class=\"nx\">readerCount</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nx\">Int32</span> <span class=\"c1\">// number of pending readers\n</span><span class=\"c1\"></span>\t<span class=\"nx\">readerWait</span>  <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nx\">Int32</span> <span class=\"c1\">// number of departing readers\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><ul><li data-pid=\"aJQt1h90\"><code>w</code>：写锁，拿到它直接有了上写锁的资格，有可能还需要等待读锁全部释放</li><li data-pid=\"mciPlNyO\"><code>writerSem</code>：写协程等待队列</li><li data-pid=\"Tk3SnRXa\"><code>readerSem</code>：读协程等待队列</li><li data-pid=\"FkBxj8qA\"><code>readerCount</code>：正值表示正值读的协程个数，负值表示加了写锁；</li><li data-pid=\"P1Gwjqan\"><code>readerWait</code>：上写锁应该等待读协程的个数</li></ul><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-b26ae39e2b80bf18ede3196c93aceabe_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1870\" data-rawheight=\"906\" data-original-token=\"v2-ab33884cd4d7ae215ffb8e9b1097d004\" class=\"origin_image zh-lightbox-thumb\" width=\"1870\" data-original=\"https://pica.zhimg.com/v2-b26ae39e2b80bf18ede3196c93aceabe_r.jpg\"/></figure><h3>3.3 上写锁</h3><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-eda9b8665caf33d0070b6877a1584799_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3028\" data-rawheight=\"336\" data-original-token=\"v2-eda9b8665caf33d0070b6877a1584799\" class=\"origin_image zh-lightbox-thumb\" width=\"3028\" data-original=\"https://pic2.zhimg.com/v2-eda9b8665caf33d0070b6877a1584799_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">const</span> <span class=\"nx\">rwmutexMaxReaders</span> <span class=\"p\">=</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">30</span> <span class=\"c1\">// 最多的读者个数，是一个非常大的值\n</span><span class=\"c1\"></span>\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">rw</span> <span class=\"o\">*</span><span class=\"nx\">RWMutex</span><span class=\"p\">)</span> <span class=\"nf\">Lock</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// 1. 抢占获取写锁的资格\n</span><span class=\"c1\"></span>\t<span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">w</span><span class=\"p\">.</span><span class=\"nf\">Lock</span><span class=\"p\">()</span>\n\t<span class=\"c1\">// Announce to readers there is a pending writer.\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 2. 原子变量 readerCount 减去 rwmutexMaxReaders 表明当前有写的需求，\n</span><span class=\"c1\"></span>        <span class=\"c1\">// \t阻止后续读锁的抢占，写者优先！\n</span><span class=\"c1\"></span>        <span class=\"c1\">// \t再加回去是要恢复原来的值，以得到抢锁之前正常读的协程的个数 r\n</span><span class=\"c1\"></span>\t<span class=\"nx\">r</span> <span class=\"o\">:=</span> <span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerCount</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"nx\">rwmutexMaxReaders</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nx\">rwmutexMaxReaders</span>\n        <span class=\"c1\">// 3. 陷入 writerSem，等待 readerWait 个正在读的协程释放读锁\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">r</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerWait</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"nx\">r</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">runtime_SemacquireRWMutex</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">writerSem</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n        <span class=\"c1\">// 4. 抢锁成功\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h3>3.4 解写锁</h3><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-b9f3f6614335d3e3216838175292faab_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2152\" data-rawheight=\"472\" data-original-token=\"v2-b99ec2bee1e1935f62cdc9d7b1a09c7a\" class=\"origin_image zh-lightbox-thumb\" width=\"2152\" data-original=\"https://pic4.zhimg.com/v2-b9f3f6614335d3e3216838175292faab_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">rw</span> <span class=\"o\">*</span><span class=\"nx\">RWMutex</span><span class=\"p\">)</span> <span class=\"nf\">Unlock</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 1. 把 rwmutexMaxReaders 加回去，表示已经没有写协程了\n</span><span class=\"c1\"></span>\t<span class=\"nx\">r</span> <span class=\"o\">:=</span> <span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerCount</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"nx\">rwmutexMaxReaders</span><span class=\"p\">)</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">r</span> <span class=\"o\">&gt;=</span> <span class=\"nx\">rwmutexMaxReaders</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 不允许对未上锁的锁进行 Unlock！\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"s\">&#34;sync: Unlock of unlocked RWMutex&#34;</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n        <span class=\"c1\">// 2. 唤醒所有阻塞在 readerSem 中的读协程\n</span><span class=\"c1\"></span>\t<span class=\"k\">for</span> <span class=\"nx\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"p\">&lt;</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"nx\">r</span><span class=\"p\">);</span> <span class=\"nx\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">runtime_Semrelease</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerSem</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"c1\">// 3. 允许其他协程抢占写锁\n</span><span class=\"c1\"></span>\t<span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">w</span><span class=\"p\">.</span><span class=\"nf\">Unlock</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>3.5 上读锁</h3><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-ac642ea654d8ea4b10463d2f50bd9695_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2230\" data-rawheight=\"270\" data-original-token=\"v2-ac642ea654d8ea4b10463d2f50bd9695\" class=\"origin_image zh-lightbox-thumb\" width=\"2230\" data-original=\"https://pic4.zhimg.com/v2-ac642ea654d8ea4b10463d2f50bd9695_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">rw</span> <span class=\"o\">*</span><span class=\"nx\">RWMutex</span><span class=\"p\">)</span> <span class=\"nf\">RLock</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 1. readerCount++，检查是否有写锁\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerCount</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">&lt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 2. 有写锁，则陷入 readerSem，等待写锁释放\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">runtime_SemacquireRWMutexR</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerSem</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n        <span class=\"c1\">// 3. 没有写锁或者写锁释放后唤醒 readerSem，则获得读锁成功\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h3>3.6 解读锁</h3><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-b9f3f6614335d3e3216838175292faab_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2152\" data-rawheight=\"472\" data-original-token=\"v2-b99ec2bee1e1935f62cdc9d7b1a09c7a\" class=\"origin_image zh-lightbox-thumb\" width=\"2152\" data-original=\"https://pic4.zhimg.com/v2-b9f3f6614335d3e3216838175292faab_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">rw</span> <span class=\"o\">*</span><span class=\"nx\">RWMutex</span><span class=\"p\">)</span> <span class=\"nf\">RUnlock</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 1. 释放当前读锁，将 readerCount --\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 2. 检查是否有写协程正在等待\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">r</span> <span class=\"o\">:=</span> <span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerCount</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"nx\">r</span> <span class=\"p\">&lt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 3. 如果有写协程等待，则往下走\n</span><span class=\"c1\"></span>\t\t<span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nf\">rUnlockSlow</span><span class=\"p\">(</span><span class=\"nx\">r</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">rw</span> <span class=\"o\">*</span><span class=\"nx\">RWMutex</span><span class=\"p\">)</span> <span class=\"nf\">rUnlockSlow</span><span class=\"p\">(</span><span class=\"nx\">r</span> <span class=\"kt\">int32</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">r</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"nx\">r</span><span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"nx\">rwmutexMaxReaders</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"s\">&#34;sync: RUnlock of unlocked RWMutex&#34;</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n        <span class=\"c1\">// 4. readerWait--\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 5. 判断是否是最后一个释放读锁的协程\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">readerWait</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 6. 是的话，就从 writerSem 中唤醒写协程\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">runtime_Semrelease</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">rw</span><span class=\"p\">.</span><span class=\"nx\">writerSem</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>3.7 总结</h3><p data-pid=\"eMASW0gJ\">总的来说，Go 的 <code>RWMutex</code> 遵循的是<b>写者优先（Writer Priority）</b> 原则，防止写者饥饿。四个核心方法的要点总结如下：</p><ul><li data-pid=\"6rj0MIYE\"><b>上写锁</b>：竞争写锁，看看有无读协程：</li><ul><li data-pid=\"S25eKOPA\">没有读协程的话直接获得写锁；</li><li data-pid=\"wZsa7J8y\">有读协程的话，阻塞后来的读协程，等待当前读协程释放；</li></ul><li data-pid=\"K49AF-5W\"><b>解写锁</b>：解写锁，唤醒 readerSem；</li><li data-pid=\"FQHeDlCM\"><b>上读锁</b>：readerCount++，并检查是否有写锁：</li><ul><li data-pid=\"SO5niLmm\">没有写锁，则上锁完毕；</li><li data-pid=\"_x_tI4qt\">有写锁，则陷入 readerSem，等待写锁释放；</li></ul><li data-pid=\"j9gHWUX4\"><b>解读锁</b>：readerCount –，并检测是否有写协程被阻塞：</li><ul><li data-pid=\"TKxICBvh\">无，则返回；</li><li data-pid=\"I0nk4TzS\">有，则 readerWait –；判断是否是最后一个释放读锁的协程：</li><ul><li data-pid=\"MdnQzpjz\">不是，则返回；</li><li data-pid=\"jUo8tg77\">是，则唤醒 writerSem，解锁完毕；</li></ul></ul></ul><h2>4. sync.WaitGroup</h2><h3>4.1 概述</h3><p data-pid=\"7ho5qggg\">WaitGroup 等待一组 Goroutine 完成。主 Goroutine 调用 Add 来设置要等待的 Goroutine 的数量。然后每个 Goroutine 运行并在完成时调用 Done。同时，主 Goroutine 可以使用 Wait 来阻塞，直到所有 Goroutine 完成。</p><ul><li data-pid=\"fpT5bGl-\"><code>wg.Add(delta int)</code>：Add 将 delta（可能为负）添加到 WaitGroup 计数器。如果计数器变为 0，所有在 Wait 时阻塞的 Goroutine 将被释放。如果计数器变成负值，Add 会 panic。</li><li data-pid=\"-Oe17qn6\"><code>wg.Done()</code>：当 WaitGroup 同步等待组中的某个 Goroutine 执行完毕后，设置这个 WaitGroup 的 counter 数值减 1。</li><li data-pid=\"Yx9T_s72\"><code>wg.Wait()</code>：表示让当前的 Goroutine 等待，进入阻塞状态。一直到 WaitGroup 的计数器为 0，才能解除阻塞，这个 Goroutine 才能继续执行。</li></ul><h3>4.2 数据结构</h3><p data-pid=\"mxwxfHjp\"><code>sync.WaitGroup</code> 源码位于 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/sync/waitgroup.go%23L48\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync/waitgroup.go#L48</a>：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">WaitGroup</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">noCopy</span> <span class=\"nx\">noCopy</span>   <span class=\"c1\">// 防止拷贝\n</span><span class=\"c1\"></span>\n\t<span class=\"c1\">// Bits (high to low):\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//   bits[0:32]  counter\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//   bits[32]    flag: synctest bubble membership\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//   bits[33:64] wait count\n</span><span class=\"c1\"></span>\t<span class=\"nx\">state</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nx\">Uint64</span>  <span class=\"c1\">// 核心状态字段（64位）\n</span><span class=\"c1\"></span>\t<span class=\"nx\">sema</span>  <span class=\"kt\">uint32</span>\t\t\t\t <span class=\"c1\">// sema 锁地址\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"TeV5fstU\">重点是看 <code>state</code> 字段：</p><div class=\"highlight\"><pre><code class=\"language-text\">63                    33  32  31                     0\n┌─────────────────────┬───┬───┬─────────────────────┐\n│   waiter count      │ B │ 0 │      counter        │\n│    (31 bits)        │ u │   │    (32 bits)        │\n│                     │ b │   │                     │\n│                     │ b │   │                     │\n│                     │ l │   │                     │\n│                     │ e │   │                     │\n└─────────────────────┴───┴───┴─────────────────────┘\n  bits[33:64]         bit32   bits[0:32]\n\ncounter:      当前待完成的任务数（Add 增加，Done 减少）\nbubble flag:  synctest 相关（测试用）\nwaiter count: 有多少个 goroutine 在 Wait 中阻塞</code></pre></div><p data-pid=\"mS8FUxh4\">为什么要用一个字段？</p><ol><li data-pid=\"8PNMlhib\">原子操作：可以用一次原子操作同时读写两个值</li><li data-pid=\"1UarNxA6\">避免竞态：counter 和 waiter 总是一致的快照</li><li data-pid=\"qwQpUoep\">零分配：整个 WaitGroup 只需 16 字节（8+4+padding）</li></ol><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"nx\">state</span> <span class=\"o\">:=</span> <span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span>\n<span class=\"nx\">counter</span> <span class=\"o\">:=</span> <span class=\"nb\">int32</span><span class=\"p\">(</span><span class=\"nx\">state</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span>     <span class=\"c1\">// 取高32位\n</span><span class=\"c1\"></span><span class=\"nx\">waiter</span> <span class=\"o\">:=</span> <span class=\"nb\">uint32</span><span class=\"p\">(</span><span class=\"nx\">state</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x7fffffff</span><span class=\"p\">)</span> <span class=\"c1\">// 取低31位（忽略bubble flag）\n</span></code></pre></div><h3>4.3 wg.Wait()</h3><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-3b5fde74fee401c1dd4cc5d65511764f_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1844\" data-rawheight=\"250\" data-original-token=\"v2-3b5fde74fee401c1dd4cc5d65511764f\" class=\"origin_image zh-lightbox-thumb\" width=\"1844\" data-original=\"https://pic4.zhimg.com/v2-3b5fde74fee401c1dd4cc5d65511764f_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">wg</span> <span class=\"o\">*</span><span class=\"nx\">WaitGroup</span><span class=\"p\">)</span> <span class=\"nf\">Wait</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">{</span>\n        <span class=\"nx\">state</span> <span class=\"o\">:=</span> <span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span>\n        <span class=\"nx\">v</span> <span class=\"o\">:=</span> <span class=\"nb\">int32</span><span class=\"p\">(</span><span class=\"nx\">state</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span>    <span class=\"c1\">// counter\n</span><span class=\"c1\"></span>\n        <span class=\"c1\">// 1. Fast Path: counter == 0，直接返回\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"nx\">v</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"c1\">// 2. Slow Path: counter &gt; 0，需要等待\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 用 CAS 增加 waiter 计数\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nf\">CompareAndSwap</span><span class=\"p\">(</span><span class=\"nx\">state</span><span class=\"p\">,</span> <span class=\"nx\">state</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// CAS 成功，进入等待\n</span><span class=\"c1\"></span>            <span class=\"nf\">runtime_SemacquireWaitGroup</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">sema</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">)</span>\n            <span class=\"c1\">// 被唤醒后返回\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// CAS 失败，重试\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>4.4 wg.Add()</h3><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-2ff8d8daf742d4d53c33b39c309cb979_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2608\" data-rawheight=\"520\" data-original-token=\"v2-68f9887c8ed01ac6155ff04c07e6e2b3\" class=\"origin_image zh-lightbox-thumb\" width=\"2608\" data-original=\"https://pic4.zhimg.com/v2-2ff8d8daf742d4d53c33b39c309cb979_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">wg</span> <span class=\"o\">*</span><span class=\"nx\">WaitGroup</span><span class=\"p\">)</span> <span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"nx\">delta</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 1. 原子地将 delta 加到 counter（高32位）\n</span><span class=\"c1\"></span>    <span class=\"nx\">state</span> <span class=\"o\">:=</span> <span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"nb\">uint64</span><span class=\"p\">(</span><span class=\"nx\">delta</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// 2. 解析 state\n</span><span class=\"c1\"></span>    <span class=\"nx\">v</span> <span class=\"o\">:=</span> <span class=\"nb\">int32</span><span class=\"p\">(</span><span class=\"nx\">state</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span>  <span class=\"c1\">// counter\n</span><span class=\"c1\"></span>    <span class=\"nx\">w</span> <span class=\"o\">:=</span> <span class=\"nb\">uint32</span><span class=\"p\">(</span><span class=\"nx\">state</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x7fffffff</span><span class=\"p\">)</span> <span class=\"c1\">// waiter count\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 3. 错误检查\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"nx\">v</span> <span class=\"p\">&lt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n        <span class=\"nb\">panic</span><span class=\"p\">(</span><span class=\"s\">&#34;negative counter&#34;</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"nx\">w</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">delta</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">v</span> <span class=\"o\">==</span> <span class=\"nb\">int32</span><span class=\"p\">(</span><span class=\"nx\">delta</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nb\">panic</span><span class=\"p\">(</span><span class=\"s\">&#34;Add called concurrently with Wait&#34;</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 4. 快速返回：counter &gt; 0 或没有 waiter\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"nx\">v</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"nx\">w</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 5. 关键时刻：counter 降到 0，且有 waiter 在等待\n</span><span class=\"c1\"></span>    <span class=\"c1\">//    → 唤醒所有 waiter！\n</span><span class=\"c1\"></span>    <span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nf\">Store</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>  <span class=\"c1\">// 重置状态\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">;</span> <span class=\"nx\">w</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">w</span><span class=\"o\">--</span> <span class=\"p\">{</span>\n        <span class=\"nf\">runtime_Semrelease</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nx\">sema</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>  <span class=\"c1\">// 唤醒一个\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>4.5 wg.Done()</h3><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">wg</span> <span class=\"o\">*</span><span class=\"nx\">WaitGroup</span><span class=\"p\">)</span> <span class=\"nf\">Done</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 就是执行 counnter--\n</span><span class=\"c1\"></span>\t<span class=\"nx\">wg</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>5. sync.Once</h2><h3>5.1 概述</h3><p data-pid=\"O3yuCAfu\"><code>sync.Once</code> 可以让并发中的一段代码只执行一次；</p><ul><li data-pid=\"xXdJpWMy\"><b>once.Do(func)</b>：执行某一函数，该函数在多个协程中，只会被执行一次。</li></ul><h3>5.2 数据结构</h3><p data-pid=\"cRhIaipW\"><code>sync.Once</code> 的源码位于 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/sync/once.go%23L20\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync/once.go#L20</a>：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Once</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">_</span> <span class=\"nx\">noCopy</span>\n\n\t<span class=\"nx\">done</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nx\">Bool</span>\n\t<span class=\"nx\">m</span>    <span class=\"nx\">Mutex</span>\n<span class=\"p\">}</span>\n</code></pre></div><ul><li data-pid=\"CLZVQKRh\"><code>done</code>：表示当前 once 是否已经执行过了；</li><li data-pid=\"pJDyXaiN\"><code>m</code>：锁</li></ul><h3>5.3 once.Do()</h3><p data-pid=\"zDYOkGwt\">其实就一个简单的双重检测逻辑。</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-646d9a40d005c67cdf23c8aa40e8db65_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2372\" data-rawheight=\"420\" data-original-token=\"v2-4daccb20bb41b7f25cd7a377aab530ad\" class=\"origin_image zh-lightbox-thumb\" width=\"2372\" data-original=\"https://pic2.zhimg.com/v2-646d9a40d005c67cdf23c8aa40e8db65_r.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">o</span> <span class=\"o\">*</span><span class=\"nx\">Once</span><span class=\"p\">)</span> <span class=\"nf\">Do</span><span class=\"p\">(</span><span class=\"nx\">f</span> <span class=\"kd\">func</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 如果已经执行过的了，直接返回\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">done</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nf\">doSlow</span><span class=\"p\">(</span><span class=\"nx\">f</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">o</span> <span class=\"o\">*</span><span class=\"nx\">Once</span><span class=\"p\">)</span> <span class=\"nf\">doSlow</span><span class=\"p\">(</span><span class=\"nx\">f</span> <span class=\"kd\">func</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 上锁\n</span><span class=\"c1\"></span>\t<span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nf\">Lock</span><span class=\"p\">()</span>\n\t<span class=\"k\">defer</span> <span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nf\">Unlock</span><span class=\"p\">()</span>\n        <span class=\"c1\">// 上锁后二次检查\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">done</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">defer</span> <span class=\"nx\">o</span><span class=\"p\">.</span><span class=\"nx\">done</span><span class=\"p\">.</span><span class=\"nf\">Store</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">)</span>\n\t\t<span class=\"nf\">f</span><span class=\"p\">()</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>6. sync.Cond</h2><h3>6.1 概述</h3><p data-pid=\"CEGyirje\">从第一性原理来看，<code>sync.Cond</code> 解决的是<b>轮询（Polling） vs 事件通知（Event Notification）</b>的问题。 当你需要等待某个<b>特定条件</b>（比如”队列不为空”或”缓冲区有空位”）满足时，你只有两种选择：</p><ol><li data-pid=\"xUjJ0XGM\"><b>轮询 (Spinning)</b>：在一个死循环里不断加锁检查。</li><li data-pid=\"wJA5OyZ0\"><b>通知 (Cond)</b>：我去睡觉，等条件满足了，你把我叫醒。</li></ol><p data-pid=\"Wh6GA7X9\">Go 的 <code>sync.Cond</code> 实现非常独特，它没有直接使用操作系统层面的 Condition Variable（如 Pthread Cond），而是自己在 Runtime 层面实现了一套<b>基于票号（Ticket）的通知队列</b>。</p><p data-pid=\"A9ewxyoI\"><code>sync.Cond</code> 提供了 3 个核心方法：</p><ul><li data-pid=\"L8k58rC4\"><code>c.Wait()</code>：阻塞，等待条件发生</li><li data-pid=\"WHFEOeCB\"><code>c.Signal()</code>：唤醒一个等待的协程</li><li data-pid=\"qJGBQ5tZ\"><code>c.Broadcast()</code>：唤醒所有等待的协程</li></ul><p data-pid=\"vSFN3EgT\">使用方式：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">L</span><span class=\"p\">.</span><span class=\"nf\">Lock</span><span class=\"p\">()</span>          <span class=\"c1\">// 1. 先加锁（保护条件 condition）\n</span><span class=\"c1\"></span><span class=\"k\">for</span> <span class=\"p\">!</span><span class=\"nf\">condition</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"c1\">// 2. 必须用 for 循环检查（防止虚假唤醒）\n</span><span class=\"c1\"></span>    <span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nf\">Wait</span><span class=\"p\">()</span>        <span class=\"c1\">// 3. 挂起（内部会：解锁 -&gt; 睡 -&gt; 加锁）\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"c1\">// 执行业务逻辑...\n</span><span class=\"c1\"></span><span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">L</span><span class=\"p\">.</span><span class=\"nf\">Unlock</span><span class=\"p\">()</span>        <span class=\"c1\">// 4. 最终解锁\n</span></code></pre></div><h3>6.2 数据结构</h3><p data-pid=\"u72off5H\"><code>sync.Cond</code> 源码位于 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/golang/go/blob/release-branch.go1.25/src/sync/cond.go%23L37\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sync/cond.go#L37</a>：</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Cond</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">noCopy</span>  <span class=\"nx\">noCopy</span>       <span class=\"c1\">// 防止拷贝\n</span><span class=\"c1\"></span>    <span class=\"nx\">L</span>       <span class=\"nx\">Locker</span>       <span class=\"c1\">// 关联的锁（通常是 *Mutex 或 *RWMutex）\n</span><span class=\"c1\"></span>    <span class=\"nx\">notify</span>  <span class=\"nx\">notifyList</span>   <span class=\"c1\">// 等待队列（ticket-based）\n</span><span class=\"c1\"></span>    <span class=\"nx\">checker</span> <span class=\"nx\">copyChecker</span>  <span class=\"c1\">// 运行时拷贝检测\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"kd\">type</span> <span class=\"nx\">notifyList</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">wait</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nx\">Uint32</span> <span class=\"c1\">// 下一个等待者的票号（原子递增）\n</span><span class=\"c1\"></span>\t<span class=\"nx\">notify</span> <span class=\"kt\">uint32</span> <span class=\"c1\">// 下一个要通知的票号\n</span><span class=\"c1\"></span>\n\t<span class=\"c1\">// 等待者列表\n</span><span class=\"c1\"></span>\t<span class=\"nx\">lock</span> <span class=\"nx\">mutex</span>\n\t<span class=\"nx\">head</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span>\n\t<span class=\"nx\">tail</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span>\n<span class=\"p\">}</span>\n</code></pre></div><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-3fb9638fbdc6e7d6b5929c1f8de1f53e_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2074\" data-rawheight=\"1144\" data-original-token=\"v2-82b547b7220193f2e8a364af9adbee69\" class=\"origin_image zh-lightbox-thumb\" width=\"2074\" data-original=\"https://pic3.zhimg.com/v2-3fb9638fbdc6e7d6b5929c1f8de1f53e_r.jpg\"/></figure><p data-pid=\"jb_d8kUr\">理解 <code>sync.Cond</code> 的关键，在于理解它如何解决<b>虚假唤醒</b>和<b>消息丢失</b>的问题。Go 使用了一种类似银行排号系统的逻辑。</p><div class=\"highlight\"><pre><code class=\"language-text\">wait = 5, notify = 2\n         ↓\n当前排队: ticket 2, 3, 4 (还未通知)\n即将排队: ticket 5, 6, 7... (新来的)</code></pre></div><h3>6.3 c.Wait()</h3><p data-pid=\"J7VETW_C\">当一个 Goroutine 调用 <code>Wait()</code> 时，发生了以下严密的步骤：</p><ol><li data-pid=\"lwajUXCJ\"><b>拿号 (Ticket Allocation)</b>： 调用 <code>runtime_notifyListAdd</code>。这本质上是一个原子操作，将 <code>notifyList</code> 中的 <code>wait</code> 计数器加 1，并返回当前的序列号（Ticket）。</li><li data-pid=\"0jSagpft\"><b>解锁 (Unlock)</b>： 调用 <code>c.L.Unlock()</code>。必须先拿号，再解锁。这保证了即使你在解锁后、睡觉前，有人发送了信号，你的号也已经排进去了，不会错过通知。</li><li data-pid=\"-WCX8VCl\"><b>睡觉 (Block)</b>： 调用 <code>runtime_notifyListWait(Ticket)</code>，把自己挂起，等待有人喊”第 100 号”或者”所有人”醒来。</li><li data-pid=\"qxhKPEHI\"><b>重新加锁 (Lock)</b>： 当被唤醒后，<code>Wait</code> 函数返回前，会<b>自动</b>调用 <code>c.L.Lock()</code>。</li></ol><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"o\">*</span><span class=\"nx\">Cond</span><span class=\"p\">)</span> <span class=\"nf\">Wait</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 步骤 1: 拿号 (Ticket Allocation)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 关键点：在解锁之前先拿号！\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 这保证了即使我还没睡着，Signal 发送者也能知道&#34;有一个持有 t 号的人正在赶来的路上&#34;。\n</span><span class=\"c1\"></span>    <span class=\"nx\">t</span> <span class=\"o\">:=</span> <span class=\"nf\">runtime_notifyListAdd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// 步骤 2: 解锁 (Unlock User Lock)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 必须解锁，否则 Signal 的发送者无法获得锁来修改条件，死锁。\n</span><span class=\"c1\"></span>    <span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">L</span><span class=\"p\">.</span><span class=\"nf\">Unlock</span><span class=\"p\">()</span>\n\n    <span class=\"c1\">// 步骤 3: 入队并休眠 (Enqueue &amp; Park)\n</span><span class=\"c1\"></span>    <span class=\"nf\">runtime_notifyListWait</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">,</span> <span class=\"nx\">t</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// 步骤 4: 重新加锁 (Relock)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 醒来后，必须恢复到调用 Wait 前的状态，以便重新检查 for !condition()。\n</span><span class=\"c1\"></span>    <span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">L</span><span class=\"p\">.</span><span class=\"nf\">Lock</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">notifyListAdd</span><span class=\"p\">(</span><span class=\"nx\">l</span> <span class=\"o\">*</span><span class=\"nx\">notifyList</span><span class=\"p\">)</span> <span class=\"kt\">uint32</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// This may be called concurrently, for example, when called from\n</span><span class=\"c1\"></span>\t<span class=\"c1\">// sync.Cond.Wait while holding a RWMutex in read mode.\n</span><span class=\"c1\"></span>\t<span class=\"k\">return</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">wait</span><span class=\"p\">.</span><span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">notifyListWait</span><span class=\"p\">(</span><span class=\"nx\">l</span> <span class=\"o\">*</span><span class=\"nx\">notifyList</span><span class=\"p\">,</span> <span class=\"nx\">t</span> <span class=\"kt\">uint32</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"nf\">lockWithRank</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">lockRankNotifyList</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">// 进入 notifyListWait 后，再次检查一下 l.notify），\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 如果 l.notify &gt; t，说明已经被叫过了，\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 那我就不睡了，直接返回。这完美解决了信号丢失问题。\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nf\">less</span><span class=\"p\">(</span><span class=\"nx\">t</span><span class=\"p\">,</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 入队休眠\n</span><span class=\"c1\"></span>\t<span class=\"nx\">s</span> <span class=\"o\">:=</span> <span class=\"nf\">acquireSudog</span><span class=\"p\">()</span>\n\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span> <span class=\"p\">=</span> <span class=\"nf\">getg</span><span class=\"p\">()</span>\n\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">ticket</span> <span class=\"p\">=</span> <span class=\"nx\">t</span>\n\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span> <span class=\"p\">=</span> <span class=\"mi\">0</span>\n\t<span class=\"nx\">t0</span> <span class=\"o\">:=</span> <span class=\"nb\">int64</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">blockprofilerate</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">t0</span> <span class=\"p\">=</span> <span class=\"nf\">cputicks</span><span class=\"p\">()</span>\n\t\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span> <span class=\"p\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">tail</span> <span class=\"o\">==</span> <span class=\"kc\">nil</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">head</span> <span class=\"p\">=</span> <span class=\"nx\">s</span>\n\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">tail</span><span class=\"p\">.</span><span class=\"nx\">next</span> <span class=\"p\">=</span> <span class=\"nx\">s</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">tail</span> <span class=\"p\">=</span> <span class=\"nx\">s</span>\n\t<span class=\"nf\">goparkunlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">waitReasonSyncCondWait</span><span class=\"p\">,</span> <span class=\"nx\">traceBlockCondWait</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">t0</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">blockevent</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span><span class=\"o\">-</span><span class=\"nx\">t0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"nf\">releaseSudog</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>6.4 c.Signal()</h3><p data-pid=\"B6tXQits\">当调用 <code>Signal()</code> 时：</p><ol><li data-pid=\"a9M2v82o\">调用 <code>runtime_notifyListNotifyOne</code>。</li><li data-pid=\"ijxDLamq\">它会查找 <code>notifyList</code> 中<b>最早</b>那个还没被唤醒的 Ticket（比如第 99 号已醒，现在叫第 100 号）。</li><li data-pid=\"E8QcK6jF\">通过 <code>sema</code>（信号量）精确唤醒持有该 Ticket 的那个 Goroutine。</li></ol><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"o\">*</span><span class=\"nx\">Cond</span><span class=\"p\">)</span> <span class=\"nf\">Signal</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"nf\">runtime_notifyListNotifyOne</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">notifyListNotifyOne</span><span class=\"p\">(</span><span class=\"nx\">l</span> <span class=\"o\">*</span><span class=\"nx\">notifyList</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 如果 wait == notify，说明没有新的等待者，直接返回\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">wait</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span>\n\t<span class=\"p\">}</span>\n\n        <span class=\"c1\">// 获取锁，因为需要修改 notifylist\n</span><span class=\"c1\"></span>\t<span class=\"nf\">lockWithRank</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">lockRankNotifyList</span><span class=\"p\">)</span>\n\n\t<span class=\"c1\">// 双重检查，如果没有新的等待者，则直接返回\n</span><span class=\"c1\"></span>\t<span class=\"nx\">t</span> <span class=\"o\">:=</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">notify</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">t</span> <span class=\"o\">==</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">wait</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 更新下一个 notify 的票号\n</span><span class=\"c1\"></span>\t<span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Store</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">,</span> <span class=\"nx\">t</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n\t<span class=\"c1\">// 从 notifyList 尝试唤醒一个休眠中的 G\n</span><span class=\"c1\"></span>\t<span class=\"k\">for</span> <span class=\"nx\">p</span><span class=\"p\">,</span> <span class=\"nx\">s</span> <span class=\"o\">:=</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"nx\">sudog</span><span class=\"p\">)(</span><span class=\"kc\">nil</span><span class=\"p\">),</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">head</span><span class=\"p\">;</span> <span class=\"nx\">s</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span><span class=\"p\">;</span> <span class=\"nx\">p</span><span class=\"p\">,</span> <span class=\"nx\">s</span> <span class=\"p\">=</span> <span class=\"nx\">s</span><span class=\"p\">,</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">next</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">ticket</span> <span class=\"o\">==</span> <span class=\"nx\">t</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"nx\">n</span> <span class=\"o\">:=</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">next</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"nx\">p</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"nx\">p</span><span class=\"p\">.</span><span class=\"nx\">next</span> <span class=\"p\">=</span> <span class=\"nx\">n</span>\n\t\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">head</span> <span class=\"p\">=</span> <span class=\"nx\">n</span>\n\t\t\t<span class=\"p\">}</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"nx\">n</span> <span class=\"o\">==</span> <span class=\"kc\">nil</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">tail</span> <span class=\"p\">=</span> <span class=\"nx\">p</span>\n\t\t\t<span class=\"p\">}</span>\n\t\t\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\t\t\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">next</span> <span class=\"p\">=</span> <span class=\"kc\">nil</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">.</span><span class=\"nx\">bubble</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nf\">getg</span><span class=\"p\">().</span><span class=\"nx\">bubble</span> <span class=\"o\">!=</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">.</span><span class=\"nx\">bubble</span> <span class=\"p\">{</span>\n\t\t\t\t<span class=\"nb\">println</span><span class=\"p\">(</span><span class=\"s\">&#34;semaphore wake of synctest goroutine&#34;</span><span class=\"p\">,</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">.</span><span class=\"nx\">goid</span><span class=\"p\">,</span> <span class=\"s\">&#34;from outside bubble&#34;</span><span class=\"p\">)</span>\n\t\t\t\t<span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"s\">&#34;semaphore wake of synctest goroutine from outside bubble&#34;</span><span class=\"p\">)</span>\n\t\t\t<span class=\"p\">}</span>\n                        <span class=\"c1\">// 唤醒\n</span><span class=\"c1\"></span>\t\t\t<span class=\"nf\">readyWithTime</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n\t\t\t<span class=\"k\">return</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">readyWithTime</span><span class=\"p\">(</span><span class=\"nx\">s</span> <span class=\"o\">*</span><span class=\"nx\">sudog</span><span class=\"p\">,</span> <span class=\"nx\">traceskip</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">releasetime</span> <span class=\"p\">=</span> <span class=\"nf\">cputicks</span><span class=\"p\">()</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"nf\">goready</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">,</span> <span class=\"nx\">traceskip</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>6.5 c.Broadcast()</h3><p data-pid=\"bt0qCF4-\">当调用 <code>Broadcast()</code> 时：</p><ol><li data-pid=\"5JWgQ7-2\">调用 <code>runtime_notifyListNotifyAll</code>。</li><li data-pid=\"Hq_58VUy\">它不需一个一个叫，而是直接记下当前的 <code>wait</code> 计数器值（比如当前排到了 150 号）。</li><li data-pid=\"V3nmMEsK\">它会唤醒从”当前已唤醒号”到”150 号”之间的<b>所有</b> Goroutine。</li></ol><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"o\">*</span><span class=\"nx\">Cond</span><span class=\"p\">)</span> <span class=\"nf\">Broadcast</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"nf\">runtime_notifyListNotifyAll</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">c</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">notifyListNotifyAll</span><span class=\"p\">(</span><span class=\"nx\">l</span> <span class=\"o\">*</span><span class=\"nx\">notifyList</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// 没有新的等待者，直接返回\n</span><span class=\"c1\"></span>\t<span class=\"k\">if</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">wait</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 上锁\n</span><span class=\"c1\"></span>\t<span class=\"nf\">lockWithRank</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"nx\">lockRankNotifyList</span><span class=\"p\">)</span>\n        <span class=\"c1\">// 清空 notifyList，因为全部都会被唤醒\n</span><span class=\"c1\"></span>\t<span class=\"nx\">s</span> <span class=\"o\">:=</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">head</span>\n\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">head</span> <span class=\"p\">=</span> <span class=\"kc\">nil</span>\n\t<span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">tail</span> <span class=\"p\">=</span> <span class=\"kc\">nil</span>\n\n\t<span class=\"c1\">// 更新 notify 为当前的 wait\n</span><span class=\"c1\"></span>\t<span class=\"nx\">atomic</span><span class=\"p\">.</span><span class=\"nf\">Store</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">notify</span><span class=\"p\">,</span> <span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">wait</span><span class=\"p\">.</span><span class=\"nf\">Load</span><span class=\"p\">())</span>\n\t<span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">l</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n\n\t<span class=\"c1\">// 唤醒旧的 notifyList 的所有 sudog\n</span><span class=\"c1\"></span>\t<span class=\"k\">for</span> <span class=\"nx\">s</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span> <span class=\"p\">{</span>\n\t\t<span class=\"nx\">next</span> <span class=\"o\">:=</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">next</span>\n\t\t<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">next</span> <span class=\"p\">=</span> <span class=\"kc\">nil</span>\n\t\t<span class=\"k\">if</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">.</span><span class=\"nx\">bubble</span> <span class=\"o\">!=</span> <span class=\"kc\">nil</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nf\">getg</span><span class=\"p\">().</span><span class=\"nx\">bubble</span> <span class=\"o\">!=</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">.</span><span class=\"nx\">bubble</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"nb\">println</span><span class=\"p\">(</span><span class=\"s\">&#34;semaphore wake of synctest goroutine&#34;</span><span class=\"p\">,</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">g</span><span class=\"p\">.</span><span class=\"nx\">goid</span><span class=\"p\">,</span> <span class=\"s\">&#34;from outside bubble&#34;</span><span class=\"p\">)</span>\n\t\t\t<span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"s\">&#34;semaphore wake of synctest goroutine from outside bubble&#34;</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">}</span>\n                <span class=\"c1\">// 唤醒\n</span><span class=\"c1\"></span>\t\t<span class=\"nf\">readyWithTime</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n\t\t<span class=\"nx\">s</span> <span class=\"p\">=</span> <span class=\"nx\">next</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>6.6 总结</h3><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-3b13862a7e2435edbd8eff195acf0eee_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2463\" data-rawheight=\"1360\" data-original-token=\"v2-8aa3d099fcfac5ff1aa5733987446021\" class=\"origin_image zh-lightbox-thumb\" width=\"2463\" data-original=\"https://pic1.zhimg.com/v2-3b13862a7e2435edbd8eff195acf0eee_r.jpg\"/></figure><p data-pid=\"wo1p1MOv\"><code>sync.Cond</code> 的核心设计：</p><ul><li data-pid=\"kP4bvsPk\"><b>Ticket 系统</b>：基于票号的通知机制，防止丢失唤醒</li><li data-pid=\"l2zWuSYH\"><b>三步原子操作</b>：Add→Unlock→Wait，顺序不能错</li><li data-pid=\"ZYVqJ5lJ\"><b>必须循环 Wait</b>：防止虚假唤醒和竞态条件</li><li data-pid=\"AbwlbYCR\"><b>关联 Locker</b>：Wait 自动释放和重新获取锁</li></ul><h2>7. 排查锁异常问题</h2><h3>7.1 锁拷贝 go vet</h3><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"nx\">m</span> <span class=\"o\">:=</span> <span class=\"nx\">sync</span><span class=\"p\">.</span><span class=\"nx\">Mutex</span><span class=\"p\">{}</span>\n<span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nf\">Lock</span><span class=\"p\">()</span>\n<span class=\"nx\">n</span> <span class=\"o\">:=</span> <span class=\"nx\">m</span> <span class=\"c1\">// n 拷贝 m\n</span><span class=\"c1\"></span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nf\">Unlock</span><span class=\"p\">()</span>\n<span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nf\">Lock</span><span class=\"p\">()</span>  <span class=\"c1\">// 这里会报错，因为 n 在拷贝 m 的时候，把它已经 lock 的状态也拷贝了\n</span></code></pre></div><p data-pid=\"EGSD3V3o\">这个时候，可以用 Go 提供的 <code>go vet</code> 工具来检查是否存在锁拷贝问题：</p><div class=\"highlight\"><pre><code class=\"language-bash\">➜ go vet main.go\n<span class=\"c1\"># command-line-arguments</span>\n./main.go:16:7: assignment copies lock value to n: sync.Mutex</code></pre></div><blockquote data-pid=\"cSmtxRnI\"><code>go vet</code> 还能检测可能的 bug 和可疑的构造。</blockquote><h3>7.2 数据竞争问题 - go build -race</h3><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// 此处 i 有并发问题\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">*</span><span class=\"kt\">int32</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"o\">*</span><span class=\"nx\">i</span><span class=\"o\">++</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">c</span> <span class=\"o\">:=</span> <span class=\"nb\">int32</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\t<span class=\"k\">for</span> <span class=\"nx\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"p\">&lt;</span> <span class=\"mi\">100</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">go</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">c</span><span class=\"p\">)</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"nx\">time</span><span class=\"p\">.</span><span class=\"nf\">Sleep</span><span class=\"p\">(</span><span class=\"nx\">time</span><span class=\"p\">.</span><span class=\"nx\">Second</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"i-HoDImM\">这个时候，可以用 Go 提供的 <code>go build -race</code> 工具来检查是否存在数据竞争问题：</p><div class=\"highlight\"><pre><code class=\"language-bash\">➜  go build -race main.go\n➜  ./main\n<span class=\"o\">==================</span>\nWARNING: DATA RACE\nRead at 0x00c000124000 by goroutine 7:\n  main.add<span class=\"o\">()</span>\n      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:6 +0x3a\n\nPrevious write at 0x00c000124000 by goroutine 6:\n  main.add<span class=\"o\">()</span>\n      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:6 +0x4e\n\nGoroutine <span class=\"m\">7</span> <span class=\"o\">(</span>running<span class=\"o\">)</span> created at:\n  main.main<span class=\"o\">()</span>\n      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:12 +0x84\n\nGoroutine <span class=\"m\">6</span> <span class=\"o\">(</span>finished<span class=\"o\">)</span> created at:\n  main.main<span class=\"o\">()</span>\n      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:12 +0x84\n<span class=\"o\">==================</span>\nFound <span class=\"m\">1</span> data race<span class=\"o\">(</span>s<span class=\"o\">)</span></code></pre></div><h3>7.3 死锁 go-deadlock</h3><ul><li data-pid=\"JGTpYcp2\"><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sasha-s/go-deadlock\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/sasha-s/go-d</span><span class=\"invisible\">eadlock</span><span class=\"ellipsis\"></span></a></li></ul><h2>8. 再次看 Go 锁的两大基础</h2><p data-pid=\"1nvHQAR4\">在分析完 Go 的各种并发工具之后，相信不少读者都能理解为什么 atomic 和 sema 是 Go 锁的两大基础了。</p> <p data-pid=\"TYQ-svcR\">还是前面那句话：</p><blockquote data-pid=\"dwDK6WZF\">atomic 提供无锁的快速状态管理（CAS、加减），sema 提供有竞争时的 goroutine 休眠/唤醒机制，两者组合实现”乐观尝试 + 悲观等待”的高效并发模型。</blockquote><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-5995811e74b1a5dd8076303270b6d8a0_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1737\" data-rawheight=\"1850\" data-original-token=\"v2-fed24a999f0e065f834be2dccaf25b81\" class=\"origin_image zh-lightbox-thumb\" width=\"1737\" data-original=\"https://pica.zhimg.com/v2-5995811e74b1a5dd8076303270b6d8a0_r.jpg\"/></figure><p data-pid=\"gKopuThG\">这里笔者再次梳理下各个并发工具的如何运用 atomic 和 sema 的：</p><ul><li data-pid=\"Yp1PR9oF\"><code>sync.Mutex</code></li></ul><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Mutex</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">state</span> <span class=\"kt\">int32</span>   <span class=\"c1\">// ← Atomic 操作的目标\n</span><span class=\"c1\"></span>    <span class=\"nx\">sema</span>  <span class=\"kt\">uint32</span>  <span class=\"c1\">// ← Semaphore 使用的地址\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n  <span class=\"c1\">// Lock 流程：\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 1. atomic.CAS(state, 0, 1)          ← Atomic 快速路径\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 2. 失败 → 自旋 + atomic 操作          ← Atomic 重试\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 3. 还失败 → semacquire(&amp;sema)        ← Semaphore 休眠\n</span><span class=\"c1\"></span>\n  <span class=\"c1\">// Unlock 流程：\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 1. atomic.Add(state, -1)            ← Atomic 快速路径\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 2. 有等待者 → semrelease(&amp;sema)      ← Semaphore 唤醒\n</span></code></pre></div><ul><li data-pid=\"W6UuaEFw\"><code>sync.RWMutex</code></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">Atomic: 管理 state（锁定/唤醒/饥饿/等待者）\nSema:   竞争时休眠/唤醒</code></pre></div><ul><li data-pid=\"CyI0sr70\"><code>sync.WaitGroup</code></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">Atomic: 管理 reader 计数和 writer 等待标志\nSema:   writer 等待、reader 等待（两个独立的 sema）</code></pre></div><ul><li data-pid=\"RDFDeYWD\"><code>sync.Once</code></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">Atomic: 管理缓冲区索引、状态标志\nSema:   发送/接收阻塞时休眠/唤醒</code></pre></div><ul><li data-pid=\"vqkrbTLr\"><code>sync.Cond</code></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">Atomic: 管理计数器（Add/Done）\nSema:   Wait() 时如果计数 &gt; 0 则休眠</code></pre></div><ul><li data-pid=\"PeYBVbEU\"><code>Channel</code></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">Atomic: (底层 Mutex 用)\nSema:   Wait() 休眠，Signal/Broadcast 唤</code></pre></div>",
        "visited_count": 361,
        "favorite_count": 26,
        "id": "1984204677873686346",
        "updated": 1765852896,
        "is_navigator": false,
        "image_url": "https://pic1.zhimg.com/v2-47e1676d59e39188f4b522086f7ec433.jpg?source=7e7ef6e2&needBackground=1",
        "preview_text": "",
        "allow_segment_interaction": true,
        "url": "https://api.zhihu.com/articles/1984204677873686346",
        "author": {
          "url": "https://api.zhihu.com/people/14479321d5d0986d5e081c929899294d",
          "url_token": "hedon-3",
          "gender": 1,
          "badge": [
            {
              "type": "identity_people",
              "description": "互联网行业 后端开发工程师"
            }
          ],
          "is_following": false,
          "id": "14479321d5d0986d5e081c929899294d",
          "user_type": "people",
          "name": "再跑一公里",
          "headline": "一名热爱摄影徒步雪山的程序员。个人博客：hedon.top",
          "avatar_url": "https://pica.zhimg.com/50/v2-9a26089127364d24a4c21084bd08071c_l.jpg?source=b6762063",
          "is_org": false,
          "followers_count": 398,
          "is_followed": false
        },
        "comment_count": 0,
        "is_labeled": true,
        "article_type": "normal",
        "vote_next_step": "vote",
        "voteup_count": 7,
        "voting": 0,
        "excerpt": "本文深入剖析 Go 语言中多种锁（Mutex、RWMutex、WaitGroup、Once、Cond）的底层实现原理，结合 atomic 原子操作与 sema 信号量机制，揭示锁的本质和并发安全保障机制，帮助读者以第一性原理理解 Go 并发锁的内部运作。 本篇将进入 Go 语言中关于锁的底层原理的探讨，笔者有幸阅读过 Mara Bos 的 《Rust Atomics and Locks》 ，该书对锁这一概念和底层原理进行了非常详尽的探讨，并且给出了 Rust 中 SpinLock、Mutex、RWMutex、Ch…",
        "preview_type": "default",
        "type": "article",
        "thumbnails": [
          "https://pic1.zhimg.com/v2-47e1676d59e39188f4b522086f7ec433.jpg?source=7e7ef6e2&needBackground=1",
          "https://picx.zhimg.com/50/v2-bcbf864ecb3698ef917bda1afd000202_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-b5f87a4a5f8157f1bc5f27295f3aec7a_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-509b714103ed94955366a694031f4163_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-fed24a999f0e065f834be2dccaf25b81_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-a3d5b9581725cfe1a487b9bc7beca975_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-b679c92015962cce0cf9b73e05e49351_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-f4f79180103e96d2e986199a6be37b41_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-ab33884cd4d7ae215ffb8e9b1097d004_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-82b547b7220193f2e8a364af9adbee69_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-8aa3d099fcfac5ff1aa5733987446021_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-fed24a999f0e065f834be2dccaf25b81_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-47e1676d59e39188f4b522086f7ec433_720w.jpg?source=b6762063"
        ]
      },
      "brief": "{\"source\": \"TS\", \"type\": \"article\", \"id\": 1984204677873686346}",
      "attached_info": "CukNCO/Ln9uNj/b0nQEQBxoJMjY3NzE4OTA5IIGMg8oGKAcwAECMAUpJCh9UU19TT1VSQ0VfWlJFQ0FMTF9JVEVNQ0ZfVVBWT1RFEiBkb2NfdHlwZTogQXJ0aWNsZQppZDogMjY3MjM0NTY0ChgAIAA6AGIgZWFlYTU0MDY2YzgxOWE2YTc5YjlmY2JlMWQ5MjIzMzRyEzE5ODQyMDQ2Nzc4NzM2ODYzNDaCAV9odHRwczovL3BpYzEuemhpbWcuY29tL3YyLTQ3ZTE2NzZkNTllMzkxODhmNGI1MjIwODZmN2VjNDMzLmpwZz9zb3VyY2U9N2U3ZWY2ZTImbmVlZEJhY2tncm91bmQ9MaoBCXJlY29tbWVuZMIBIDE0NDc5MzIxZDVkMDk4NmQ1ZTA4MWM5Mjk4OTkyOTRk8gEKCAwSBk5vcm1hbPIBKAgKEiQzNTQyYjYxNy1hZWJjLTRlZmUtYTJkOC0yYTQzMzQ0YzVlNjPyAQYICxICMjSCAgCIAvHJ4pu5M5ICIDE0NDc5MzIxZDVkMDk4NmQ1ZTA4MWM5Mjk4OTkyOTRkmgIAygIURmlyc3RCcnVzaFdlaWdodFJ1bGXKAhZTaG9ySW50ZXJlc3RXZWlnaHRSdWxlygIWQWN0aW9uU2hvckludGVyZXN0UnVsZcoCG0ludGVyYWN0aW9uU2hvckludGVyZXN0UnVsZcoCF1Rlc3RlZEFuZFdvcmtXZWlnaHRSdWxl2gIfVFNfU09VUkNFX1pSRUNBTExfSVRFTUNGX1VQVk9URegCA/oCC05PUk1BTF9GTE9XigMgZWNjYTExYjZhZThlNGQ5NjgxYTBmY2JjNDkzMzg3ZTWaAw0KAnYyEAAaBW90aGVyqAPpAtgDAOoDG3RleHRBbGxTaXRlSHFBY3Rpb25JdGVtQ0ZWMvoDnAcSDFVOS05PV05fTU9ERSAAKg1OT19JTUFHRV9NT0RFOi0IBBDcDhiyBiIjdjItYmNiZjg2NGVjYjM2OThlZjkxN2JkYTFhZmQwMDAyMDI6LQgCEJkVGLgIIiN2Mi1iNWY4N2E0YTVmODE1N2YxYmM1ZjI3Mjk1ZjNhZWM3YTotCAIQuAgYyggiI3YyLTUwOWI3MTQxMDNlZDk0OTU1MzY2YTY5NDAzMWY0MTYzOi0IBBDJDRi6DiIjdjItZmVkMjRhOTk5ZjBlMDY1ZjgzNGJlMmRjY2FmMjViODE6LQgEEMYLGPYFIiN2Mi1hM2Q1Yjk1ODE3MjVjZmUxYTQ4N2I5YmM3YmVjYTk3NTotCAIQkBcYuAgiI3YyLWI2NzljOTIwMTU5NjJjY2UwY2Y5YjczZTA1ZTQ5MzUxOi0IAhCgERicBiIjdjItZjRmNzkxODAxMDNlOTZkMmU5ODYxOTlhNmJlMzdiNDE6LQgCEM4OGIoHIiN2Mi1hYjMzODg0Y2Q0ZDdhZTIxNWZmYjhlOWIxMDk3ZDAwNDotCAIQ1BcY0AIiI3YyLWVkYTliODY2NWNhZjMzZDAwNzBiNjg3N2ExNTg0Nzk5Oi0IAhDoEBjYAyIjdjItYjk5ZWMyYmVlMWUxOTM1ZjYyY2RjOWQ3YjFhMDljN2E6LQgCELYRGI4CIiN2Mi1hYzY0MmVhNjU0ZDhlYTRiMTA0NjNkMmY1MGJkOTY5NTotCAIQ6BAY2AMiI3YyLWI5OWVjMmJlZTFlMTkzNWY2MmNkYzlkN2IxYTA5YzdhOi0IAhC0Dhj6ASIjdjItM2I1ZmRlNzRmZWU0MDFjMWRkNGNjNWQ2NTUxMTc2NGY6LQgCELAUGIgEIiN2Mi02OGY5ODg3YzhlZDAxYWM2MTU1ZmYwNGMwN2U2ZTJiMzotCAIQxBIYpAMiI3YyLTRkYWNjYjIwYmI0MWI3ZjI1Y2Q3YTM3N2FhYjUzMGFkOi0IAxCaEBj4CCIjdjItODJiNTQ3YjcyMjAxOTNmMmU4YTM2NGFmOWFkYmVlNjk6LQgDEJ8TGNAKIiN2Mi04YWEzZDA5OWZjZmFjNWZmMWFhNTczMzk4NzQ0NjAyMTotCAQQyQ0Yug4iI3YyLWZlZDI0YTk5OWYwZTA2NWY4MzRiZTJkY2NhZjI1YjgxOi0IBBDcCxjeBSIjdjItNDdlMTY3NmQ1OWUzOTE4OGY0YjUyMjA4NmY3ZWM0MzOABACIBACSBAZOb3JtYWyaBAEzoAQAqAQAsAQAugQCYWnCBAM0MDDIBADSBA/mjqjojZDlt7Lmm7TmlrDYBADwBAD5BAAAACCSVm8/gQUAAAAAAAAAAIkFQgJt3raMsj+SBQCaBQNkZnSiBQNkZnSyBQExuQUAAAAAAAAAANAFAOAFAOgFAPAFGJAGAKAGjQGoBgCSAi4KCTI2NzcxODkwORITMTk4NDIwNDY3Nzg3MzY4NjM0NhgHIgpJTUFHRV9URVhU",
      "action_card": false
    },
    {
      "id": "141_1767705716.45",
      "type": "feed",
      "offset": 141,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705716,
      "updated_time": 1767705716,
      "target": {
        "comment_count": 156,
        "is_labeled": false,
        "visited_count": 84823,
        "id": "1988393688024503974",
        "created_time": 1766849997,
        "reshipment_settings": "allowed",
        "content": "<p data-pid=\"ZjLEahwP\">1、</p><p data-pid=\"K8S0rzfU\"><b>“富不住大屋”，这句话亘古不变。</b></p><p data-pid=\"FukFpRRa\">凡事发迹后搬进大房子，但家里人丁不兴镇不住的，或者是本人的主卧空间很大那种，都富不过三五年。</p><p data-pid=\"Et9KjsP1\">大家可以去看看，很多<a href=\"https://zhida.zhihu.com/search?content_id=751824895&amp;content_type=Answer&amp;match_order=1&amp;q=%E6%B3%95%E6%8B%8D%E6%9F%A5%E5%B0%81&amp;zhida_source=entity\" class=\"internal\" target=\"_blank\">法拍查封</a>的豪宅，都是主卧很宽敞的户型，这种房子谁来了都接不住，住进去财气很快就散没了。</p><p data-pid=\"t-Dhj9W9\">有钱了换大房子没问题，大平层、别墅、四合院.....前提是家里人多热闹，都住进去旺人气;</p><p data-pid=\"ttz22SEM\">另外卧室设计一定要隐蔽且温馨小巧，不要太空。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"sMDv__RX\">2、</p><p data-pid=\"AfghvgPP\"><b>人生最大的报应之一，就是婚姻:</b></p><p data-pid=\"wsPxqqPa\">你遇见谁和谁结合，然后走进婚姻，过什么日子，其实就是你精准的找到了自己的报应。找到对的人，那就是善报，,找到错的人，那就是恶报。但是，它的最初都是伪装成大红喜事”的面目出现的。</p><p data-pid=\"wp7-dOER\">所有人都认为这是奔向幸福的起点，然而有的人是起点，有的人却是终点，快则一年半载，慢则十年八年，感情的退去，缘分的淡化，很多人才逐渐发现它原来是报应，是要偿还的<a href=\"https://zhida.zhihu.com/search?content_id=751824895&amp;content_type=Answer&amp;match_order=1&amp;q=%E5%9B%A0%E6%9E%9C&amp;zhida_source=entity\" class=\"internal\" target=\"_blank\">因果</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"pqCjA_ye\">3、</p><p data-pid=\"PQKRBium\"><b>不要介入别人的因果，不然你就会吃了他的果。</b></p><p data-pid=\"FPDpcuLl\">有些忙不能乱帮，你帮了，就要承担那个果。</p><p data-pid=\"AiZ1bMDe\">这个果也不是什么预料不到的事情，举个小例子，你借钱给别人，本来是他没钱，但他不还你，没钱的就是你。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"1A1fOoLG\">4、</p><p data-pid=\"zmJTp5KD\">99%的焦虑都来自于虚度时间和没有好好做事，所以唯一的解决办法就是行动起来，认真做完事情，战胜焦虑，战胜那些心里空荡荡的时刻，而不是选择逃避。</p><p data-pid=\"RB6TtfEL\"><b>不要站在原地想象困难，行动永远是改变现状的最佳方式。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"D4NbU_Da\"><b>5、</b></p><p data-pid=\"vIQGnbY7\"><b>搞钱才能让一个人通透，读书、性、爱情、婚姻、等都只会让一个人愚蠢。</b>从赚100块钱，1000块钱，1万块钱，10万块钱开始赚。</p><p data-pid=\"e9QZU4Ru\">实际是检验真理的唯一标准，只有赚钱才会让一个人越来越聪明。一个人只有赚到了钱，才会对这个世界的认知更加深刻，才会真的了解这个社会的运转机制。</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-4b6b057028a0bce18914a2564c4ad45d_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1085\" data-rawheight=\"1446\" data-original-token=\"v2-66c5ce0c477dada123e6f2334f83fbc9\" class=\"origin_image zh-lightbox-thumb\" width=\"1085\" data-original=\"https://pic4.zhimg.com/v2-4b6b057028a0bce18914a2564c4ad45d_r.jpg\"/></figure><p data-pid=\"RE7L_wY0\">6、</p><p data-pid=\"k_PDEaQs\"><b>人年轻的时候，千万不要太讲究。</b></p><p data-pid=\"bwdC-4iI\">开什么样的车子、用什么样的手机、戴什么样的手表、穿什么样的衣服，不是你考虑的主要问题.</p><p data-pid=\"5Uda_KKs\">买了和经济实力不匹配的物品，用起来都小心翼翼的，无形中增加了精神损耗。人的精力有限，年轻的时候应该多想办法搞钱。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"O7WD-QzB\">7、</p><p data-pid=\"P_8xx8q-\">很通透的一段话，看完瞬间清醒。<a href=\"https://zhida.zhihu.com/search?content_id=751824895&amp;content_type=Answer&amp;match_order=1&amp;q=%E6%9B%BE%E4%BB%95%E5%BC%BA&amp;zhida_source=entity\" class=\"internal\" target=\"_blank\">曾仕强</a>说，我不惑之年才悟出这些道理。</p><p data-pid=\"vLws2K-2\">心软+之人，便是无福之人，心软之人，纵然委屈自己，也要成全对方。心软，看似豁达，实则愚钝，看似善良，实则懦弱。</p><p data-pid=\"PFMU1W87\">太多人因为可怜别人，最后自己变成了可怜人。人品越好，朋友越少，心越善良，苦难越多。</p><p data-pid=\"Hc0OwZw1\"><b>不要随便可怜任何人。心软之人，处处妥协，不断退让，经常给别人伤害自己的机会。千万记住人不应该心软，尤其是因为心软去帮助不应该帮助人，那是在分走自己的福气。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"gfFphzpx\"><b>8、</b></p><p data-pid=\"kogiH-sR\">比变好更好的方式是慢慢变好，比瘦更好的方式是健康地瘦，比多读书更好的阅读是有选择地读，比结婚更重要的事情是遇到合适的人。</p><p data-pid=\"2P38hlJS\"><b>不用担心“暂时落后”，不必恐慌“一无所有”，人生的路曲折且漫长，偶尔堵车很正常，就像导航提示的那样：前方道路拥堵，但你仍然在最佳路线上。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"M4j8ILzy\"><b>9、</b></p><p data-pid=\"K7X7x7r1\">你每天都很急，60秒的红灯等不及要闯，三分钟的泡面等不及要吃，路程三天的快递等不及要催；</p><p data-pid=\"NeqNffiZ\">追剧要两倍速，比赛只关心结果。结果是，只要活着，就一定会有引起你焦虑的事情，它们时刻在提醒你，别人有的，你都没有。</p><p data-pid=\"NTcDnVn0\"><b>结果是，你卷又卷不赢，躺又躺不平，只好一边控诉内卷，祈祷生活节奏能慢下来，一边又被迫焦虑地努力着，继续对内卷推波助澜。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"mBsts009\"><b>10、</b></p><p data-pid=\"NeIwYM3u\"><b>能控制情绪，而不是成为情绪的奴隶。</b></p><p data-pid=\"sEtSz1au\">生活中出现各种状况，不会条件反应似的一点就爆，成为情绪的奴隶，他们总是能根据情况，有选择地表现出自己该表现的情绪，而不是事情让它该有的情绪。</p><p data-pid=\"gdivObdY\">狠人几乎都不会哭，也不会闹，因为那些都是小孩子干的事。但凡相处让自己感觉很累的关系，直接结束就ok，还在那煎熬干嘛呢。</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-0c8ef2ead74af554c7e4e0028ccda411_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"664\" data-rawheight=\"792\" data-original-token=\"v2-3b8866197756687ad5c396d2b068be1f\" class=\"origin_image zh-lightbox-thumb\" width=\"664\" data-original=\"https://picx.zhimg.com/v2-0c8ef2ead74af554c7e4e0028ccda411_r.jpg\"/></figure><p data-pid=\"WUluOWUS\">11、</p><p data-pid=\"fWLhgkwB\"><b>学校不会教你搞钱的学问。</b></p><p data-pid=\"CwoV-HMX\">搞钱的学问，要么有贵人带，要么自己开悟。</p><p data-pid=\"aUAROto4\">这两个的大前提都是要多接触外面的世界，多跟别人交流，不要沉浸在自己的小圈子里。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"AsPKydqQ\">12、</p><p data-pid=\"vlf529zH\">这个世界上在意你的和讨厌你的可能加起来都不超过十个，所以你可能真的没那么多观众。内耗的本质其实就是有点聪明，但是不多。</p><p data-pid=\"g129sqJL\">首先，愚蠢的人肯定不会内耗，聪明人也不会。最内耗的就是那些有点小聪明但是不够多的人，看透了一部分社会的本质，或者说自认为看透了一部分社会的本质，但是又接受不了这些信息给自己带来的冲击，总认为别人会关注自己有没有钱，够不够漂亮，拥有的多不多，但其实都是自己给自己加戏。</p><p data-pid=\"XuT04A8v\">你一定要搞清楚，对方如何看待你是对方的事情，过于在意他人评价只会让你感到痛苦，其实你真的不需要在乎自己是不是有存在感，你要做的就是找到自己的节奏和步调。</p><p data-pid=\"atBTBEgt\">慢慢的你会发现其实一切都不晚，在这个过程中一定会有恰到好处的时机给予你想要的那些东西。如果你眼下得不到，要么就是时机没到，要么就是你还配不上。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"g4-v8mg9\">13、</p><p data-pid=\"62ANL8OE\">生活中得罪几个人，做错几件事儿，真的没那么可怕。</p><p data-pid=\"pEOgPHjW\">一辈子活得委曲求全，战战兢兢才是最可怕的。你一定要明白，人生是一条起起伏伏的长线，你的人生一定不会因为任何一个单一的时间点就被毁掉。一旦你习惯了取悦他人，那你的人生就会有取悦不完的人，但如果你习惯了取悦自己，那就自然一定会不断有新的人来取悦你。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"9gmE6rE4\">14、</p><p data-pid=\"sosVWaLk\">人生本来就没什么意义，低调平凡也不等于虚度光阴，轰轰烈烈也不一定就是意义非凡。人生的本质就是用于体验，万物不为我所有，但为我所用。</p><p data-pid=\"jqzTEiv9\">这世间的一切都不是真正属于你，只有你的体验，你的情绪是你的。所以慢慢学会接受自己的平庸和愚钝真的没什么不好，允许自己做错事，允许自己看错人，允许自己的不完美。</p><p data-pid=\"AQfc3ZLW\">每个人的人生道路都充满了遗憾，所以真正聪明的做法就是带着遗憾绽放，带着遗憾去体验人生。</p><p data-pid=\"KKZKn-KN\">我希望有一天，你可以真正的和自己和解，放下你的焦虑和内耗。人生是旷野，不是轨道，专注当下，享受当下，活着就是最大的意义。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"E0S6sv_P\">15、</p><p data-pid=\"m2BAvr75\">带你赚钱的人，约你学习的人，和你谈人生的人，和你聊理想的人，处处为你加油打气，希望你越来越好的人，这才是贵人。</p><p data-pid=\"XugxtN6m\">故意在人多的时候训你的人，是做给别人看的，你别往心里去，他是小人，在没人的时候，才骂你跟你交心的人，千万要记住，他是你的贵人。</p><p data-pid=\"JljBhZzI\">真正的贵人，会鼓励你，指引你，帮助你，能开拓你的眼界，纠正你的格局，带给你正能量。</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-8cc3e14fc2ef4b4ca542e1d5b9a48eaf_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1146\" data-rawheight=\"1554\" data-original-token=\"v2-dece6fb5a4998643f2bb1ce32d5c6741\" class=\"origin_image zh-lightbox-thumb\" width=\"1146\" data-original=\"https://pic4.zhimg.com/v2-8cc3e14fc2ef4b4ca542e1d5b9a48eaf_r.jpg\"/></figure><p data-pid=\"XeO6mIPm\">16、</p><p data-pid=\"pyhy6Yke\">放下助人情节，尊重他人命运。</p><p data-pid=\"70sVBC6K\">村里的老人活到九十多岁，最大的原因就是不多管闲事，烂泥烂的好好的，你非要给他扶上墙，咸鱼躺的好好的，你非要给他翻个身。</p><p data-pid=\"VTDQ05NK\">一块朽木，你非要把它雕成才，克制自己去纠正别人的欲望，不要随意介入别人的因果。 社会的游戏规则，一层一层的难度系数和代价，都锁死着不同的人，层层递进。</p><p data-pid=\"VxiNiHXE\">才会有这么一句话：成年人，最终是被筛选出来的。</p><p data-pid=\"EjebwJnZ\">你能赚得到多少钱，不是时间熬出来的，是社会中的他人，把你筛选出来的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"VWcVYJx1\">17、</p><p data-pid=\"fcfxsvbH\">懒惰是很奇怪的东西，它使你以为那是安逸，是休息，是福气；但实际上它所给你的是无聊，是倦怠，是消沉；它剥夺你对前途的希望，割断你和别人之间的友情，使你心胸日渐狭窄，对人生也越来越怀疑 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"_hW4IZfP\">18、</p><p data-pid=\"GSWfo22M\">你所赚的每一块钱，都是你前半生做对事情得到的赞赏；</p><p data-pid=\"XKIY_MtZ\">你所花掉的每一块钱，都是你为你想要的世界投票；</p><p data-pid=\"hfeIg8SX\">你所亏掉的每一块钱，都是你为你认知的缺陷交学费。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"WCC5pkwb\">19、</p><p data-pid=\"jjtNeyzI\">只有深度破碎过的人才会大彻大悟。</p><p data-pid=\"gOD8tugf\">人在大彻大悟之前总有盲目自大的“小我”，自作聪明，自以为是，用狭隘的世界观判断周遭的世界。这是绝大部分人的现状。</p><p data-pid=\"CJSZVYRV\">所以只有极度深刻的痛苦，把你自大的头脑小我给打碎了，人才会愿意开始放下自己的自作聪明，回归心智去领悟真理，去诚实的面对自己内心的匮乏和鄙陋。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"gGP4dn5G\">20、</p><p data-pid=\"FtOIPxx1\">99%的焦虑都来自于虚度时间和没有好好做事，所以唯一的解决办法就是行动起来，认真做完事情，战胜焦虑，战胜那些心里空荡荡的时刻，而不是选择逃避。</p><p data-pid=\"0ETL4OJV\">不要站在原地想象困难，行动永远是改变现状的最佳方式。</p><p data-pid=\"0tuqA4oy\">当你刷到这里，点赞留下一句“我很好”，与过去和解，你将越来越顺利!</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-3adba7ae8f9b31745a9a6dce5609e4ec_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"828\" data-rawheight=\"1090\" data-original-token=\"v2-5c83abab97f7946057cd7797feaf7079\" class=\"origin_image zh-lightbox-thumb\" width=\"828\" data-original=\"https://pic3.zhimg.com/v2-3adba7ae8f9b31745a9a6dce5609e4ec_r.jpg\"/></figure><p data-pid=\"g3P9yGne\">21、</p><p data-pid=\"_FlmCyvT\">人生没有意义，不稳定才是常态。人的痛苦，无非就是，想不出，做不到，拿不起，放不下。</p><p data-pid=\"WpnHgnYa\">要保证这些，一个月只要收入1500块足够了，劳动三天，摸鱼两天，就能过上明末只那个农民梦寐以求的生活。</p><p data-pid=\"VzgOb8Mr\">人活着只需要，水，食物，空气，保暖以及安全超出这之上的游戏规则，是上层人给下层人制定的机锁，是束缚。权利，地位，婚姻，都是。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"W6mLlJFi\">22、</p><p data-pid=\"RfMMn7AZ\">如果你做事，因为拖延感到焦虑，那就去做最重要的一件事，抓住主要矛盾，把所有的力量，集中精力攻克的一个最重要的任务，只做那一件事。</p><p data-pid=\"t-kis0IC\">等这件事情处理完之后，再把所有的时间都拿来放松，养精蓄锐，绝不在不重要的事情上浪费精力。你发现你的矛盾，你生活中的矛盾和痛苦至少能减少70%。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"7L4rQOgm\">23、</p><p data-pid=\"CsQf1___\">人类所有真实的快乐，一定是恒久的努力。</p><p data-pid=\"H8YkO_OL\">那些瞬间的满足、短暂的享乐之后便是无尽的空虚。</p><p data-pid=\"GoKPZjAf\">这世上真正有价值的事情，从来都不是轻松就能达到的，你必须克服懒惰、克服急功近利、克制你一蹴而就的妄想。</p><p data-pid=\"4kFVr7LM\">通过自律、克制、努力所实现的人生，才会令人拥有持续的快乐与平和。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"yWDK938O\">24、</p><p data-pid=\"ix_2fVhW\">没有人会去帮助一个毫无价值的人，你必须好好经营自己，就算你跌入了谷底，也要有与人交换的筹码，这就是<a href=\"https://zhida.zhihu.com/search?content_id=736585862&amp;content_type=Answer&amp;match_order=1&amp;q=%E5%BC%BA%E8%80%85%E5%AE%9A%E5%BE%8B&amp;zhida_source=entity\" class=\"internal\" target=\"_blank\">强者定律</a>。</p><p data-pid=\"AHnEWg9Z\">你知道什么叫最顶级的能力吗?就是当所有人认为你只有死路一条的时候，而你却能够起死回生，解决所有的困难，力挽狂澜。</p><p data-pid=\"s7u7b7_P\">水到绝境是风景，人到绝境是重生。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"5Epx_Jqf\">25、</p><p data-pid=\"8kHL_5m7\">比变好更好的方式是慢慢变好，比瘦更好的方式是健康地瘦，比多读书更好的阅读是有选择地读，比结婚更重要的事情是遇到合适的人。不用担心“暂时落后”，不必恐慌“一无所有”，人生的路曲折且漫长，偶尔堵车很正常，就像导航提示的那样：前方道路拥堵，但你仍然在最佳路线上。<br/> </p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-1850976daaa5ac373253816c0a0220b3_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"721\" data-original-token=\"v2-eef28612cabe503678a1dd48fda70474\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-1850976daaa5ac373253816c0a0220b3_r.jpg\"/></figure><p data-pid=\"uRdt3GjX\">感谢你在千千万万个回答点开了我的，如果觉得这些句子不错，记得点赞、收藏呀～</p><p data-pid=\"Q0pzXFpQ\">图片和文案均来自网络，侵删~</p><p data-pid=\"2ZLfmCqf\">嗨，我是浅浅，全网17W粉的自由撰稿人，致力于分享优质文案｜女性成长｜自律精进｜阅读写作｜学习 干货～</p><p data-pid=\"_CqdRRoP\">欢迎关注我 <a class=\"member_mention\" href=\"https://www.zhihu.com/people/aea4bc69fad818e89617d062b3bc0f4b\" data-hash=\"aea4bc69fad818e89617d062b3bc0f4b\" data-hovercard=\"p$b$aea4bc69fad818e89617d062b3bc0f4b\">@浅浅同学</a> ，我们⼀起精进⾃我，成为更好的自己</p>",
        "type": "answer",
        "voteup_count": 1451,
        "is_navigator": false,
        "author": {
          "user_type": "people",
          "gender": 0,
          "followers_count": 4287,
          "id": "aea4bc69fad818e89617d062b3bc0f4b",
          "url": "https://api.zhihu.com/people/aea4bc69fad818e89617d062b3bc0f4b",
          "url_token": "44-52-51-21",
          "name": "浅浅同学",
          "headline": "",
          "avatar_url": "https://pic1.zhimg.com/50/v2-c9118a1144700448f01069b4e2c3d79a_l.jpg?source=b6762063",
          "is_org": false,
          "is_following": false,
          "is_followed": false
        },
        "preview_text": "",
        "thumbnails": [
          "https://pic1.zhimg.com/50/v2-66c5ce0c477dada123e6f2334f83fbc9_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-de0a84508463abe34b70fedd5cb498ad_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-1ce73c6ae0d2270c6372b66a9f28ded8_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-5c83abab97f7946057cd7797feaf7079_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-eef28612cabe503678a1dd48fda70474_720w.jpg?source=b6762063"
        ],
        "url": "https://api.zhihu.com/answers/1988393688024503974",
        "is_copyable": true,
        "thumbnail": "https://picx.zhimg.com/50/v2-66c5ce0c477dada123e6f2334f83fbc9_720w.jpg?source=b6762063",
        "preview_type": "default",
        "navigator_vote": false,
        "allow_segment_interaction": true,
        "updated_time": 1766849997,
        "thanks_count": 119,
        "answer_type": "normal",
        "excerpt": "1、 “富不住大屋”，这句话亘古不变。凡事发迹后搬进大房子，但家里人丁不兴镇不住的，或者是本人的主卧空间很大那种，都富不过三五年。 大家可以去看看，很多 法拍查封 的豪宅，都是主卧很宽敞的户型，这种房子谁来了都接不住，住进去财气很快就散没了。有钱了换大房子没问题，大平层、别墅、四合院.....前提是家里人多热闹，都住进去旺人气; 另外卧室设计一定要隐蔽且温馨小巧，不要太空。 2、 人生最大的报应之一，就是婚姻:…",
        "favorite_count": 2642,
        "relationship": {
          "is_thanked": false,
          "is_nothelp": false,
          "voting": 0
        },
        "vote_next_step": "vote",
        "segment_infos": [
          {
            "pid": "zmJTp5KD",
            "text": "99%的焦虑都来自于虚度时间和没有好好做事，所以唯一的解决办法就是行动起来，认真做完事情，战胜焦虑，战胜那些心里空荡荡的时刻，而不是选择逃避。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 71,
                "seg_info": {
                  "seg_ids": [
                    "1989352580959195168"
                  ],
                  "is_like": false,
                  "like_count": 5,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "RB6TtfEL",
            "text": "不要站在原地想象困难，行动永远是改变现状的最佳方式。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 26,
                "seg_info": {
                  "seg_ids": [
                    "1989352596406813875"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "e9QZU4Ru",
            "text": "实际是检验真理的唯一标准，只有赚钱才会让一个人越来越聪明。一个人只有赚到了钱，才会对这个世界的认知更加深刻，才会真的了解这个社会的运转机制。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 70,
                "seg_info": {
                  "seg_ids": [
                    "1989352649120845917"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "Hc0OwZw1",
            "text": "不要随便可怜任何人。心软之人，处处妥协，不断退让，经常给别人伤害自己的机会。千万记住人不应该心软，尤其是因为心软去帮助不应该帮助人，那是在分走自己的福气。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 77,
                "seg_info": {
                  "seg_ids": [
                    "1991049788041479134"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "2P38hlJS",
            "text": "不用担心“暂时落后”，不必恐慌“一无所有”，人生的路曲折且漫长，偶尔堵车很正常，就像导航提示的那样：前方道路拥堵，但你仍然在最佳路线上。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 68,
                "seg_info": {
                  "seg_ids": [
                    "1988975747046582044"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "pEOgPHjW",
            "text": "一辈子活得委曲求全，战战兢兢才是最可怕的。你一定要明白，人生是一条起起伏伏的长线，你的人生一定不会因为任何一个单一的时间点就被毁掉。一旦你习惯了取悦他人，那你的人生就会有取悦不完的人，但如果你习惯了取悦自己，那就自然一定会不断有新的人来取悦你。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 122,
                "seg_info": {
                  "seg_ids": [
                    "1991236938590597307"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "sosVWaLk",
            "text": "人生本来就没什么意义，低调平凡也不等于虚度光阴，轰轰烈烈也不一定就是意义非凡。人生的本质就是用于体验，万物不为我所有，但为我所用。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 65,
                "seg_info": {
                  "seg_ids": [
                    "1991237157730395939"
                  ],
                  "is_like": false,
                  "like_count": 3,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "AQfc3ZLW",
            "text": "每个人的人生道路都充满了遗憾，所以真正聪明的做法就是带着遗憾绽放，带着遗憾去体验人生。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 43,
                "seg_info": {
                  "seg_ids": [
                    "1990857651538658946"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          },
          {
            "pid": "VTDQ05NK",
            "text": "一块朽木，你非要把它雕成才，克制自己去纠正别人的欲望，不要随意介入别人的因果。 社会的游戏规则，一层一层的难度系数和代价，都锁死着不同的人，层层递进。",
            "marks": [
              {
                "start_index": 0,
                "end_index": 40,
                "seg_info": {
                  "seg_ids": [
                    "1990041766808789244",
                    "1988549643739625411"
                  ],
                  "is_like": false,
                  "like_count": 2,
                  "comment_count": 0,
                  "my_comment_count": 0,
                  "is_span": false
                }
              }
            ]
          }
        ],
        "question": {
          "is_following": false,
          "detail": "",
          "author": {
            "gender": 0,
            "is_followed": false,
            "id": "fb7ccee13cafa9a62ca7ff166279510e",
            "url": "https://api.zhihu.com/people/fb7ccee13cafa9a62ca7ff166279510e",
            "user_type": "people",
            "headline": "",
            "avatar_url": "https://picx.zhimg.com/50/v2-25e4d7803e256253fb696f2287a2022b_l.jpg?source=b6762063",
            "url_token": "36-22-61-86",
            "name": "夢舒",
            "is_org": false,
            "followers_count": 293,
            "is_following": false
          },
          "type": "question",
          "url": "https://api.zhihu.com/questions/659733012",
          "question_type": "normal",
          "id": "659733012",
          "answer_count": 0,
          "follower_count": 0,
          "excerpt": "",
          "relationship": {
            "is_author": false
          },
          "created": 1719194646,
          "comment_count": 20,
          "bound_topic_ids": [
            7490,
            89325,
            139227
          ],
          "title": "大彻大悟的人，都看透了什么 ？"
        },
        "excerpt_new": "1、 “富不住大屋”，这句话亘古不变。凡事发迹后搬进大房子，但家里人丁不兴镇不住的，或者是本人的主卧空间很大那种，都富不过三五年。 大家可以去看看，很多 法拍查封 的豪宅，都是主卧很宽敞的户型，这种房子谁来了都接不住，住进去财气很快就散没了。有钱了换大房子没问题，大平层、别墅、四合院.....前提是家里人多热闹，都住进去旺人气; 另外卧室设计一定要隐蔽且温馨小巧，不要太空。 2、 人生最大的报应之一，就是婚姻:…"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1988393688024503974}",
      "attached_info": "CpoICO/Ln9uNj/b0nQEQBBoJNzYyOTU0Nzg5IM37v8oGKKsLMJwBQI0BSm0KHFRTX1NPVVJDRV9IT1RfQ1JPU1NfUkVBTFRJTUUSR2hvdF9yZWNhbGxfcmVhbHRpbWVfdDpub3JtYWw6MjAyNi0wMS0wNjptYWxlOmJpZ3lvdW5nc3RlcjpvdGhlcjptb250aGx5GAAgADoAWgkxMDg4ODUxOTViIGVhZWE1NDA2NmM4MTlhNmE3OWI5ZmNiZTFkOTIyMzM0chMxOTg4MzkzNjg4MDI0NTAzOTc0igEJNjU5NzMzMDEyqgEJcmVjb21tZW5kwgEgYWVhNGJjNjlmYWQ4MThlODk2MTdkMDYyYjNiYzBmNGLyAQoIDBIGTm9ybWFs8gEoCAoSJDc2ZjUyODBhLWUzYTUtNGE4Yy1iMjk2LWM1MzZlOWZiNTE4ZPIBBggLEgIyNIICAIgC8cnim7kzkgIgYWVhNGJjNjlmYWQ4MThlODk2MTdkMDYyYjNiYzBmNGKaAgDKAhRGaXJzdEJydXNoV2VpZ2h0UnVsZcoCFlNob3JJbnRlcmVzdFdlaWdodFJ1bGXKAhtJbnRlcmFjdGlvblNob3JJbnRlcmVzdFJ1bGXKAhZSZXZpc2l0VmFsdWVXZWlnaHRSdWxl2gIcVFNfU09VUkNFX0hPVF9DUk9TU19SRUFMVElNRegCA/oCC05PUk1BTF9GTE9XigMgZWNjYTExYjZhZThlNGQ5NjgxYTBmY2JjNDkzMzg3ZTWaAw0KAnYyEAAaBW90aGVyqAPXlgXYAwDqAx9ob3RDcm9zc1JlYWxUaW1lQ29udGVudFJlY2FsbGVy+gOKAhIMVU5LTk9XTl9NT0RFIAAqDU5PX0lNQUdFX01PREU6LQgDEL0IGKYLIiN2Mi02NmM1Y2UwYzQ3N2RhZGExMjNlNmYyMzM0ZjgzZmJjOTotCAMQmAUYmAYiI3YyLTNiODg2NjE5Nzc1NjY4N2FkNWMzOTZkMmIwNjhiZTFmOi0IAhD6CBiSDCIjdjItZGVjZTZmYjVhNDk5ODY0M2YyYmIxY2UzMmQ1YzY3NDE6LQgDELwGGMIIIiN2Mi01YzgzYWJhYjk3Zjc5NDYwNTdjZDc3OTdmZWFmNzA3OTotCAMQ0AUY0QUiI3YyLWVlZjI4NjEyY2FiZTUwMzY3OGExZGQ0OGZkYTcwNDc0gAQAiAQAkgQGTm9ybWFsmgQBM6AEAKgEALAEALoEAmFpwgQDNDAwyAQA0gQP5o6o6I2Q5bey5pu05paw2AQA8AQA+QQAAABgbhu0P4EFAAAAAAAAAACJBUICbd62jLI/kgUAmgUDZGZ0ogUDZGZ0sgUBMbkFAAAAAAAAAADQBQDgBQDoBQDwBRiQBgCgBo4BqAYAkgIuCgk3NjI5NTQ3ODkSEzE5ODgzOTM2ODgwMjQ1MDM5NzQYBCIKSU1BR0VfVEVYVA==",
      "action_card": false
    },
    {
      "id": "142_1767705716.943",
      "type": "feed",
      "offset": 142,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705716,
      "updated_time": 1767705716,
      "target": {
        "excerpt_new": "1、再不醒，拿勺都掏干净了   2、谁设计这种口罩的?我们聊聊!   3、在这给大婶儿织毛衣呢   4、性别:公牛!   5、让你拿你就拿，你妈还能害你不成   6、猫:老公你说句话呀   7、鼻子和嘴巴那条沟是用来干啥的   8、你好，雷总让我过来的。   9、从此吃粑你吃尖，电线杆子各呲一边~   10、报警也没用，他算的对   11、辛巴这道歉的姿势，这是有什么讲究吗?   12、律师:很明显，我的委托人有严重的精神疾病   13、一家飞机要几亿 飞机场 航空公司怎么赚钱?   1…",
        "is_labeled": false,
        "visited_count": 35921,
        "id": "1986338064017159983",
        "question": {
          "id": "267249806",
          "type": "question",
          "author": {
            "gender": 0,
            "followers_count": 8,
            "id": "8e01274c09dd4b4656fee65e93e7a111",
            "url": "https://api.zhihu.com/people/8e01274c09dd4b4656fee65e93e7a111",
            "url_token": "llllll-22-42",
            "name": "半夏夏夏夏夏",
            "headline": "",
            "avatar_url": "https://pic1.zhimg.com/50/v2-1ae1725694d43cc95490e3854feb7fbf_l.jpg?source=b6762063",
            "is_following": false,
            "user_type": "people",
            "is_org": false,
            "is_followed": false
          },
          "comment_count": 34,
          "bound_topic_ids": [
            307,
            1309,
            4447,
            4453,
            20223
          ],
          "detail": "",
          "question_type": "normal",
          "answer_count": 0,
          "url": "https://api.zhihu.com/questions/267249806",
          "created": 1518840663,
          "follower_count": 0,
          "title": "你有哪些压箱底的笑话？",
          "is_following": false,
          "excerpt": "",
          "relationship": {
            "is_author": false
          }
        },
        "voteup_count": 233,
        "relationship": {
          "is_thanked": false,
          "is_nothelp": false,
          "voting": 0
        },
        "author": {
          "id": "380a46ecac8645b5fc91417f65b526a3",
          "url": "https://api.zhihu.com/people/380a46ecac8645b5fc91417f65b526a3",
          "url_token": "53-60-32-45-63",
          "followers_count": 283,
          "is_following": false,
          "user_type": "people",
          "name": "安宁",
          "headline": "好物推荐 ‖ 搞笑图片 ‖ 治愈文案",
          "avatar_url": "https://picx.zhimg.com/50/v2-2f1413a6806a4bda2d567fbc3b55178e_l.jpg?source=b6762063",
          "is_org": false,
          "gender": 0,
          "is_followed": false
        },
        "updated_time": 1766359898,
        "favorite_count": 28,
        "answer_type": "normal",
        "url": "https://api.zhihu.com/answers/1986338064017159983",
        "thumbnail": "https://picx.zhimg.com/50/v2-8151bda74c585a4310b82ffa8a49c054_720w.jpg?source=b6762063",
        "is_navigator": false,
        "thanks_count": 92,
        "excerpt": "1、再不醒，拿勺都掏干净了   2、谁设计这种口罩的?我们聊聊!   3、在这给大婶儿织毛衣呢   4、性别:公牛!   5、让你拿你就拿，你妈还能害你不成   6、猫:老公你说句话呀   7、鼻子和嘴巴那条沟是用来干啥的   8、你好，雷总让我过来的。   9、从此吃粑你吃尖，电线杆子各呲一边~   10、报警也没用，他算的对   11、辛巴这道歉的姿势，这是有什么讲究吗?   12、律师:很明显，我的委托人有严重的精神疾病   13、一家飞机要几亿 飞机场 航空公司怎么赚钱?   1…",
        "preview_text": "",
        "reshipment_settings": "disallowed",
        "thumbnails": [
          "https://pic1.zhimg.com/50/v2-8151bda74c585a4310b82ffa8a49c054_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-6422bdc43563347d29223efcaeb2b5e1_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-e604044344121375dcfae30119c8f802_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-62b016a336f61afbbde5095572577aff_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-f6457f25151cb48e42420bd5919b420d_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-c12fb3b82c3e7d17c7b157a49b280d30_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-5aa28ad1dd8496455849d0d712eb87e6_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-6dcd28522fbb6a9f480127c576b8cab2_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-6626915e46e825c762a92ee68c07290f_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-78a1902d347a7f2e585fe4ab5a217b82_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-a1f6b59ba27b03c0b0398eaf09a39ce8_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-9646879cc54bd45010c3bf997688d0bc_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-b12ddc07b2a8728e86e781a24a973d96_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-bfad337e1f41b265792807f6389f2f26_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-bd918cb4da7f29d5ded78ebc54f2e2d6_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-95bf23c673fde2f1074b258cabcb34b5_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-46d73a2691d8c832efffe3698d9aafe1_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-6b398ff4bb20319116babb4ab3c23c56_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-1b33aa9a92a2d350a7245c89e391b31e_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-67e6c341670f7d27ed80e837f25164d3_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-0f8ccf4741b96a55dacff4ba91440f83_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-9e83a5959f5dfcbe2245cd51d7049598_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-aa3ec8b38692a580a8c7fa6373e5fb03_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-8cae6fdf9b84053d81efffdb0197f048_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-b711fb17b73cf6e79764d6c1c672c12d_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-02a4820e7e1a202bc198a67b18647c10_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-be27ff34fa893db6e8bae43102ef1f40_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-576a64b19d7edded7b7b4ec53254ec92_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-872d7fc330ce5863a6f98e7f990190d3_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-457e3effc184f99eb3e5874262df7c19_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-a37dd58dab1655ff20782f914c3ce8d6_720w.jpg?source=b6762063"
        ],
        "navigator_vote": false,
        "comment_count": 0,
        "preview_type": "default",
        "content": "<p data-pid=\"Wpd2vyZ3\">1、再不醒，拿勺都掏干净了</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-3feba124301318ce6e938db2edf30454_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1518\" data-original-token=\"v2-8151bda74c585a4310b82ffa8a49c054\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pica.zhimg.com/v2-3feba124301318ce6e938db2edf30454_r.jpg\"/></figure><p data-pid=\"d7-wEIlB\">2、谁设计这种口罩的?我们聊聊!</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-fb92f67dad0451d424780f4ee246f09b_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1313\" data-original-token=\"v2-6422bdc43563347d29223efcaeb2b5e1\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-fb92f67dad0451d424780f4ee246f09b_r.jpg\"/></figure><p data-pid=\"GoyFJCj6\">3、在这给大婶儿织毛衣呢</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-39a2fae2d9a19322387802dbfcf4b930_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1615\" data-original-token=\"v2-e604044344121375dcfae30119c8f802\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-39a2fae2d9a19322387802dbfcf4b930_r.jpg\"/></figure><p data-pid=\"ekieyWB_\">4、性别:公牛!</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-dfd1dc18d8c0e570724ccf59afbfd20b_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1786\" data-original-token=\"v2-62b016a336f61afbbde5095572577aff\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-dfd1dc18d8c0e570724ccf59afbfd20b_r.jpg\"/></figure><p data-pid=\"SjO4bOMv\">5、让你拿你就拿，你妈还能害你不成</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-aaca8f566eac6f3eccc2e3ec748f7feb_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1291\" data-original-token=\"v2-f6457f25151cb48e42420bd5919b420d\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-aaca8f566eac6f3eccc2e3ec748f7feb_r.jpg\"/></figure><p data-pid=\"4xStxdkm\">6、猫:老公你说句话呀</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-57f29f96a7f4414d5c1abd282f862fb3_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1664\" data-original-token=\"v2-c12fb3b82c3e7d17c7b157a49b280d30\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-57f29f96a7f4414d5c1abd282f862fb3_r.jpg\"/></figure><p data-pid=\"oxAZzrDQ\">7、鼻子和嘴巴那条沟是用来干啥的</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-5ae57dc1d56abc75df9cfb606620dfb8_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"878\" data-original-token=\"v2-5aa28ad1dd8496455849d0d712eb87e6\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-5ae57dc1d56abc75df9cfb606620dfb8_r.jpg\"/></figure><p data-pid=\"VyuGBHxg\">8、你好，雷总让我过来的。</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-b6f003b078c0dc81da53a790a107a597_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1574\" data-original-token=\"v2-6dcd28522fbb6a9f480127c576b8cab2\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-b6f003b078c0dc81da53a790a107a597_r.jpg\"/></figure><p data-pid=\"DeuDbBlL\">9、从此吃粑你吃尖，电线杆子各呲一边~</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-3bff045894a029b6b85881f267f9086f_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1107\" data-original-token=\"v2-6626915e46e825c762a92ee68c07290f\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-3bff045894a029b6b85881f267f9086f_r.jpg\"/></figure><p data-pid=\"bdp15f23\">10、报警也没用，他算的对</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-a6486fff655452aa5ae23afa6560ea22_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1444\" data-original-token=\"v2-78a1902d347a7f2e585fe4ab5a217b82\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pica.zhimg.com/v2-a6486fff655452aa5ae23afa6560ea22_r.jpg\"/></figure><p data-pid=\"_e5XdwP8\">11、辛巴这道歉的姿势，这是有什么讲究吗?</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-303598ee9bf02c11b7d2b203e2ab16ad_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1182\" data-original-token=\"v2-a1f6b59ba27b03c0b0398eaf09a39ce8\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-303598ee9bf02c11b7d2b203e2ab16ad_r.jpg\"/></figure><p data-pid=\"6KL9W931\">12、律师:很明显，我的委托人有严重的精神疾病</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-46ad223be4afc5ed1edad0231c7e730a_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1398\" data-original-token=\"v2-9646879cc54bd45010c3bf997688d0bc\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pica.zhimg.com/v2-46ad223be4afc5ed1edad0231c7e730a_r.jpg\"/></figure><p data-pid=\"_0TpMBUW\">13、一家飞机要几亿 飞机场 航空公司怎么赚钱?</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-da510a3b104a7ca692208704aa06b754_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"923\" data-original-token=\"v2-b12ddc07b2a8728e86e781a24a973d96\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-da510a3b104a7ca692208704aa06b754_r.jpg\"/></figure><p data-pid=\"Rvhiuxlq\">14、这是什么情况?</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-96d46f5fc7bc31e60efac15313f6bb09_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1494\" data-original-token=\"v2-bfad337e1f41b265792807f6389f2f26\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-96d46f5fc7bc31e60efac15313f6bb09_r.jpg\"/></figure><p data-pid=\"Pi9iy0Xe\">15、这两单位怎么凑在一起了?</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-023a25434e1ae3d9537d1b6dd86b259a_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1497\" data-original-token=\"v2-bd918cb4da7f29d5ded78ebc54f2e2d6\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pica.zhimg.com/v2-023a25434e1ae3d9537d1b6dd86b259a_r.jpg\"/></figure><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-84927aa035e8af84b20aeea8959dcf41_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"1619\" data-original-token=\"v2-95bf23c673fde2f1074b258cabcb34b5\" class=\"origin_image zh-lightbox-thumb\" width=\"1220\" data-original=\"https://pic4.zhimg.com/v2-84927aa035e8af84b20aeea8959dcf41_r.jpg\"/></figure><p data-pid=\"2q66vnzS\"><b>快乐打包了，不妨花一秒钟点赞＋关注鼓励一下。❤️❤️❤️</b></p><p data-pid=\"S7yGyUSB\">16、我感觉伤得不止是腿吧。</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-86b50b44c3e8df0e2a6ae138102b1872_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1790\" data-original-token=\"v2-46d73a2691d8c832efffe3698d9aafe1\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-86b50b44c3e8df0e2a6ae138102b1872_r.jpg\"/></figure><p data-pid=\"yUcHtfCD\">17、破我的门你还不够格</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-4d5791ef39cbf2ca0597b59f1b678c67_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1609\" data-original-token=\"v2-6b398ff4bb20319116babb4ab3c23c56\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-4d5791ef39cbf2ca0597b59f1b678c67_r.jpg\"/></figure><p data-pid=\"YMbeG_vB\">18、真?..真猪奶茶</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-9985b2476c883838e4e08f292e2b276e_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1774\" data-original-token=\"v2-1b33aa9a92a2d350a7245c89e391b31e\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pica.zhimg.com/v2-9985b2476c883838e4e08f292e2b276e_r.jpg\"/></figure><p data-pid=\"udv2GtCu\">19、抽压片</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-9f640f727f1bb85436633eafc1e0f5ea_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1625\" data-original-token=\"v2-67e6c341670f7d27ed80e837f25164d3\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-9f640f727f1bb85436633eafc1e0f5ea_r.jpg\"/></figure><p data-pid=\"wq9zO_v4\">20、野钓技巧，人生第一条鱼，还没钩子大</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-3bf56712e009e94cbaec5e40be9afd54_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1611\" data-original-token=\"v2-0f8ccf4741b96a55dacff4ba91440f83\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-3bf56712e009e94cbaec5e40be9afd54_r.jpg\"/></figure><p data-pid=\"BTWWrrXh\">21、?为什么还长草了</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-bee924f2a19ef40a07223b66a296e0c3_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1602\" data-original-token=\"v2-9e83a5959f5dfcbe2245cd51d7049598\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-bee924f2a19ef40a07223b66a296e0c3_r.jpg\"/></figure><p data-pid=\"CUF-nCrX\">22、打开窗户让孤单透气...</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-8a5c64de25b75cf305c9e4100fa4696f_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1630\" data-original-token=\"v2-aa3ec8b38692a580a8c7fa6373e5fb03\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-8a5c64de25b75cf305c9e4100fa4696f_r.jpg\"/></figure><p data-pid=\"vYimvhqE\">23、没车的情况下，大家都是怎么带一月宝宝出门打预防针的?</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-9f8501ef3f71335be79c3ef59996f294_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1679\" data-original-token=\"v2-8cae6fdf9b84053d81efffdb0197f048\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-9f8501ef3f71335be79c3ef59996f294_r.jpg\"/></figure><p data-pid=\"ZtrbqAKL\">24、来聊，村里的小溪，河边这些洞是什么?</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-864a8c502dae546fb183e5e166ad5360_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1052\" data-original-token=\"v2-b711fb17b73cf6e79764d6c1c672c12d\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-864a8c502dae546fb183e5e166ad5360_r.jpg\"/></figure><p data-pid=\"WCFCmj9x\">25、阳台的这根梁有没有办法装饰?</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-617d4eb9a2960174d6fc557514a5c13f_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1325\" data-original-token=\"v2-02a4820e7e1a202bc198a67b18647c10\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-617d4eb9a2960174d6fc557514a5c13f_r.jpg\"/></figure><p data-pid=\"C4bhegEC\">26、机床设备保养及维护</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-db55b7f49fc5b75dca202e94bd1ffa31_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1360\" data-original-token=\"v2-be27ff34fa893db6e8bae43102ef1f40\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-db55b7f49fc5b75dca202e94bd1ffa31_r.jpg\"/></figure><p data-pid=\"nZxMWaDx\">27、这张图说明了什么道理?</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-301cb90d1a77f43349d5634db9cb919b_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1614\" data-original-token=\"v2-576a64b19d7edded7b7b4ec53254ec92\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-301cb90d1a77f43349d5634db9cb919b_r.jpg\"/></figure><p data-pid=\"zKPnSpOq\">28、大妈这生意头脑，想不发财都难啊!</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-fb7f348d80f6658b67e122d05d1b924d_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1132\" data-original-token=\"v2-872d7fc330ce5863a6f98e7f990190d3\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-fb7f348d80f6658b67e122d05d1b924d_r.jpg\"/></figure><p data-pid=\"Jxn8bTwB\">29、幸褔有很多种，有人给你做八菜一汤是一种。</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-c6b3f0ec8f4795f2efaa673d26671a67_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1784\" data-original-token=\"v2-457e3effc184f99eb3e5874262df7c19\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-c6b3f0ec8f4795f2efaa673d26671a67_r.jpg\"/></figure><p data-pid=\"GyaWg2cH\">30、双胞胎为什么要穿得一模一样，目的何在?</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-42d7262d0e5c6ed4cab568bfb8e3af89_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1513\" data-original-token=\"v2-a37dd58dab1655ff20782f914c3ce8d6\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-42d7262d0e5c6ed4cab568bfb8e3af89_r.jpg\"/></figure><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-1b20fa053d0d4ab07e6d2ffdfaeb8f59_1440w.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"240\" data-original-token=\"v2-1b20fa053d0d4ab07e6d2ffdfaeb8f59\" data-thumbnail=\"https://pic4.zhimg.com/v2-1b20fa053d0d4ab07e6d2ffdfaeb8f59_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"426\" data-original=\"https://pic4.zhimg.com/v2-1b20fa053d0d4ab07e6d2ffdfaeb8f59_r.jpg\"/></figure><p data-pid=\"VKZyN9CD\"><b>如果你觉得这篇文章分享的还不错，不妨交个朋友吧，点点关注，近我者富！！！！</b></p><p data-pid=\"XhacHuPZ\"><b>往期精选，更多搞笑段子点击跳转</b></p><a href=\"https://zhuanlan.zhihu.com/p/1986165443958957208\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">有没有笑的停不下来的搞笑图片？</a><a href=\"https://zhuanlan.zhihu.com/p/1985086179251603446\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">你认为最搞笑的图片是哪一张？</a><p data-pid=\"MS6jOS4A\">（图文源于网络，侵删致歉）</p>",
        "allow_segment_interaction": true,
        "type": "answer",
        "is_copyable": false,
        "created_time": 1766359898,
        "vote_next_step": "vote"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1986338064017159983}",
      "attached_info": "CswRCO/Ln9uNj/b0nQEQBBoJNzYyMDgzOTQ2INqGosoGKOkBMABAjgFKQwoXVFNfU09VUkNFX1RIRU1FX1dBS0VfVVASInRoZW1lOmRldGVjdDpjb250ZW50OnRoZW1lOmlkOjMxNTMYACAAOgBaCDIxMzMyNjcxYiBlYWVhNTQwNjZjODE5YTZhNzliOWZjYmUxZDkyMjMzNHITMTk4NjMzODA2NDAxNzE1OTk4M4oBCTI2NzI0OTgwNqoBCXJlY29tbWVuZMIBIDM4MGE0NmVjYWM4NjQ1YjVmYzkxNDE3ZjY1YjUyNmEz8gEKCAwSBk5vcm1hbPIBKAgKEiQ4N2RmNTQ5NC1lYWUzLTRiMDYtYmY0NS1jNzFiZDk2NTA3NWPyAQYICxICMjSCAgCIAvLJ4pu5M5ICIDM4MGE0NmVjYWM4NjQ1YjVmYzkxNDE3ZjY1YjUyNmEzmgIAygIURmlyc3RCcnVzaFdlaWdodFJ1bGXKAhZTaG9ySW50ZXJlc3RXZWlnaHRSdWxlygIUQ29udGVudEFnZVdlaWdodFJ1bGXKAhdUZXN0ZWRBbmRXb3JrV2VpZ2h0UnVsZdoCF1RTX1NPVVJDRV9USEVNRV9XQUtFX1VQ6AIC+gILTk9STUFMX0ZMT1eKAyBlY2NhMTFiNmFlOGU0ZDk2ODFhMGZjYmM0OTMzODdlNZoDDQoCdjIQABoFb3RoZXKoA9GYAtgDAOoDE1RoZW1lV2FrZVVwUmVjYWxsZXL6A/8LEgxVTktOT1dOX01PREUgACoNTk9fSU1BR0VfTU9ERTotCAQQuAgY7gsiI3YyLTgxNTFiZGE3NGM1ODVhNDMxMGI4MmZmYThhNDljMDU0Oi0IAhC4CBihCiIjdjItNjQyMmJkYzQzNTYzMzQ3ZDI5MjIzZWZjYWViMmI1ZTE6LQgCELgIGM8MIiN2Mi1lNjA0MDQ0MzQ0MTIxMzc1ZGNmYWUzMDExOWM4ZjgwMjotCAMQuAgY+g0iI3YyLTYyYjAxNmEzMzZmNjFhZmJiZGU1MDk1NTcyNTc3YWZmOi0IAhC4CBiLCiIjdjItZjY0NTdmMjUxNTFjYjQ4ZTQyNDIwYmQ1OTE5YjQyMGQ6LQgDELgIGIANIiN2Mi1jMTJmYjNiODJjM2U3ZDE3YzdiMTU3YTQ5YjI4MGQzMDotCAIQuAgY7gYiI3YyLTVhYTI4YWQxZGQ4NDk2NDU1ODQ5ZDBkNzEyZWI4N2U2Oi0IAhC4CBimDCIjdjItNmRjZDI4NTIyZmJiNmE5ZjQ4MDEyN2M1NzZiOGNhYjI6LQgCELgIGNMIIiN2Mi02NjI2OTE1ZTQ2ZTgyNWM3NjJhOTJlZTY4YzA3MjkwZjotCAQQuAgYpAsiI3YyLTc4YTE5MDJkMzQ3YTdmMmU1ODVmZTRhYjVhMjE3YjgyOi0IAxC4CBieCSIjdjItYTFmNmI1OWJhMjdiMDNjMGIwMzk4ZWFmMDlhMzljZTg6LQgCELgIGPYKIiN2Mi05NjQ2ODc5Y2M1NGJkNDUwMTBjM2JmOTk3Njg4ZDBiYzotCAMQuAgYmwciI3YyLWIxMmRkYzA3YjJhODcyOGU4NmU3ODFhMjRhOTczZDk2Oi0IAhC4CBjWCyIjdjItYmZhZDMzN2UxZjQxYjI2NTc5MjgwN2Y2Mzg5ZjJmMjY6LQgEELgIGNkLIiN2Mi1iZDkxOGNiNGRhN2YyOWQ1ZGVkNzhlYmM1NGYyZTJkNjotCAIQxAkY0wwiI3YyLTk1YmYyM2M2NzNmZGUyZjEwNzRiMjU4Y2FiY2IzNGI1Oi0IAxC4CBj+DSIjdjItNDZkNzNhMjY5MWQ4YzgzMmVmZmZlMzY5OGQ5YWFmZTE6LQgDELgIGMkMIiN2Mi02YjM5OGZmNGJiMjAzMTkxMTZiYWJiNGFiM2MyM2M1NjotCAMQuAgY7g0iI3YyLTFiMzNhYTlhOTJhMmQzNTBhNzI0NWM4OWUzOTFiMzFlOi0IAhC4CBjZDCIjdjItNjdlNmMzNDE2NzBmN2QyN2VkODBlODM3ZjI1MTY0ZDM6LQgEELgIGMsMIiN2Mi0wZjhjY2Y0NzQxYjk2YTU1ZGFjZmY0YmE5MTQ0MGY4MzotCAEQuAgYwgwiI3YyLTllODNhNTk1OWY1ZGZjYmUyMjQ1Y2Q1MWQ3MDQ5NTk4Oi0IAxC4CBjeDCIjdjItYWEzZWM4YjM4NjkyYTU4MGE4YzdmYTYzNzNlNWZiMDM6LQgCELgIGI8NIiN2Mi04Y2FlNmZkZjliODQwNTNkODFlZmZmZGIwMTk3ZjA0ODotCAIQuAgYnAgiI3YyLWI3MTFmYjE3YjczY2Y2ZTc5NzY0ZDZjMWM2NzJjMTJkOi0IBBC4CBitCiIjdjItMDJhNDgyMGU3ZTFhMjAyYmMxOThhNjdiMTg2NDdjMTA6LQgCELgIGNAKIiN2Mi1iZTI3ZmYzNGZhODkzZGI2ZThiYWU0MzEwMmVmMWY0MDotCAQQuAgYzgwiI3YyLTU3NmE2NGIxOWQ3ZWRkZWQ3YjdiNGVjNTMyNTRlYzkyOi0IAhC4CBjsCCIjdjItODcyZDdmYzMzMGNlNTg2M2E2Zjk4ZTdmOTkwMTkwZDM6LQgCELgIGPgNIiN2Mi00NTdlM2VmZmMxODRmOTllYjNlNTg3NDI2MmRmN2MxOTotCAAQuAgY6QsiI3YyLWEzN2RkNThkYWIxNjU1ZmYyMDc4MmY5MTRjM2NlOGQ2Oi0IABCqAxjwASIjdjItMWIyMGZhMDUzZDBkNGFiMDdlNmQyZmZkZmFlYjhmNTmABACIBACSBAZOb3JtYWyaBAEyoAQAqAQAsAQAugQCYWnCBAM0MDDIBADSBA/mjqjojZDlt7Lmm7TmlrDYBADwBAD5BAAAAMAZZrI/gQUAAAAAAAAAAIkFQgJt3raMsj+SBQCaBQNkZnSiBQNkZnSyBQExuQUAAAAAAAAAANAFAOAFAOgFAPAFGJAGAKAGjwGoBgGSAi4KCTc2MjA4Mzk0NhITMTk4NjMzODA2NDAxNzE1OTk4MxgEIgpJTUFHRV9URVhU",
      "action_card": false
    },
    {
      "id": "143_1767705716.594",
      "type": "feed",
      "offset": 143,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705716,
      "updated_time": 1767705716,
      "target": {
        "reshipment_settings": "allowed",
        "visited_count": 389,
        "favorite_count": 50,
        "type": "answer",
        "updated_time": 1767157345,
        "is_copyable": true,
        "preview_type": "default",
        "preview_text": "",
        "navigator_vote": false,
        "url": "https://api.zhihu.com/answers/1989682798680880756",
        "comment_count": 0,
        "allow_segment_interaction": true,
        "content": "<p data-pid=\"RGeQcL7a\">当年天涯有一篇帖子，讲的是通过每日静坐训练（闭目收心、专注听觉）回收注意力，驯服杂念以提升自控力与专注力，并针对高敏体质人群给出节省能量、保持状态的具体策略。</p><p data-pid=\"ufDkqlYb\"><b>天涯论坛：《驯服自己》</b></p><p data-pid=\"luUturbF\">以下是原文内容：</p><p data-pid=\"VcBaMoYo\">想要变强，第一步就是驯服自己。</p><p data-pid=\"XntwpN2F\">如何驯服自己呢？很简单，就是每天抽出一段时间什么都不做，就是坐在那里，最多可以听音乐，但什么也不能想，什么也不能做，也不要乱动，可以坐在椅子上。这是我每天日常的训练，我训练完之后，感觉专注力、自制力、执行力、精力都会得到很大的提升。每当我失控的时候，我就会去静坐。</p><p data-pid=\"txqfowFX\">人的大脑是很贱的，如果你失去了对大脑和身体的掌控力，他就会认为你是懦弱的，好欺负的，你就会慢慢被潜意识掌控，被欲望被诱惑，被外界的信息所控制，这些所有的所有都在争夺你的大脑和身体的掌控权。而你就像一个。意识薄弱的人总是被各种东西分割，你的注意力轮流掌控你的大脑和身体。所以静坐将注意力集中在听觉上，听音乐，什么也不做，就会收回你的注意力。</p><p data-pid=\"e6uVT2Po\">你要先将注意力这种重要的资源和能力收回，你才能有掌控权。你的注意力将相当于你的兵权，你的权力，当你权力都没有了，你的身体和大脑怎么信服你呢？所以要将你被分散的注意力被切割成很多份的意识先收回，重新聚集成一个整体。不然你每天的状态就是先一个小时被某个过往的经历难过，下一个小时被某个网络对立舆论吸引，在下一个小时某种瘾控制不断陷入死循环里。</p><p data-pid=\"IZ1z_Fl2\">你的身体就像公共场合一样，谁想来就来，谁想走就走，这样你怎么控制自己呢？所以你只需要什么都不做，然后集中注意力在听觉。上收回你的注意力，你的那些想法、情绪也都会慢慢消散，他们自己随着时间的推移就会消亡，消亡的时间大概是半小时到一小时，然后你就获得了几个小时的身体和大脑的绝对控制权。</p><p data-pid=\"15yCYfuH\">因为每一个念头产生都需要时间，累积成一个强烈的念头，就好像一个种子慢慢成长，而注意力就是它们的养分。当你不断激活这个念头，这个念头就会越来越强烈，像种子一样长大。但当你不关注它，不用注意力教养他，他自己慢慢就枯萎灭亡了，所以什么都不做。收回注意力，本质就是让这些像种子一样的念头自己消亡。</p><p data-pid=\"2rpBAFCe\">当所有念头都彻底被清除，你的注意力被收回来，你的大脑重启之后，你就不会分心，不会在做一件事情时犹犹豫豫要和其他的念头争夺身体的掌控权，不然这些念头不消亡，你就需要。花费大量的精力和他们斗争，最后慢慢失去身体的掌控权。所以驯服你的身体很简单，即使什么也不做，对自己狠一点，静坐半小时到一小时，就能获得很强大的自控力了。</p><p data-pid=\"gU1Rp_2B\">静坐的时候一定要闭上眼睛，闭目养神就是这个道理。闭上眼睛，你的脑海里的想法就会减少，为你收回了眼睛的注意力，你收回了注意力，这一部分注意力就可以集中到你的意识上，也就是那个理性的声音上。因为大脑节省了摄入视觉信息的能量，拥有更多的能量去集中到意识上面，所以在一些需要意志力的情况，也就需要闭目，这也是我在创作的时候常用的一种方法。闭目创作，尽量减少大脑耗能，将更多能量运用到思考上面，这是最简单的变强的方法。</p><p data-pid=\"rpxT9ST2\">要记住，你脑海里很多想法都不是你自己的真实想法，而是外界强加于你的，是过去的。力带给你不是你的本心，而是你的心魔。所以你要驯服他们，杀死他们，你才会变得强大。不要想着与他们共存。一个连自己的身体和大脑都驯服不来的人是不可能强大的，也不能得到别人的尊重的，只会深陷在孱弱的沼泽里，一辈子在里面打转。</p><p data-pid=\"A-k6rc8j\">特别是专注力从小就不好，脑海里很多想法，容易内耗的。高敏性的人就更需要安静的环境，将事情变得简单，减少自己需要注意力的事情。因为你的注意力就相当于大脑的运行内存，别人运行内存高的，可以同时运行很多软件，但你运行内存是很低的，只能将你仅有的内存运用在重要的事情上。</p><p data-pid=\"iMvbr4wN\">不要让一些琐碎的想法和事情让你分心，怎么节省注意力，怎么节省能量，你就怎么来，因为你高明，所以容易被分散注意力，但又因为你高明，所以你对一件事物的感知能力很强。所以这就是优。是高敏，就是学着关闭更多的能量通道，避免没必要的能量损耗，学着怎么节省能量，收缩注意力。高敏的人一般也深入，因为他们的身体和大脑一样是存不住能量，这里的身弱不是代表他们身体不好，而是因为新陈代谢过快，身体存不住能量，很容易溢散出去，所以怎么吃都不胖，身体消瘦，一顿不吃就饿得慌。</p><p data-pid=\"sT8j6AjH\">他们高明体质本质就是因为新陈代谢太快导致，所以要学着如何节省自己的能量，就是高明者的策略。我现在基本就是这样的策略，工作一小时，然后静坐20分钟到半小时，中间不能让自己做多余浪费精力和注意力的事情，让自己能长时间保持专注力、精力和意志力，这样工作效率也会变高。因为静坐的时候精力得到了恢复，千万不要工作一会儿就去娱乐或者耍手机，因为那会消耗你的精力和注意力的同时，种下很多种子念头，你就会慢慢失控。</p><p data-pid=\"5oZf4P2T\">专注力差的人只能工作休息，工作休息，工作休息，不断循环，一整天都不能娱乐，除非完成了一天的工作，因为你的那点专注力是很难处理好休息和娱乐之间的关系的。高明者进入状态比一般人难，但是只要一进入状态，就能比平常人更专注，也能专注的更持久。所以不要轻易中断自己的状态。他们最好的生活状态是疯狂工作，然后达到阶段性目标，之后疯狂娱乐，然后又重新进入工作状态，这才是适合他们的。因为他们本质就是单前程的大脑，不能同时兼顾很多事情，懈怠是他们最大的敌人，他们惯性是很大的，要启动很难，所以你不能让自己走走停停，而是启动了就不要停下了。</p><p data-pid=\"ersE1Y_e\">一旦你形成动起来，就会在巨大的惯性下疯狂前进。评论区留下驯服自己，强大自己。你的内心会。越来越强大，反正我个人是这样的，一旦做某件事情进入状态了之后，一天除了睡觉基本都在想那件事情，可以一天做14个小时，一旦停下来就需要很长时间去记录状态了。</p>",
        "relationship": {
          "is_nothelp": false,
          "voting": 0,
          "is_thanked": false
        },
        "is_labeled": false,
        "id": "1989682798680880756",
        "voteup_count": 19,
        "thanks_count": 0,
        "excerpt": "当年天涯有一篇帖子，讲的是通过每日静坐训练（闭目收心、专注听觉）回收注意力，驯服杂念以提升自控力与专注力，并针对高敏体质人群给出节省能量、保持状态的具体策略。 天涯论坛：《驯服自己》以下是原文内容： 想要变强，第一步就是驯服自己。 如何驯服自己呢？很简单，就是每天抽出一段时间什么都不做，就是坐在那里，最多可以听音乐，但什么也不能想，什么也不能做，也不要乱动，可以坐在椅子上。这是我每天日常的训练，我…",
        "excerpt_new": "当年天涯有一篇帖子，讲的是通过每日静坐训练（闭目收心、专注听觉）回收注意力，驯服杂念以提升自控力与专注力，并针对高敏体质人群给出节省能量、保持状态的具体策略。 天涯论坛：《驯服自己》以下是原文内容： 想要变强，第一步就是驯服自己。 如何驯服自己呢？很简单，就是每天抽出一段时间什么都不做，就是坐在那里，最多可以听音乐，但什么也不能想，什么也不能做，也不要乱动，可以坐在椅子上。这是我每天日常的训练，我…",
        "is_navigator": false,
        "vote_next_step": "vote",
        "author": {
          "is_following": false,
          "is_followed": false,
          "id": "49b5f21bf749580b7c2b07ca56a06e11",
          "user_type": "people",
          "url_token": "he-lai-ren-jian-liang-hong-ke",
          "headline": "",
          "avatar_url": "https://picx.zhimg.com/50/v2-fe63ddab1c4094b0b6c4ca2b51d23ff9_l.jpg?source=b6762063",
          "is_org": false,
          "url": "https://api.zhihu.com/people/49b5f21bf749580b7c2b07ca56a06e11",
          "name": "何来人间惊鸿客",
          "gender": -1,
          "followers_count": 1227
        },
        "created_time": 1767157345,
        "question": {
          "created": 1731071590,
          "comment_count": 10,
          "is_following": false,
          "excerpt": "",
          "question_type": "normal",
          "url": "https://api.zhihu.com/questions/3585508713",
          "author": {
            "headline": "心有山水不造作\n静而不争远是非",
            "avatar_url": "https://pic1.zhimg.com/50/v2-b68bc9ba3037115e1cb8fc8c932d0d0f_l.jpg?source=b6762063",
            "gender": 1,
            "badge": [
              {
                "type": "identity_people",
                "description": "贸易批发行业 经营者"
              }
            ],
            "is_followed": false,
            "is_following": false,
            "id": "4abe946cd9dd3b106d594a5f1fd03e41",
            "url": "https://api.zhihu.com/people/4abe946cd9dd3b106d594a5f1fd03e41",
            "user_type": "people",
            "url_token": "yang-xian-sen-94-57",
            "name": "子宜老师",
            "is_org": false,
            "followers_count": 7487
          },
          "answer_count": 0,
          "bound_topic_ids": [
            307,
            1575,
            2566,
            7129,
            19907
          ],
          "relationship": {
            "is_author": false
          },
          "id": "3585508713",
          "title": "大家提升自己最快的方式是什么？",
          "follower_count": 0,
          "type": "question",
          "detail": ""
        },
        "answer_type": "normal"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1989682798680880756}",
      "attached_info": "CtAFCO/Ln9uNj/b0nQEQBBoJNzYzNDQzODQyIOHc0soGKBMwAECPAUonChxUU19TT1VSQ0VfQ09OQ0VQVF9XT1JEX01FUkdFEgEwGAAgADoAWgkxMTE2OTM4NjRiIGVhZWE1NDA2NmM4MTlhNmE3OWI5ZmNiZTFkOTIyMzM0chMxOTg5NjgyNzk4NjgwODgwNzU2igEKMzU4NTUwODcxM6oBCXJlY29tbWVuZMIBIDQ5YjVmMjFiZjc0OTU4MGI3YzJiMDdjYTU2YTA2ZTEx8gEKCAwSBk5vcm1hbPIBKAgKEiRkNDQxMTMyZC1iZjA3LTRkNGItOGUxYi0xYTg5MGUxODgzMzLyAQYICxICMjSCAgCIAvLJ4pu5M5ICIDQ5YjVmMjFiZjc0OTU4MGI3YzJiMDdjYTU2YTA2ZTExmgIAygIURmlyc3RCcnVzaFdlaWdodFJ1bGXKAhZTaG9ySW50ZXJlc3RXZWlnaHRSdWxlygIcQmF5ZXNGaXJzdExldmVsSXNvbGF0aW9uUnVsZdoCHFRTX1NPVVJDRV9DT05DRVBUX1dPUkRfTUVSR0XoAgP6AgtOT1JNQUxfRkxPV4oDIGVjY2ExMWI2YWU4ZTRkOTY4MWEwZmNiYzQ5MzM4N2U1mgMNCgJ2MhAAGgVvdGhlcqgDhQPYAwDqAyFDb25jZXB0V29yZE1lcmdlTmV3VjFQb29sUmVjYWxsZXL6Ax8SDFVOS05PV05fTU9ERSAAKg1OT19JTUFHRV9NT0RFgAQAiAQAkgQGTm9ybWFsmgQBM6AEAKgEALAEALoEAmFpwgQDNDAwyAQA0gQP5o6o6I2Q5bey5pu05paw2AQA8AQA+QQAAACAZwqQP4EFAAAAAAAAAACJBUICbd62jLI/kgUAmgUDZGZ0ogUDZGZ0sgUBMbkFAAAAAAAAAADQBQDgBQDoBQDwBRiQBgCgBpABqAYAkgIuCgk3NjM0NDM4NDISEzE5ODk2ODI3OTg2ODA4ODA3NTYYBCIKSU1BR0VfVEVYVA==",
      "action_card": false
    }
  ],
  "paging": {
    "is_end": false,
    "is_start": false,
    "next": "https://www.zhihu.com/api/v3/feed/topstory/recommend?action=down&ad_interval=-10&after_id=143&desktop=true&end_offset=144&page_number=25&session_token=eaea54066c819a6a79b9fcbe1d922334",
    "previous": "https://www.zhihu.com/api/v3/feed/topstory/recommend?action=pull&ad_interval=-10&before_id=143&desktop=true&end_offset=144&page_number=25&session_token=eaea54066c819a6a79b9fcbe1d922334",
    "totals": 0
  },
  "fresh_text": "推荐已更新"
}