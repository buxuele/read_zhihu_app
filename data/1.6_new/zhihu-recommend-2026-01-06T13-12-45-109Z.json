{
  "data": [
    {
      "id": "48_1767705225.110",
      "type": "feed",
      "offset": 48,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705225,
      "updated_time": 1767705225,
      "target": {
        "is_copyable": false,
        "excerpt": "趁着伙计韩道国出门，西门庆带着秘密武器包来到韩家，和他老婆王六儿玩耍到晚上十点。韩道国回来后，王六儿告诉他： 你走后，西门庆来了三四次，还花钱给我们买了个丫头，每次来还给我几两银子。而且他看我们住在这里不方便过来，还许诺要在大街上给我们买一套大房子呢。   若是一般夫妻，妻子和主人勾搭上，是不敢叫丈夫知道的。而丈夫若是知道，必定也要暴跳如雷的，这一点可以参考宋惠莲的丈夫来旺儿。 可韩道国夫妇的做法完全…",
        "allow_segment_interaction": true,
        "url": "https://api.zhihu.com/answers/1991228829499410382",
        "preview_text": "",
        "relationship": {
          "is_thanked": false,
          "is_nothelp": false,
          "voting": 0
        },
        "navigator_vote": false,
        "vote_next_step": "vote",
        "author": {
          "is_org": false,
          "gender": 1,
          "is_following": false,
          "is_followed": false,
          "url": "https://api.zhihu.com/people/8b66e3955736e7b598ba67f00acd7e60",
          "user_type": "people",
          "avatar_url": "https://picx.zhimg.com/50/v2-d03409e8fbec2e47101e01ebbd6f4f0e_l.jpg?source=b6762063",
          "headline": "等春风得意，等时间嘉许。",
          "followers_count": 2206,
          "id": "8b66e3955736e7b598ba67f00acd7e60",
          "url_token": "b-3-91-80-20",
          "name": "京墨"
        },
        "created_time": 1767525948,
        "excerpt_new": "趁着伙计韩道国出门，西门庆带着秘密武器包来到韩家，和他老婆王六儿玩耍到晚上十点。韩道国回来后，王六儿告诉他： 你走后，西门庆来了三四次，还花钱给我们买了个丫头，每次来还给我几两银子。而且他看我们住在这里不方便过来，还许诺要在大街上给我们买一套大房子呢。   若是一般夫妻，妻子和主人勾搭上，是不敢叫丈夫知道的。而丈夫若是知道，必定也要暴跳如雷的，这一点可以参考宋惠莲的丈夫来旺儿。 可韩道国夫妇的做法完全…",
        "preview_type": "default",
        "reshipment_settings": "disallowed",
        "id": "1991228829499410382",
        "thanks_count": 2,
        "answer_type": "normal",
        "type": "answer",
        "visited_count": 2026,
        "favorite_count": 12,
        "voteup_count": 18,
        "comment_count": 2,
        "updated_time": 1767525948,
        "question": {
          "id": "658123154",
          "title": "金瓶梅讲了什么，哪里可以看到?",
          "question_type": "normal",
          "url": "https://api.zhihu.com/questions/658123154",
          "created": 1717553502,
          "answer_count": 0,
          "is_following": false,
          "detail": "",
          "author": {
            "id": "df534b6611e2c5699b5c6673e83252c1",
            "url": "https://api.zhihu.com/people/df534b6611e2c5699b5c6673e83252c1",
            "headline": "",
            "avatar_url": "https://pica.zhimg.com/50/v2-dd1498f6e3552ba9ac89dbb0c0ce04e4_l.jpg?source=b6762063",
            "is_org": false,
            "is_followed": false,
            "user_type": "people",
            "url_token": "zhi-hu-yong-hu-93408-28",
            "name": "玛丽·沃斯通克拉",
            "gender": -1,
            "followers_count": 110,
            "is_following": false
          },
          "follower_count": 0,
          "comment_count": 0,
          "excerpt": "",
          "type": "question",
          "bound_topic_ids": [
            4211,
            10400,
            25193,
            158356
          ],
          "relationship": {
            "is_author": false
          }
        },
        "content": "<p data-pid=\"HcMQseeo\">趁着伙计韩道国出门，西门庆带着秘密武器包来到韩家，和他老婆王六儿玩耍到晚上十点。韩道国回来后，王六儿告诉他：</p><p data-pid=\"L-PwMR0m\">你走后，西门庆来了三四次，还花钱给我们买了个丫头，每次来还给我几两银子。而且他看我们住在这里不方便过来，还许诺要在大街上给我们买一套大房子呢。</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-1efc6062326dc766ed1dcf0dbeeac249_1440w.jpg\" data-rawwidth=\"1020\" data-rawheight=\"1199\" data-size=\"normal\" data-original-token=\"v2-e19d968014aff94798e2790900aa866f\" class=\"origin_image zh-lightbox-thumb\" width=\"1020\" data-original=\"https://pic2.zhimg.com/v2-1efc6062326dc766ed1dcf0dbeeac249_r.jpg\"/></figure><p data-pid=\"3h6F3zcP\">若是一般夫妻，妻子和主人勾搭上，是不敢叫丈夫知道的。而丈夫若是知道，必定也要暴跳如雷的，这一点可以参考宋惠莲的丈夫来旺儿。</p><p data-pid=\"cpsD-u7U\">可韩道国夫妇的做法完全出乎我们的意料。</p><p data-pid=\"aUEPGDUK\">其一是王六儿毫不避讳将和西门庆的奸情和盘托出。</p><p data-pid=\"_F1PZ3Nr\">其二是韩道国听到后淡定自若、受宠若惊的反应。韩道国听了老婆的坦诚后，赶忙说道：</p><p data-pid=\"qirHfoka\">“等我明日往铺子里去了，他若来时，你只推我不知道，休要怠慢了他，凡事奉承他些儿。如今好容易赚钱，怎么赶的这个道路！”</p><p data-pid=\"6AeyBZVW\">主动给西门庆让路，还装傻充愣，让老婆好生伺候西门庆。只因为好不容易这么个发财的路子，别人想挣还挣不到呢。</p><p data-pid=\"A-o9gW9M\">一片大草原顶得心甘情愿，欢天喜地。</p><p data-pid=\"cMlPfFTI\">而王六儿到这番言语后，更是笑着说道：</p><p data-pid=\"ZyZzFXM0\">“贼强人，倒路死的！你到会吃自在饭儿，你还不知老娘怎样受苦哩！”</p><p data-pid=\"s8-gd-xt\">说完两人笑了一阵，王六儿做好了饭菜为韩道国接风，夫妇俩照常美美地睡上了一觉。</p><p data-pid=\"n1fFnYYD\">很多人看到这一幕都要被震碎三观，怎么会有这样一对夫妇？丈夫知道妻子和他人通奸，竟然像看到妻子找到一份高薪工作一般庆幸欢喜，还给对方打气。而妻子说起伺候西门庆的种种难耐时，亦是可以用幽默的语气跟丈夫谈论。就真的像在谈一份工作似的。</p><p data-pid=\"BSZTuaGi\">以前每每看到这一段都对此嗤之以鼻，但后来再看，似乎看到了《金瓶梅》中不一样的东西。</p><p data-pid=\"0i641mtf\">《金瓶梅》里有很多家庭，但这些家庭很没有人味，要么妻妾不和，要么要么夫妻貌合神离，夫妻猜忌防范，夫妇各自有奸情谋算……独独韩道国和王六儿这一对，真的在齐心协力建设自己的小家。</p><p data-pid=\"oBi7fg9E\">和西门庆通奸的女人很多，但那些女人要么谋爱，比如潘金莲、李瓶儿；要么谋名分，譬如宋惠莲；要么谋私欲，比如林太太……</p><p data-pid=\"JRzrwZDU\">而纯粹谋钱财为小家庭的，只有王六儿。</p><p data-pid=\"eCLJsF4l\">因为目的特别单纯，所以王六儿真的将伺候西门庆当成一份工作在做，所以我们才能看到，西门庆和这么多女人玩耍，玩得最大的是王六儿，通过文字我们都能感觉到那种难受和痛苦。但王六儿都咬牙忍了，还在工作时保持笑脸，情绪价值给到满分。</p><p data-pid=\"30Uc_KRq\">”你还不知老娘怎样受苦哩！“说出了王六儿和西门庆在一块时的无奈和隐忍。</p><p data-pid=\"qP4cci_L\">而难得的是，两人面对这件事时竟然能够用调侃的语气，说明这对夫妇对彼此是信任和理解的，他们有共同的心愿，而这种同心同德，在其他夫妇身上你根本看不到。</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-e1ebb7891039d27fd396559fdb1e2fa5_1440w.jpg\" data-rawwidth=\"1015\" data-rawheight=\"1196\" data-size=\"normal\" data-original-token=\"v2-380cc60906c66e63b70872d3bcbcbb76\" class=\"origin_image zh-lightbox-thumb\" width=\"1015\" data-original=\"https://pic2.zhimg.com/v2-e1ebb7891039d27fd396559fdb1e2fa5_r.jpg\"/></figure><p data-pid=\"Pvpv9i8z\">当然，很多人是无法接受这样的同心同德，但是作者不一样，他有一颗悲悯的心。</p><p data-pid=\"e2sqcevV\">试想那样一个社会，世风日下，道德沦丧，官商勾结，也就西门庆这样的人才能春风得意一路高歌，普通老百姓根本无法冲出那一层黑雾，一世只能受苦受穷。这样的环境下，为了生存甩掉道德的约束，实在没有什么可指责的。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-9a9741a666f78debd3bfe7e4d95093f6_1440w.jpg\" data-rawwidth=\"976\" data-rawheight=\"1474\" data-size=\"normal\" data-original-token=\"v2-f99307ed4ff48d15fc0e9181d82f58db\" class=\"origin_image zh-lightbox-thumb\" width=\"976\" data-original=\"https://pic1.zhimg.com/v2-9a9741a666f78debd3bfe7e4d95093f6_r.jpg\"/></figure><p data-pid=\"d9SMbmXQ\">何况，纵观全书，王六儿和韩道国也没有做什么伤天害理的事，最多就是西门庆去世的时候，王六儿撺掇韩道国吞掉西门庆的一千两货银罢了，那还是因为王六儿去西门庆灵前祭拜被吴月娘苛待，恼怒之下才决定的。</p><p data-pid=\"omZQqdg6\">因此，这本书里，王六儿的结局是难得的圆满，最后不仅有了钱财，还在韩道国死后，和小叔子韩二过上了平静的日子，较之潘金莲、孙雪娥、庞春梅等人，不可谓不幸运。这正是作者的悲悯之处。</p>",
        "is_labeled": false,
        "thumbnail": "https://pica.zhimg.com/50/v2-e19d968014aff94798e2790900aa866f_720w.jpg?source=b6762063",
        "thumbnails": [
          "https://picx.zhimg.com/50/v2-e19d968014aff94798e2790900aa866f_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-380cc60906c66e63b70872d3bcbcbb76_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-f99307ed4ff48d15fc0e9181d82f58db_720w.jpg?source=b6762063"
        ],
        "is_navigator": false
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1991228829499410382}",
      "attached_info": "CvYGCICBzNa/lZS0qgEQBBoJNzYzOTkxMDcwILyc6coGKBIwAkAwSigKE1RTX1NPVVJDRV9GRUVEUkVfVjUSATAYACAAOgp7InJhdyI6IiJ9SisKFlRTX1NPVVJDRV9GRUVEUkVfTVNfVjMSATAYACAAOgp7InJhdyI6IiJ9WgkxMDg1Mjc1NjBiIGE0ZTkwYzU3OTg3MTU2YmE5MWIwMjVhOTMxYWNlMTA4chMxOTkxMjI4ODI5NDk5NDEwMzgyigEJNjU4MTIzMTU0qgEJcmVjb21tZW5kwgEgOGI2NmUzOTU1NzM2ZTdiNTk4YmE2N2YwMGFjZDdlNjDyAQoIDBIGTm9ybWFs8gEoCAoSJDM3M2Q5MjNlLWY0ZTItNDA2Mi04ZjVkLTZlZTdiNzkyMDViOPIBBQgLEgE5ggIAiALM0sSbuTOSAiA4YjY2ZTM5NTU3MzZlN2I1OThiYTY3ZjAwYWNkN2U2MJoCAMoCFEZpcnN0QnJ1c2hXZWlnaHRSdWxlygIWU2hvckludGVyZXN0V2VpZ2h0UnVsZcoCG0ludGVyYWN0aW9uU2hvckludGVyZXN0UnVsZdoCE1RTX1NPVVJDRV9GRUVEUkVfVjXoAgP6AgtOT1JNQUxfRkxPV4oDIDNkZjJiZDgyZDRhMDQzYWVhZGFjMGQ5MDE0ZTU0MzQ2mgMNCgJ2MhAAGgVvdGhlcqgD6g/YAwDqAxlmZWVkcmVXYXJtU3VjY2Vzc1JlY2FsbGVy+gOsARIMVU5LTk9XTl9NT0RFIAAqDU5PX0lNQUdFX01PREU6LQgCEPwHGK8JIiN2Mi1lMTlkOTY4MDE0YWZmOTQ3OThlMjc5MDkwMGFhODY2ZjotCAMQ9wcYrAkiI3YyLTM4MGNjNjA5MDZjNjZlNjNiNzA4NzJkM2JjYmNiYjc2Oi0IAxDQBxjCCyIjdjItZjk5MzA3ZWQ0ZmY0OGQxNWZjMGU5MTgxZDgyZjU4ZGKABACIBACSBAZOb3JtYWyaBAEzoAQAqAQAsAQAugQCYWnCBAM0MDDIBADSBA/mjqjojZDlt7Lmm7TmlrDYBADwBAD5BAAAAGDcHqQ/gQUAAAAAAAAAAIkFGSivE5G4sT+SBQCaBQNkZnSiBQNkZnSyBQExuQUAAAAAAAAAANAFAOAFAOgFAPAFCZAGAKAGMKgGAZICLgoJNzYzOTkxMDcwEhMxOTkxMjI4ODI5NDk5NDEwMzgyGAQiCklNQUdFX1RFWFQ=",
      "action_card": false
    },
    {
      "id": "49_1767705225.136",
      "type": "feed",
      "offset": 49,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705225,
      "updated_time": 1767705225,
      "target": {
        "type": "answer",
        "excerpt_new": "日常工作中，用nginx巧妙的解决过几个问题的场景。 通过模块做服务兼容实际场景中，有一套老的客户端程序和一套服务端数据接口不兼容，甚至特殊情况下会导致服务端崩溃。在部署的时候既不想更新客户端程序，又推动不了兄弟部门解决接口兼容问题。 使用headers-more-nginx-module模块，把客户端请求的header改写了一下，甚至于重造了一个老的接口，全都是通过nginx配置文件做到的，一行代码没写，这是最廉价的方案。 数据库访问代…",
        "author": {
          "url_token": "fengxiaochuang",
          "name": "冯晓闯",
          "avatar_url": "https://pic1.zhimg.com/50/2acb39278_l.jpg?source=b6762063",
          "is_following": false,
          "is_followed": false,
          "url": "https://api.zhihu.com/people/dda94d748b264dea89087b6361576671",
          "user_type": "people",
          "headline": "大多数中的少数人,少数人中的大多数",
          "is_org": false,
          "gender": 1,
          "followers_count": 92,
          "id": "dda94d748b264dea89087b6361576671"
        },
        "voteup_count": 227,
        "is_labeled": false,
        "navigator_vote": false,
        "preview_type": "default",
        "relationship": {
          "voting": 0,
          "is_thanked": false,
          "is_nothelp": false
        },
        "vote_next_step": "vote",
        "allow_segment_interaction": true,
        "created_time": 1642118821,
        "thanks_count": 55,
        "preview_text": "",
        "answer_type": "normal",
        "comment_count": 10,
        "is_copyable": false,
        "question": {
          "author": {
            "id": "fdb0e7aa4525b21999234f97debfd8d2",
            "url": "https://api.zhihu.com/people/fdb0e7aa4525b21999234f97debfd8d2",
            "name": "果子狸",
            "headline": "码农",
            "avatar_url": "https://pic1.zhimg.com/50/411e5195d_l.jpg?source=b6762063",
            "gender": 1,
            "is_followed": false,
            "user_type": "people",
            "url_token": "shang-jin-13",
            "is_org": false,
            "followers_count": 47,
            "is_following": false
          },
          "answer_count": 0,
          "bound_topic_ids": [
            1355,
            1452,
            2084,
            7563,
            7946
          ],
          "excerpt": "",
          "detail": "",
          "id": "21483073",
          "created": 1376543434,
          "relationship": {
            "is_author": false
          },
          "url": "https://api.zhihu.com/questions/21483073",
          "follower_count": 0,
          "question_type": "normal",
          "type": "question",
          "title": "Nginx 能做什么好玩的事情？",
          "comment_count": 1,
          "is_following": true
        },
        "excerpt": "日常工作中，用nginx巧妙的解决过几个问题的场景。 通过模块做服务兼容实际场景中，有一套老的客户端程序和一套服务端数据接口不兼容，甚至特殊情况下会导致服务端崩溃。在部署的时候既不想更新客户端程序，又推动不了兄弟部门解决接口兼容问题。 使用headers-more-nginx-module模块，把客户端请求的header改写了一下，甚至于重造了一个老的接口，全都是通过nginx配置文件做到的，一行代码没写，这是最廉价的方案。 数据库访问代…",
        "content": "<p data-pid=\"UTnSskC3\">日常工作中，用nginx巧妙的解决过几个问题的场景。</p><h3>通过模块做服务兼容</h3><p data-pid=\"7VIiKS7f\">实际场景中，有一套老的客户端程序和一套服务端数据接口不兼容，甚至特殊情况下会导致服务端崩溃。在部署的时候既不想更新客户端程序，又推动不了兄弟部门解决接口兼容问题。</p><p data-pid=\"fby4cNop\">使用headers-more-nginx-module模块，把客户端请求的header改写了一下，甚至于重造了一个老的接口，全都是通过nginx配置文件做到的，一行代码没写，这是最廉价的方案。</p><h3>数据库访问代理</h3><p data-pid=\"480gSIXq\">使用stream进行映射内网mysql访问权限。</p><p data-pid=\"H8Y4dZBo\">生产环境不要乱映射！！！</p><h3>https转http</h3><p data-pid=\"iHd8fKHf\">兄弟部门的gitlab是自签名的https的地址，我们的jenkins又不太好调参数，所以用nginx可以把https映射成http，跳过git clone时候提示的ssl verify问题。</p><h3>开发环境用负载切换开发机调试</h3><p data-pid=\"tkAjAHGt\">我们有开发服务器，又有个人主机的开发调试。有的时候需要跟前端打断点联调。搞了一套开发环境的域名，前端在开发的时候可以代理到这个域名下。</p><p data-pid=\"4tMXhSBd\">如果需要某个人调试自己的服务的时候，通过nginx负载切换到开发服务器或者个人主机上，这样就不用每次让前端一直切不同的环境配置，配合nginxWebUI使用更佳。</p><h3>增强web网站</h3><p data-pid=\"NYMe_TI6\">公司有个极其难用的日报系统，平时我都会在上面写一些增强的css/js优化使用体验。后来把这些优化的资源搬到服务器上也供其他同事用。</p><p data-pid=\"x06OEld8\">通过代理原来的web网站，又通过nginx覆盖路由重写了几个静态资源文件和接口。</p>",
        "favorite_count": 478,
        "is_navigator": false,
        "id": "2309911663",
        "url": "https://api.zhihu.com/answers/2309911663",
        "updated_time": 1642118821,
        "reshipment_settings": "disallowed",
        "reaction_instruction": {
          "REACTION_CONTENT_SEGMENT_LIKE": "HIDE"
        },
        "visited_count": 39917
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 2309911663}",
      "attached_info": "CtsFCICBzNa/lZS0qgEQBBoJNDUwMDY1NjQ1IKX9go8GKOMBMApAMUowCiBUU19TT1VSQ0VfRk9MTE9XX1FVRVNUSU9OX0FOU1dFUhIGNzczOTE1GAAgADoAWgY3NzM5MTViIGE0ZTkwYzU3OTg3MTU2YmE5MWIwMjVhOTMxYWNlMTA4cgoyMzA5OTExNjYzigEIMjE0ODMwNzOqAQlyZWNvbW1lbmTCASBkZGE5NGQ3NDhiMjY0ZGVhODkwODdiNjM2MTU3NjY3MfIBCggMEgZOb3JtYWzyASgIChIkMThkZTE4NGItNzZlZi00ZTYwLTg3ZDYtY2MzNGExNWMxYWMw8gEFCAsSATmCAgCIAs3SxJu5M5ICIGRkYTk0ZDc0OGIyNjRkZWE4OTA4N2I2MzYxNTc2NjcxmgIAygIURmlyc3RCcnVzaFdlaWdodFJ1bGXKAhZTaG9ySW50ZXJlc3RXZWlnaHRSdWxlygIbSW50ZXJhY3Rpb25TaG9ySW50ZXJlc3RSdWxlygIUQ29udGVudEFnZVdlaWdodFJ1bGXaAiBUU19TT1VSQ0VfRk9MTE9XX1FVRVNUSU9OX0FOU1dFUugCAvoCC05PUk1BTF9GTE9XigMgM2RmMmJkODJkNGEwNDNhZWFkYWMwZDkwMTRlNTQzNDaaAw0KAnYyEAAaBW90aGVyqAPttwLYAwDqAxhmb2xsb3ctcXVlc3Rpb24tcmVjYWxsZXL6Ax8SDFVOS05PV05fTU9ERSAAKg1OT19JTUFHRV9NT0RFgAQAiAQAkgQGTm9ybWFsmgQBMqAEAKgEALAEALoEAmFpwgQDNDAwyAQA0gQP5o6o6I2Q5bey5pu05paw2AQA8AQA+QQAAADgodqSP4EFAAAAAAAAAACJBRkorxORuLE/kgUAmgUDZGZ0ogUDZGZ0sgUBMbkFAAAAAAAAAADQBQDgBQDoBQDwBQmQBgCgBjGoBgOSAiUKCTQ1MDA2NTY0NRIKMjMwOTkxMTY2MxgEIgpJTUFHRV9URVhU",
      "action_card": false
    },
    {
      "id": "50_1767705225.312",
      "type": "feed",
      "offset": 50,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705225,
      "updated_time": 1767705225,
      "target": {
        "author": {
          "headline": "关注我，看更多神人",
          "followers_count": 364,
          "is_followed": false,
          "id": "3b2e695c537a7387fcd6864d22f78220",
          "url": "https://api.zhihu.com/people/3b2e695c537a7387fcd6864d22f78220",
          "user_type": "people",
          "url_token": "ai-wai-bo-de-shu-shu",
          "is_following": false,
          "name": "肯德基松软企鹅",
          "avatar_url": "https://pic1.zhimg.com/50/v2-8ae67269f0b28e6a31d0a10f4e3f1052_l.jpg?source=b6762063",
          "is_org": false,
          "gender": -1
        },
        "created_time": 1767498528,
        "thanks_count": 2,
        "allow_segment_interaction": true,
        "is_copyable": false,
        "excerpt": "低情商：鲥鱼多刺而味鲜，伯乐少有而识材。鲜鱼骏马，不是都得靠领导赏识嘛。领导，鱼刺虽多，若是烹饪有方也可成一道佳肴。就像我们团队里的大家，虽然来自天南海北，工作时小有摩擦，但在您的带领下，我们这刺多的鱼也能同心同力，心往一处使。领导，啥也不说了，我敬您一杯！   中情商：领导是好领导，就是话多。领导您人是好人，就是事多。咱们公司是好公司，就是傻逼领导太多，工资……（不语，捂嘴笑）   高情商：这得看给谁吃…",
        "preview_type": "default",
        "type": "answer",
        "navigator_vote": false,
        "vote_next_step": "vote",
        "url": "https://api.zhihu.com/answers/1991113821977346967",
        "updated_time": 1767500652,
        "question": {
          "type": "question",
          "url": "https://api.zhihu.com/questions/1989998006259446255",
          "bound_topic_ids": [
            17130,
            39779
          ],
          "excerpt": "",
          "question_type": "normal",
          "created": 1767232497,
          "comment_count": 1,
          "answer_count": 0,
          "follower_count": 0,
          "id": "1989998006259446255",
          "author": {
            "followers_count": 303,
            "is_following": false,
            "is_followed": false,
            "url_token": "46-26-72-32-44",
            "is_org": false,
            "gender": 1,
            "name": "逆风",
            "headline": "越是熬不住的时候，越需要坚持！❤️",
            "avatar_url": "https://picx.zhimg.com/50/v2-281d3e1d41bde376eb8d9e894704c1f9_l.jpg?source=b6762063",
            "id": "0716b2445bb6239fb52a6ebe4269108a",
            "url": "https://api.zhihu.com/people/0716b2445bb6239fb52a6ebe4269108a",
            "user_type": "people"
          },
          "title": "昨天吃年夜饭，领导指着端上来的鱼说:“鱼是好鱼，就是刺多。”这个我该怎么接啊？",
          "is_following": false,
          "relationship": {
            "is_author": false
          },
          "detail": ""
        },
        "relationship": {
          "is_thanked": false,
          "is_nothelp": false,
          "voting": 0
        },
        "is_labeled": true,
        "visited_count": 2291,
        "is_navigator": false,
        "id": "1991113821977346967",
        "comment_count": 5,
        "preview_text": "",
        "thumbnails": [
          "https://pica.zhimg.com/50/v2-f5e30a857841b835db478836114c9ecd_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-5af687edb6d1e6425e58e2cd16aaa3cf_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-fa1fdba1f69220fca2d1e3840c86881a_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-58b4f40378c48c797716cb66bdb5ab51_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-3e1588a3e4ff3e99e3db5663b253d9b5_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-ce47ca06af7b286e3e0a610aeb0c297a_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-e01453a4f7b067b717af9d5fde06bd3d_720w.jpg?source=b6762063",
          "https://pic1.zhimg.com/50/v2-a3bcc2f21ad01af83779abbd13ce8e37_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-d3bef522c377117aaeda22241a661480_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-3b8dd9ec8a7d42d9e7aecbc28f8b5d9a_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-cfe55e1df05900b0b42030bfc78ac071_720w.jpg?source=b6762063"
        ],
        "voteup_count": 42,
        "thumbnail": "https://picx.zhimg.com/50/v2-f5e30a857841b835db478836114c9ecd_720w.jpg?source=b6762063",
        "excerpt_new": "低情商：鲥鱼多刺而味鲜，伯乐少有而识材。鲜鱼骏马，不是都得靠领导赏识嘛。领导，鱼刺虽多，若是烹饪有方也可成一道佳肴。就像我们团队里的大家，虽然来自天南海北，工作时小有摩擦，但在您的带领下，我们这刺多的鱼也能同心同力，心往一处使。领导，啥也不说了，我敬您一杯！   中情商：领导是好领导，就是话多。领导您人是好人，就是事多。咱们公司是好公司，就是傻逼领导太多，工资……（不语，捂嘴笑）   高情商：这得看给谁吃…",
        "reshipment_settings": "disallowed",
        "content": "<p data-pid=\"29PGio8A\"><b>低情商</b>：鲥鱼多刺而味鲜，伯乐少有而识材。鲜鱼骏马，不是都得靠领导赏识嘛。领导，鱼刺虽多，若是烹饪有方也可成一道佳肴。就像我们团队里的大家，虽然来自天南海北，工作时小有摩擦，但在您的带领下，我们这刺多的鱼也能同心同力，心往一处使。领导，啥也不说了，我敬您一杯！</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-c59634623691491457ccea59fd7cf3dc_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1348\" data-size=\"normal\" data-original-token=\"v2-f5e30a857841b835db478836114c9ecd\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pica.zhimg.com/v2-c59634623691491457ccea59fd7cf3dc_r.jpg\"/></figure><p data-pid=\"vofR4Ub0\"><b>中情商</b>：领导是好领导，就是话多。领导您人是好人，就是事多。咱们公司是好公司，就是傻逼领导太多，工资……（不语，捂嘴笑）</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-91be4e7f84a70a4ce008a6c53c972214_1440w.jpg\" data-rawwidth=\"464\" data-rawheight=\"504\" data-size=\"normal\" data-original-token=\"v2-eac23ff93872adfb9fddb767cf9c3769\" class=\"origin_image zh-lightbox-thumb\" width=\"464\" data-original=\"https://pica.zhimg.com/v2-91be4e7f84a70a4ce008a6c53c972214_r.jpg\"/></figure><p data-pid=\"yz-6bqWr\"><b>高情商</b>：这得看给谁吃。鱼给猫吃，猫觉得好吃。给狗吃吧，狗就嫌刺多。领导，我怎么没吃到刺呢，是不是您太会挑刺了？</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-2cc382958c43718fff28f964d88ccbe7_1440w.jpg\" data-rawwidth=\"1052\" data-rawheight=\"1064\" data-size=\"normal\" data-original-token=\"v2-5af687edb6d1e6425e58e2cd16aaa3cf\" class=\"origin_image zh-lightbox-thumb\" width=\"1052\" data-original=\"https://picx.zhimg.com/v2-2cc382958c43718fff28f964d88ccbe7_r.jpg\"/></figure><p data-pid=\"fEids07D\"><b>超高情商</b>：</p><p data-pid=\"EhZ8y6W6\">站在桌子上不说话，打一管没刺的交给领导补充补充优质蛋白质</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-206d593aab96644ea214dcb2b09b451d_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1704\" data-size=\"normal\" data-original-token=\"v2-fa1fdba1f69220fca2d1e3840c86881a\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-206d593aab96644ea214dcb2b09b451d_r.jpg\"/></figure><p data-pid=\"QFjs2W7_\"><b>雌小鬼版：</b>杂鱼♥～杂鱼♥～哦哦哦齁齁齁～</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-c3b9bbd1c0f14a26987340dd3fcf3407_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1080\" data-size=\"normal\" data-original-token=\"v2-58b4f40378c48c797716cb66bdb5ab51\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-c3b9bbd1c0f14a26987340dd3fcf3407_r.jpg\"/></figure><p data-pid=\"2jwzYZiJ\"><b>骨气版</b>：鱼尚有刺，人岂能无骨？</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-bbce38b46f4f0bae516cc7f5bdfd2d1a_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"602\" data-size=\"normal\" data-original-token=\"v2-28a84e57e2eed952a038902f691388cf\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-bbce38b46f4f0bae516cc7f5bdfd2d1a_r.jpg\"/></figure><p data-pid=\"NffHk3H5\"><b>窝囊版</b>：一声不吭偷偷掉小珍珠，第二天吊死在领导办公室。</p><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-073ead3c77fc117c3a92a4b30d5fcc8f_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1440\" data-size=\"normal\" data-original-token=\"v2-3e1588a3e4ff3e99e3db5663b253d9b5\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://picx.zhimg.com/v2-073ead3c77fc117c3a92a4b30d5fcc8f_r.jpg\"/></figure><p data-pid=\"TF6Fo1FE\"><b>饕餮版</b>：趁着大家不敢动筷，低头猛猛干饭，把菜全炫完。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-9e6119ddca51e496a709dd898768f154_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1080\" data-size=\"normal\" data-original-token=\"v2-ce47ca06af7b286e3e0a610aeb0c297a\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-9e6119ddca51e496a709dd898768f154_r.jpg\"/></figure><p data-pid=\"i5fc1IUG\"><b>节约版</b>：领导，你不爱吃就别拔拉。服务员来个打包盒，这个菜打包。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-8e6b37785802e93f48c2e87383d3d9bc_1440w.jpg\" data-rawwidth=\"1260\" data-rawheight=\"1648\" data-size=\"normal\" data-original-token=\"v2-e01453a4f7b067b717af9d5fde06bd3d\" class=\"origin_image zh-lightbox-thumb\" width=\"1260\" data-original=\"https://pic1.zhimg.com/v2-8e6b37785802e93f48c2e87383d3d9bc_r.jpg\"/></figure><p data-pid=\"TtEEFyJJ\"><b>弱智吧逻辑学家版</b>：鱼越大刺越多，鱼刺多肉就少，肉越少鱼越小，鱼越小刺越少，所以刺越多，刺越少。</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-817f1b3ad5f8ad083162ace666587837_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1064\" data-size=\"normal\" data-original-token=\"v2-a3bcc2f21ad01af83779abbd13ce8e37\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-817f1b3ad5f8ad083162ace666587837_r.jpg\"/></figure><p data-pid=\"JV3jA_rt\"><b>古风小生版：</b>今日盛宴，肴馔丰美，诚为难得。余闻古人云：“肉以养人，骨以饲犬。”故特选一鱼，刺繁而味鲜，欲以此献于尊。愿吾尊能细细品味，勿使鲠喉，方不负余一片诚意。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-1a8c7c751ef06fc7dcbd9ae33cc5a59a_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1008\" data-size=\"normal\" data-original-token=\"v2-d3bef522c377117aaeda22241a661480\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-1a8c7c751ef06fc7dcbd9ae33cc5a59a_r.jpg\"/></figure><p data-pid=\"m_xsy-u1\"><b>升舱版</b>：换鱼的钱我来出。服务员，换条刺少的鱼。（一把抢过领导手机）（面部识别并为领导办理20W高利贷）</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-62c0f584da2b16f5d16824b3b0ecc5c8_1440w.jpg\" data-rawwidth=\"1036\" data-rawheight=\"784\" data-size=\"normal\" data-original-token=\"v2-3b8dd9ec8a7d42d9e7aecbc28f8b5d9a\" class=\"origin_image zh-lightbox-thumb\" width=\"1036\" data-original=\"https://pica.zhimg.com/v2-62c0f584da2b16f5d16824b3b0ecc5c8_r.jpg\"/></figure><p data-pid=\"qWhS9r4g\"><b>殡葬版：</b>还得是领导！吃饭就是讲究！有文化！不像我个无亲无故的泥腿子。领导啊，等我有钱了，一定去您小区买套房子多亲近亲近。哦对，您小孩是在xx幼儿园上学的对吧！您每天这么忙，我明天去帮您接接啊。领导，快过年了，可千万记得给父母打电话报个平安啊。</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-f8cbace9ec01db38091b2f135c8989de_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1444\" data-size=\"normal\" data-original-token=\"v2-cfe55e1df05900b0b42030bfc78ac071\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-f8cbace9ec01db38091b2f135c8989de_r.jpg\"/></figure><p data-pid=\"BA5M2f3P\"><b>知乎名菜版：</b>让服务员把鱼撤了，换成<b>西葫芦炖茄子，再加点肉，日一声打成糊糊。</b>领导觉得很好吃，<b>一口气吃了两大碗。</b></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-043f551970cfb5cebcdcb6acc8cb119e_1440w.jpg\" data-rawwidth=\"524\" data-rawheight=\"524\" data-size=\"normal\" data-original-token=\"v2-7cda5ba200782e7bd016437b8d672d2c\" class=\"origin_image zh-lightbox-thumb\" width=\"524\" data-original=\"https://pic1.zhimg.com/v2-043f551970cfb5cebcdcb6acc8cb119e_r.jpg\"/></figure><p></p>",
        "favorite_count": 7,
        "answer_type": "normal"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1991113821977346967}",
      "attached_info": "CpULCICBzNa/lZS0qgEQBBoJNzYzOTI0MjYyIKDG58oGKCowBUAySigKHVRTX1NPVVJDRV9JTlRFUkVTVF9XT1JEX01FUkdFEgEwGAAgADoASigKHVRTX1NPVVJDRV9ORUFSTElORV9DT05URU5UX1YyEgEwGAAgADoAWgkxMTc5MTY1NzBiIGE0ZTkwYzU3OTg3MTU2YmE5MWIwMjVhOTMxYWNlMTA4chMxOTkxMTEzODIxOTc3MzQ2OTY3igETMTk4OTk5ODAwNjI1OTQ0NjI1NaoBCXJlY29tbWVuZMIBIDNiMmU2OTVjNTM3YTczODdmY2Q2ODY0ZDIyZjc4MjIw8gEKCAwSBk5vcm1hbPIBKAgKEiQ3MDViYjVhZC04ZmJjLTQwNjMtYWIyYi1mNDE1NTIzMWUxYzXyAQUICxIBOYICAIgCzdLEm7kzkgIgM2IyZTY5NWM1MzdhNzM4N2ZjZDY4NjRkMjJmNzgyMjCaAgDKAhRGaXJzdEJydXNoV2VpZ2h0UnVsZcoCFlNob3JJbnRlcmVzdFdlaWdodFJ1bGXKAhtJbnRlcmFjdGlvblNob3JJbnRlcmVzdFJ1bGXaAh1UU19TT1VSQ0VfSU5URVJFU1RfV09SRF9NRVJHRegCAvoCC05PUk1BTF9GTE9XigMgM2RmMmJkODJkNGEwNDNhZWFkYWMwZDkwMTRlNTQzNDaaAw0KAnYyEAAaBW90aGVyqAPzEdgDAOoDIkludGVyZXN0V29yZE1lcmdlVjFOZXdQb29sUmVjYWxsZXL6A7EFEgxVTktOT1dOX01PREUgACoNTk9fSU1BR0VfTU9ERTotCAMQuAgYxAoiI3YyLWY1ZTMwYTg1Nzg0MWI4MzVkYjQ3ODgzNjExNGM5ZWNkOi0IAhDQAxj4AyIjdjItZWFjMjNmZjkzODcyYWRmYjlmZGRiNzY3Y2Y5YzM3Njk6LQgDEJwIGKgIIiN2Mi01YWY2ODdlZGI2ZDFlNjQyNWU1OGUyY2QxNmFhYTNjZjotCAMQuAgYqA0iI3YyLWZhMWZkYmExZjY5MjIwZmNhMmQxZTM4NDBjODY4ODFhOi0IAhC4CBi4CCIjdjItNThiNGY0MDM3OGM0OGM3OTc3MTZjYjY2YmRiNWFiNTE6LQgEELgIGNoEIiN2Mi0yOGE4NGU1N2UyZWVkOTUyYTAzODkwMmY2OTEzODhjZjotCAMQuAgYoAsiI3YyLTNlMTU4OGEzZTRmZjNlOTllM2RiNTY2M2IyNTNkOWI1Oi0IAhC4CBi4CCIjdjItY2U0N2NhMDZhZjdiMjg2ZTNlMGE2MTBhZWIwYzI5N2E6LQgDEOwJGPAMIiN2Mi1lMDE0NTNhNGY3YjA2N2I3MTdhZjlkNWZkZTA2YmQzZDotCAIQuAgYqAgiI3YyLWEzYmNjMmYyMWFkMDFhZjgzNzc5YWJiZDEzY2U4ZTM3Oi0IAhC4CBjwByIjdjItZDNiZWY1MjJjMzc3MTE3YWFlZGEyMjI0MWE2NjE0ODA6LQgCEIwIGJAGIiN2Mi0zYjhkZDllYzhhN2Q0MmQ5ZTdhZWNiYzI4ZjhiNWQ5YTotCAMQuAgYpAsiI3YyLWNmZTU1ZTFkZjA1OTAwYjBiNDIwMzBiZmM3OGFjMDcxOi0IAhCMBBiMBCIjdjItN2NkYTViYTIwMDc4MmU3YmQwMTY0MzdiOGQ2NzJkMmOABACIBACSBAZOb3JtYWyaBAEyoAQAqAQAsAQAugQCYWnCBAM0MDDIBADSBA/mjqjojZDlt7Lmm7TmlrDYBADwBAD5BAAAAMCj1Jk/gQUAAAAAAAAAAIkFGSivE5G4sT+SBQCaBQNkZnSiBQNkZnSyBQExuQUAAAAAAAAAANAFAOAFAOgFAPAFCZAGAKAGMqgGAJICLgoJNzYzOTI0MjYyEhMxOTkxMTEzODIxOTc3MzQ2OTY3GAQiCklNQUdFX1RFWFQ=",
      "action_card": false
    },
    {
      "id": "51_1767705225.229",
      "type": "feed",
      "offset": 51,
      "verb": "TOPIC_ACKNOWLEDGED_ANSWER",
      "created_time": 1767705225,
      "updated_time": 1767705225,
      "target": {
        "type": "answer",
        "favorite_count": 12,
        "answer_type": "normal",
        "navigator_vote": false,
        "voteup_count": 5,
        "reshipment_settings": "disallowed",
        "preview_type": "default",
        "is_copyable": false,
        "preview_text": "",
        "content": "<p data-pid=\"YlU0E0eH\">“女性兽人”通常指兽耳、兽尾等动物特征与人类女性结合的角色，即“兽娘/Kemono-mimi”，属于广义Furry文化的一个分支的画师，在动漫、游戏和同人插画界有很多代表性人物。</p><p data-pid=\"Jrie4nlg\">“女性兽人”这个中文词可能同时涵盖两种概念，第一是日系动漫风格的“兽娘”，更多强调可爱、性感的拟人化，保留部分动物特征，第二是西方幻想艺术中更偏向写实或奇幻风格的“女性兽人”，例如猫人、狐人等亚人种族。</p><p data-pid=\"BQKbYTiS\">寺田克也是日本国宝级插画大师。他的画风粗犷豪放，色彩浓烈，极具生命力和幻想感。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-29a1caef16ce939dffe46272edc176e2_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1368\" data-size=\"normal\" data-original-token=\"v2-7d86a22eb1a9c12a9a03092d58e40ac5\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-29a1caef16ce939dffe46272edc176e2_r.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-f4b8cbdea79b41bfdc0b0e21b11f6556_1440w.jpg\" data-rawwidth=\"1005\" data-rawheight=\"1047\" data-size=\"normal\" data-original-token=\"v2-c7efc2eb060cf34e5c76c21ff057b459\" class=\"origin_image zh-lightbox-thumb\" width=\"1005\" data-original=\"https://pica.zhimg.com/v2-f4b8cbdea79b41bfdc0b0e21b11f6556_r.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-e0d660ba30b2ca2cf63f82f087aaf461_1440w.jpg\" data-rawwidth=\"1080\" data-rawheight=\"1458\" data-size=\"normal\" data-original-token=\"v2-0fe273c31b16e9da51f9b55d71db5e59\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-e0d660ba30b2ca2cf63f82f087aaf461_r.jpg\"/></figure><p data-pid=\"4a02SxBy\">他笔下的女性兽人，例如猫女、龙女等常常充满野性、神秘和强大的气场，完美结合了妖艳与力量感，对后世许多画家影响巨大。</p><p data-pid=\"mffuDvM6\">代表作品有《魔天传说》、《大猿王》等游戏及插画作品集中常有经典兽娘形象。</p><p data-pid=\"N3hdB73h\">村田莲尔以其独特的“复古未来主义”风格闻名。</p><p data-pid=\"0u1OCmoh\">他笔下的女性角色包括兽娘，常常带有机械义肢、精密装饰与动物特征尤其是犬耳的结合，造型优雅华丽，细节无比精致，开创了一种极具辨识度的美学风格。</p><p data-pid=\"T6u_eVTL\">代表作品有游戏《最终幻想》系列部分宣传插画、个人画集《REN MURATA ARTWORKS》等。</p><p data-pid=\"cC1sPwOi\">田中贵之是商业美少女游戏的旗帜性人物。虽然他绘制各种类型的美少女，但其笔下的兽娘尤其是猫娘、狐娘形象极其经典，以极度唯美、性感、色彩绚丽的风格定义了整整一代人对“兽耳娘”的审美。</p><p></p>",
        "is_labeled": true,
        "allow_segment_interaction": true,
        "id": "1990383710781055664",
        "question": {
          "comment_count": 0,
          "is_following": false,
          "question_type": "normal",
          "url": "https://api.zhihu.com/questions/265039005",
          "follower_count": 0,
          "author": {
            "url": "https://api.zhihu.com/people/f2740a780d0e40eff74e02d536f81f0a",
            "name": "大小黑",
            "headline": "人无远虑，必有近忧。",
            "is_org": false,
            "gender": 1,
            "is_following": false,
            "is_followed": false,
            "id": "f2740a780d0e40eff74e02d536f81f0a",
            "user_type": "people",
            "url_token": "chai_wei",
            "avatar_url": "https://pica.zhimg.com/50/v2-4736ff0aad9fc396bc951be2e6d7b44d_l.jpg?source=b6762063",
            "followers_count": 40
          },
          "title": "有哪些擅长画女性兽人的画师？",
          "excerpt": "",
          "detail": "",
          "id": "265039005",
          "type": "question",
          "created": 1514980284,
          "relationship": {
            "is_author": false
          },
          "answer_count": 0,
          "bound_topic_ids": [
            13739,
            110952
          ]
        },
        "excerpt_new": "“女性兽人”通常指兽耳、兽尾等动物特征与人类女性结合的角色，即“兽娘/Kemono-mimi”，属于广义Furry文化的一个分支的画师，在动漫、游戏和同人插画界有很多代表性人物。 “女性兽人”这个中文词可能同时涵盖两种概念，第一是日系动漫风格的“兽娘”，更多强调可爱、性感的拟人化，保留部分动物特征，第二是西方幻想艺术中更偏向写实或奇幻风格的“女性兽人”，例如猫人、狐人等亚人种族。 寺田克也是日本国宝级插画大师。他…",
        "is_navigator": false,
        "author": {
          "id": "010d26d363afc0fcb37a26a87725b787",
          "user_type": "people",
          "name": "彩色的煤球",
          "is_org": false,
          "gender": -1,
          "is_following": false,
          "is_followed": false,
          "url": "https://api.zhihu.com/people/010d26d363afc0fcb37a26a87725b787",
          "url_token": "tan-a-wen-92",
          "headline": "用绘画讲故事，用故事讲绘画。",
          "avatar_url": "https://picx.zhimg.com/50/v2-8f9d8db79a0ae547f43024203c8c9c07_l.jpg?source=b6762063",
          "followers_count": 741
        },
        "created_time": 1767324456,
        "updated_time": 1767324456,
        "comment_count": 0,
        "excerpt": "“女性兽人”通常指兽耳、兽尾等动物特征与人类女性结合的角色，即“兽娘/Kemono-mimi”，属于广义Furry文化的一个分支的画师，在动漫、游戏和同人插画界有很多代表性人物。 “女性兽人”这个中文词可能同时涵盖两种概念，第一是日系动漫风格的“兽娘”，更多强调可爱、性感的拟人化，保留部分动物特征，第二是西方幻想艺术中更偏向写实或奇幻风格的“女性兽人”，例如猫人、狐人等亚人种族。 寺田克也是日本国宝级插画大师。他…",
        "visited_count": 273,
        "thumbnails": [
          "https://pica.zhimg.com/50/v2-7d86a22eb1a9c12a9a03092d58e40ac5_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-c7efc2eb060cf34e5c76c21ff057b459_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-0fe273c31b16e9da51f9b55d71db5e59_720w.jpg?source=b6762063"
        ],
        "url": "https://api.zhihu.com/answers/1990383710781055664",
        "thanks_count": 3,
        "thumbnail": "https://pica.zhimg.com/50/v2-7d86a22eb1a9c12a9a03092d58e40ac5_720w.jpg?source=b6762063",
        "relationship": {
          "is_thanked": false,
          "is_nothelp": false,
          "voting": 0
        },
        "vote_next_step": "vote"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"answer\", \"id\": 1990383710781055664}",
      "attached_info": "CsYHCICBzNa/lZS0qgEQBBoJNzYzNjYyMDQ1IKj23MoGKAUwAEAzSkIKLVRTX1NPVVJDRV9UV09UT1dFUl9NVUxUSV9TQ0VORV9WMV9SRUNBTExfVEVYVBIBMBgAIAA6CnsicmF3IjoiIn1KQgotVFNfU09VUkNFX1RXT1RPV0VSX01VTFRJX1NDRU5FX1YxX1JFQ0FMTF9URVhUEgEwGAAgADoKeyJyYXciOiIifVoIMjA0NDY5MDNiIGE0ZTkwYzU3OTg3MTU2YmE5MWIwMjVhOTMxYWNlMTA4chMxOTkwMzgzNzEwNzgxMDU1NjY0igEJMjY1MDM5MDA1qgEJcmVjb21tZW5kwgEgMDEwZDI2ZDM2M2FmYzBmY2IzN2EyNmE4NzcyNWI3ODfyAQoIDBIGTm9ybWFs8gEoCAoSJDNhNTZkNWFkLTJhZDktNDFkMC05NjBhLTU1ZTg1NjEwNDEyOPIBBQgLEgE5ggIAiALN0sSbuTOSAiAwMTBkMjZkMzYzYWZjMGZjYjM3YTI2YTg3NzI1Yjc4N5oCAMoCFEZpcnN0QnJ1c2hXZWlnaHRSdWxlygIWU2hvckludGVyZXN0V2VpZ2h0UnVsZcoCG0ludGVyYWN0aW9uU2hvckludGVyZXN0UnVsZdoCLVRTX1NPVVJDRV9UV09UT1dFUl9NVUxUSV9TQ0VORV9WMV9SRUNBTExfVEVYVOgCBPoCC05PUk1BTF9GTE9XigMgM2RmMmJkODJkNGEwNDNhZWFkYWMwZDkwMTRlNTQzNDaaAw0KAnYyEAAaBW90aGVyqAORAtgDAOoDH3RleHRGZWVkVHdvVG93ZXJXYXJtdXBTdWNjZXNzVjH6A6wBEgxVTktOT1dOX01PREUgACoNTk9fSU1BR0VfTU9ERTotCAQQuAgY2AoiI3YyLTdkODZhMjJlYjFhOWMxMmE5YTAzMDkyZDU4ZTQwYWM1Oi0IAxDtBxiXCCIjdjItYzdlZmMyZWIwNjBjZjM0ZTVjNzZjMjFmZjA1N2I0NTk6LQgDELgIGLILIiN2Mi0wZmUyNzNjMzFiMTZlOWRhNTFmOWI1NWQ3MWRiNWU1OYAEAIgEAJIEBk5vcm1hbJoEATSgBACoBACwBAC6BAJhacIEAzQwMMgEANIED+aOqOiNkOW3suabtOaWsNgEAPAEAPkEAAAAYCIkeT+BBQAAAAAAAAAAiQUZKK8TkbixP5IFAJoFA2RmdKIFA2RmdLIFATG5BQAAAAAAAAAA0AUA4AUA6AUA8AUJkAYAoAYzqAYAkgIuCgk3NjM2NjIwNDUSEzE5OTAzODM3MTA3ODEwNTU2NjQYBCIKSU1BR0VfVEVYVA==",
      "action_card": false
    },
    {
      "id": "52_1767705225.111",
      "type": "feed",
      "offset": 52,
      "verb": "TOPIC_ACKNOWLEDGED_ARTICLE",
      "created_time": 1767705225,
      "updated_time": 1767705225,
      "target": {
        "author": {
          "url": "https://api.zhihu.com/people/8d60231c1cb2f6916dd585f07874f496",
          "user_type": "people",
          "url_token": "57-63-48-71",
          "headline": "研讨孙子兵法",
          "avatar_url": "https://picx.zhimg.com/50/v2-fb56a1762c7c8258a40d590097e11a9d_l.jpg?source=b6762063",
          "gender": 1,
          "is_following": false,
          "id": "8d60231c1cb2f6916dd585f07874f496",
          "is_org": false,
          "followers_count": 72,
          "is_followed": false,
          "name": "沈阳张氏"
        },
        "voting": 0,
        "comment_count": 0,
        "preview_text": "",
        "content": "<p data-pid=\"cxu_zZGj\">本篇，主要目的是通过对《战争论》和《孙子兵法》的对照分析来为深入理解孙子的军事思想提供更进一步的参考和帮助。</p><p data-pid=\"OO2PpBIu\">所谓思想碰撞，指的是两部著作中共同谈及的某些重要观点的碰撞。由于《孙子兵法》的很多领域《战争论》并未涉及，所以那些领域的内容并未包括在本篇之内。</p><p data-pid=\"uQkjanqo\">解读原著的思想，如果没能悟懂悟透就会差之毫厘，谬之千里。</p><p data-pid=\"jLm-_264\">比如“兵以诈立”（〈九地〉篇），就曾遭到过挞伐。批评者的代表性人物南宋的思想家叶适在《水心先生别集·兵权》中批评道，“非诈不为兵，盖自孙、吴始甚矣，人心之不仁也！”，“至于孙武，始弃法而言智，其著兵之情奇正分合豫应天下之变百出而不穷，以诈自名于世，而曰兵徒诈而已矣。”宋代词人高似孙在其《子略卷三·孙子》中批评道，“兵流于毒始于孙武乎。武称雄于言兵，往往舍正而凿高，背义而依诈，凡其言议反复高变无常，智术相高气驱力奋，故《诗》、《书》所述，《韬》、《匮》所传，至此皆索然无余泽矣。”</p><p data-pid=\"S-Z7mRyr\">批评的语气可谓严厉，可是明眼人都清楚这其实是批评者自己不懂得战争，不知道仁义永远都只能对自己国家和民众讲，不能跟敌人讲；战争并不是和平年代的公平竞争，取胜必须靠诡诈，不能靠诚信，如果非要诚信就只有招败，使得自己国破家亡。像批评者这样把和平时期的道德观念和意识形态强加于战争，其实只能表现出自己既不懂战争究竟是什么，又不懂《孙子兵法》的语境以及讲的究竟是什么，其指责并无道理。</p><p data-pid=\"8_8U0NQL\">比如“因粮于敌”（〈作战〉篇）、“重地则掠”（〈九地〉篇），有人很是不忿于抢掠敌国百姓，认为那样做是不人道、不仁义。这也是没能设身处地理解古代军队在战争的困境下必须要做的艰难选择：要么是抢掠敌国，要么是“抢掠”本国，而且是成二十倍的“抢掠”（请参考〈作战〉篇的“解读”），二者无法兼顾。那么，应该去对敌国民众展现人道、仁义，还是对本国民众去展现人道、仁义？答案显然是选无可选的、唯一的，除非心里根本就没拿自己国家的生死存亡、民众的艰难困苦当回事。</p><p data-pid=\"shl1iQ0U\">再比如“夫兵久而国利者，未有也”（〈作战〉篇），有人批评说，孙子只说到了速胜的好，其实久也有久的好，抗日战争我们坚持下来靠的不就是“持久战”么，孙子“兵贵速，不贵久”说得太片面了。这同样是出于批评者自己的误解：《孙子兵法》说的都是进入敌境的进攻作战，并不是对付敌人的入侵，他不提持久战自然是合理的，并不片面。这还是批评者自己没能悟懂孙子。</p><p data-pid=\"0nh39UYb\">还有“凡先处战地而待战者佚，后处战地而趋战者劳”，也有人质疑，三国时期邓艾出奇兵攻蜀，历尽艰险、极其疲惫，可是一举降伏了蜀国，并未见其“劳”有何不利呀；还有，抗战时我29军在南营市艰难挖掘野战工事防御日军，疲惫不堪，虽然先处战地也未见其有多少“佚”的好处，日军后处战地也未见其有多少“劳”的坏处呀。这仍是质疑者自己没能理解孙子，仅看到了其字面，没能懂得其背后隐含的真意。〈实虚〉篇“解读”里对此作了分析，这句话的意思“完全不是敌我双方谁先赶到战场就占了休憩充分的大便宜，后赶到战场就吃了劳顿疲惫的大亏，以至于可以决定胜负，所以必须‘致人而不致于人’”。</p><p data-pid=\"SRX_U_UZ\">……</p><p data-pid=\"MUe0d1Al\">倘若自己没能悟懂悟透，分析和判断自然就会出现错误。现在我辨析《战争论》和《孙子兵法》的观点异同，对自己有着同样的担心。</p><p data-pid=\"eyY03zvX\">英国著名军事理论家李德哈特说：“《战争论》俨然是一座充满着哲学理论的迷宫，读者当中很少有人能够真正把握其逻辑路线，或者深入其理论境界而不致迷失方向。”</p><p data-pid=\"Nh3TP7uP\">因为文化背景不同，对我而言《战争论》确实冗长而繁复，甚至晦涩难懂，所以尽管我已百般谨慎，仍很担心会不会像前面的例子一样，误解《战争论》著者的本意。</p><p data-pid=\"R3h1cTkG\">如果真的有误解，敬请读者不吝批评指正。</p><h2>《战争论》与《孙子兵法》</h2><p data-pid=\"rGh4SQgf\">《战争论》诞生于19世纪初，是德国人卡尔•冯•克劳塞维茨的代表作。《孙子兵法》诞生于公元前5世纪，是中国人孙子（孙武，字长卿）的代表作。</p><p data-pid=\"lCut3AJb\">《战争论》和《孙子兵法》都是了不起的经典之作，各自有其完整的军事思想体系，各自在其理论框架内深入探讨了战争的本质和规律，被公认是西、东方军事理论的两座巅峰、世界兵学界的两朵奇葩，克劳塞维茨和孙子分别被称为西方和东方的兵圣。</p><p data-pid=\"K58IKfyA\">两部著作各有其鲜明的特点。</p><p data-pid=\"ExkxNIB3\">其一，《战争论》是一部军事哲学专著，注重于阐述军事理论，主要着眼于对战争本身的理解，讲述战争是什么。《孙子兵法》是一部用兵作战的教科书，既注重于军事理论，又注重于军事实践，讲述的是用兵作战的取胜之道，涵盖的范围比较大。</p><p data-pid=\"e0Ns3yYf\">比如要做一道美味菜肴，理论著作会告诉我们用什么食材、什么佐料、每种东西需要多少，这些东西之间会如何相互作用，会产生什么样的效果。教科书不仅要讲明这些，还要告诉我们如何去实现美味，何时以何方式放什么食材、什么佐料、分几步、每步放多少，火候要如何掌握、翻炒要如何翻炒、时间要如何控制等等操作细节。或者说，理论著作更多着墨于揭示原理和配方，教科书则不仅要揭示原理和配方，还要揭示具体的实现方法，一步一步指导如何把菜肴做出来。</p><p data-pid=\"pLF3E8sw\">其二，两位著者关注的同是军事斗争领域，在战争的某些根本性规律方面自然会英雄所见略同，可是这又不排除他们各自以自己的独特视角看问题，在站的高度、眼睛的视野以及思考的深度等方面各有特点甚至有明显差异。两部著作都涵盖了军事、政治、经济、民生等领域，了解并比较他们的一些主要论点，会给我们学习和理解孙子的军事理论提供很好的帮助。</p><p data-pid=\"phji81Fa\">克劳塞维茨的视角像是战争的旁观者，描述的画面是静态的，给我们的感觉像是在面对一张张的战场画页；孙子的视角像是战争的参与者，描述的画面是动态的，给我们的感觉像是身临其境参与一场场的战场争斗。如果读者真的能读进去，在后者的文字里，脑海里浮现的就是敌我间的引诱、压迫、冲击、对抗、穿插、奔袭、防御、避让，你冲过来、我杀过去，你用这种招法相攻、我用那种招法回应，你再攻、我再应、再反攻，是战马嘶鸣、喧嚣奔腾、刀刀见血、横尸战阵的动态景象。</p><p data-pid=\"YAN8h1Qz\">其三，就整部著作而言，非常大的不同体现在结构和文笔。这一方面无需赘言，《孙子兵法》总字数虽然仅仅不足6000字，不及《战争论》的百分之一，可是思想与文采的光芒却自然迸射，从宏观到微观、从抽象到具体、从军事到国事、从战争到战事，高明而又精微，比《战争论》的立足点更高、视野更广阔、探讨得更深入、思考得更周详、行文更流畅，全书气势恢宏、前呼后应、环环相扣，如同高山流水、水银泻地，无论是阐述战争理论还是指导实际作战，《战争论》都无法与《孙子兵法》相提并论。</p><h2>战争与政治、经济、民生</h2><p data-pid=\"XNDoQtq8\">先从克劳塞维茨最为著名的战争与政治的关系说起。</p><p data-pid=\"VFib1TX7\">《战争论》指出：“战争就是政治以其他手段的延续”，“政治意图是目的，战争是手段，没有目的的手段永远是不可想象的”，“一切战争均可视为政治行为”（第一篇第一章）……。</p><p data-pid=\"OUZD-ofW\">这一论断振聋发聩，精辟地揭示了战争的来源：是政治选择或者推动了战争。东、西方无数政治家和军事家异口同声地赞同这个论断，认为其揭示了战争的本质。</p><p data-pid=\"2ptqJwTJ\">可是，这就是战争的本质吗？要说到本质，其实还差一层。政治不是神物，而是人的意志的体现，所以说到政治只要未能落实到具体的人，就是未能触及到本质。政治本身又是什么的延续？政治的背后其实还有推手，一个叫做社会的整体利益，一个叫做政治家的个人利益，这两种利益都可能也可以推动政治去选择战争。换言之，战争背后的推手是政治，而政治背后的推手是社会利益和政治家的个人利益。</p><p data-pid=\"ma2NiwiW\">更深入一步，国家间的政治是具体的，是靠称为君主或总统的政治家来实施的。照理，代表着整个社会的政治家推动战争理所当然应该出于整个社会的共同利益而非政治家的个人利益，可实际上却未必能够完全如此，往往不可避免地还参杂有政治家个人或其小团体的私利。所以本质上，政治与战争背后的真正推手其实都是政治家。</p><p data-pid=\"4j3vIZRi\">《战争论》揭示了政治与战争的关系，可是局限在政治与战争之间关系的表象，克劳塞维茨放弃了进一步去探讨政治背后的真正推手，他说，“至于政治会有错误的方向，会优先为执政者的野心、私利和虚荣服务，不是在这里要讨论的问题，因为在任何情况下，军事艺术都不会被视为政治的导师。我们在这里只能把政治看作是整个社会的一切利益的代表”（第八篇第六章）。他揭示了政治与战争的关系，但是止步于以概念对概念，并没有真正触及政治与战争关系的本质。</p><p data-pid=\"a19fn92F\">而事实上，政治家的个人因素是无法回避的，不应该放弃探讨，不应该笼统地把整个社会的共同利益与政治家的个人利益混在一起，忽视政治会优先为执政者的野心、私利甚至虚荣服务，那样会模糊甚至扭曲政治与战争关系的本来面目。因为此时确实存在两种利益，而这两种利益有可能是矛盾甚至对立的：政治家的个人利益即使不同于整个社会的共同利益，却仍然可能成为战争的真正推手。不把战争联系到政治背后的真正推手，关于政治与战争关系的论断就是空洞的，对于认识、指导、解决实际问题没有意义。</p><p data-pid=\"9bcqSwP_\">《孙子兵法》中没有提及政治这个词，可是也讲到了《战争论》中的“政治”，而且透过表象揭示了政治与战争关系的本质。孙子直指政治背后的两个真正推手，一个是社会的整体利益，一个是政治家的个人因素。关于前者，他指出判断战争的是与非、对与错，必须要看是否符合整个社会的整体利益，如果不满足“合乎利而用，不合而止”（〈火攻〉篇）的前提，那战争就是错误的；关于后者，他指出政治家、军事家是可能会因个人因素甚至个人情绪而推动战争的，那样的战争是根本错误的，所以必须注意避免，无论是君主还是将领，都不可以把个人的意愿、好恶凌驾于社会利益之上，“主不可以怒兴军，将不可以愠用战”。</p><p data-pid=\"Tbu_cZgY\">他不仅透过政治的表象揭示了其背后的真正推手与战争之间的联系，而且还进一步给出了战争是与非、对与错的判断标准：那要看是哪一个推手因为什么推动了战争，如果战争是政治家、军事家基于个人利益甚至个人情绪推动的，那就是错误的；即使战争是由整个社会的整体利益推动的，可是如果没能同时具备有把握必胜、危险已迫在眉睫这两个条件，那么发动战争也是错误的，“非利不动，非得不用，非危不战”（〈火攻〉篇）。</p><p data-pid=\"N5Qzof6g\">《孙子兵法》本是有意回避国家政治的，可能因为孙子不认为国家政治是将领应该或者可以介入的领域，所以《孙子兵法》中他尽量避言国家政治。可他又清楚，谈到战争是不可能完全避开政治的，不能忽略政治因素的存在，既然必须涉及到政治，他就直指问题的要害，从根本上指出正确与错误的判断标准，并且指出错误的本源来自哪里，既批判了不当的战争行为和不当的政治选择，对那样的危险发出了警告，又指出了如何从源头上避免、控制或者制止错误的战争。</p><p data-pid=\"Mbk7yA0F\">事实上，细品《孙子兵法》就可以发现，孙子的心目中是把政治分为国际政治和国内政治的，前面说的政治家基于社会利益或个人因素推动战争，其实说的就是国际政治；〈计〉篇说的“道者，令民与上同意者也”、〈形〉篇所说的“修道而保法”，其实说的就是国内政治。</p><p data-pid=\"5GftupbB\">不得不说，说《战争论》在西方军事界具有划时代的意义没有错，可是有些人还是把《战争论》捧得太过了，似乎“战争就是政治以其他手段的延续”（第一篇第一章）揭示了多么伟大的真理。那确实是真理，可是克劳塞维茨也并没有多么神，并没有到达应有的深度，通过前面的分析就可以知道，他揭示的不过是一个表象而已，却放弃了去直面政治后面的真正推手，放弃了思考“政治……优先为执政者的野心、私利和虚荣服务”时应该怎么办。如果没读过、没读懂过《孙子兵法》的话，他的观点可能会振聋发聩、像是千里明灯，可是如果真读懂了《孙子兵法》，千里明灯就会黯淡。那是因为，克劳塞维茨的兵学还未能进入到“道”的境界，其哲学格局不够，《孙子兵法》虽然比《战争论》早诞生了两千多年，却是更为明亮的发光体。</p><p data-pid=\"IOfyDjjY\">有人可能会说，连毛泽东都极其重视《战争论》，甚至带着高级将领们专门学习研究过《战争论》，你这样讲是鼠目寸光。我想说我不是带着有色眼镜来看《战争论》的，毛确实重视并且亲自组织高级干部研读过《战争论》，可那有其历史背景，当时他统帅的军队遭受了种种磨难、深陷于战争的漩涡中随时随地面临生死，为了生存下去自然对顶尖的军事理论求知若渴，放着盛名滚滚于先进的西方世界且有马克思、恩格斯、列宁重视且研读在先的军事经典而不去研读，那就不是毛泽东。可是研读是为了汲取其营养部分，并不意味通盘接受和赞同。请看，毛对“战争就是政治以其他手段的延续”（第一篇第一章）的观点是接受的，说“政治发展到一定的阶段，再也不能照旧前进，于是爆发了战争，用以扫除政治道路上的障碍”、“政治是不流血的战争，战争是流血的政治”（《论持久战》）；对“战争是迫使敌人服从我们意志的一种暴力行为”、“必须将以流血的方式解决危机（努力消灭敌军）视为战争的长子”（第一篇第一章）是有批判地接受的，指出“消灭敌人，就是解除敌人的武装，也就是所谓‘剥夺敌人的抵抗力’，不是要完全消灭其肉体”（《论持久战》）；而对战争是“由各种可能性、盖然性、幸运和不幸组成的赌博”之论则是正面驳斥的，说“战争没有绝对的确实性，但不是没有某种程度的相对的确实性。我之一方是比较地确实的。敌之一方很不确实，但也有朕兆可寻，有端倪可察，有前后现象可供思索。这就构成了所谓某种程度的相对的确实性，战争的计划性就有了客观基础”（《论持久战》）。这些批判性地接受和正面驳斥所点明的，恰恰是克劳塞维茨的局限性，这些批判性地接受和正面驳斥所反映出的思想，恰恰与孙子的军事思想是一致的。</p><p data-pid=\"YB4D0a0q\">说到毛与《战争论》的关系，不由得使我联想到毛与《孙子兵法》的关系。</p><p data-pid=\"7Wtz0iHY\">仅就军事而论军事，毛是人类历史上唯一一位堪与孙子相比肩的伟大军事家，不仅西方的军事家们全都无缘于此位，就是中国古代名动青史的著名兵家孙膑、吴起、尉缭、白起、韩信、曹操、诸葛亮、李靖等等，也全都无缘得居此位，因为只有毛真正独立地在某种程度上接近或达到了孙子的军事境界。尽管毛身为大政治家，在军事理论体系的建设上远不如孙子全面和完善，可是在很多关键性军事观点的高度上真的达到了相若的层次。</p><p data-pid=\"cg6Dolki\">毛读没读过《孙子兵法》？</p><p data-pid=\"eOJegjVs\">根据毛自己的回忆，他是红军长征到达陕北后才读《孙子兵法》的，“那时我没有事情做，走路坐在担架上，做什么？我看书！他抬他的担架，我看我的书。他们又批评我，说我凭着《三国演义》和《孙子兵法》指挥打仗。其实《孙子兵法》当时我并没有看过；《三国演义》我看过几遍，但指挥作战时，谁还记得什么《三国演义》，统统忘了。我就反问他们：你们既然说我是按照《孙子兵法》指挥作战的，想必你们一定是熟读的了，那么请问：《孙子兵法》一共有几章？第一章开头讲的是什么？他们哑口无言。原来他们也根本没有看过！后来到陕北，我看了八本书，看了《孙子兵法》，克劳塞维茨的书看了，日本人写的军事操典也看了，还看了苏联人写的论战略、几种兵种配合作战的书，等等。那时看这些，是为了写革命战争的战略问题，是为了总结革命战争的经验。”（《党的文献》1993年第4期）。</p>",
        "navigator_vote": false,
        "id": "1991883592071156472",
        "excerpt": "本篇，主要目的是通过对《战争论》和《孙子兵法》的对照分析来为深入理解孙子的军事思想提供更进一步的参考和帮助。 所谓思想碰撞，指的是两部著作中共同谈及的某些重要观点的碰撞。由于《孙子兵法》的很多领域《战争论》并未涉及，所以那些领域的内容并未包括在本篇之内。 解读原著的思想，如果没能悟懂悟透就会差之毫厘，谬之千里。 比如“兵以诈立”（〈九地〉篇），就曾遭到过挞伐。批评者的代表性人物南宋的思想家叶适在《…",
        "preview_type": "default",
        "article_type": "paid_column_content",
        "created": 1767682399,
        "url": "https://api.zhihu.com/articles/1991883592071156472",
        "favorite_count": 4,
        "reaction_instruction": {
          "REACTION_CONTENT_SEGMENT_LIKE": "HIDE"
        },
        "voteup_count": 1,
        "is_labeled": true,
        "type": "article",
        "updated": 1767683779,
        "linkbox": {
          "category": "",
          "pic": "",
          "title": "",
          "url": ""
        },
        "excerpt_new": "本篇，主要目的是通过对《战争论》和《孙子兵法》的对照分析来为深入理解孙子的军事思想提供更进一步的参考和帮助。 所谓思想碰撞，指的是两部著作中共同谈及的某些重要观点的碰撞。由于《孙子兵法》的很多领域《战争论》并未涉及，所以那些领域的内容并未包括在本篇之内。 解读原著的思想，如果没能悟懂悟透就会差之毫厘，谬之千里。 比如“兵以诈立”（〈九地〉篇），就曾遭到过挞伐。批评者的代表性人物南宋的思想家叶适在《…",
        "visited_count": 23,
        "vote_next_step": "vote",
        "title": "《孙子兵法本义探微》之兵圣的思想碰撞（约20千字）",
        "thumbnails": [
          "https://pica.zhimg.com/v2-6b8ffa3184f759e378c21ef5c3534537.jpg?source=7e7ef6e2&needBackground=1",
          "https://pic1.zhimg.com/50/v2-6b8ffa3184f759e378c21ef5c3534537_720w.jpg?source=b6762063"
        ],
        "is_navigator": false,
        "allow_segment_interaction": true,
        "image_url": "https://pica.zhimg.com/v2-6b8ffa3184f759e378c21ef5c3534537.jpg?source=7e7ef6e2&needBackground=1",
        "paid_info": {
          "content": "<p data-pid=\"cxu_zZGj\">本篇，主要目的是通过对《战争论》和《孙子兵法》的对照分析来为深入理解孙子的军事思想提供更进一步的参考和帮助。</p><p data-pid=\"OO2PpBIu\">所谓思想碰撞，指的是两部著作中共同谈及的某些重要观点的碰撞。由于《孙子兵法》的很多领域《战争论》并未涉及，所以那些领域的内容并未包括在本篇之内。</p><p data-pid=\"uQkjanqo\">解读原著的思想，如果没能悟懂悟透就会差之毫厘，谬之千里。</p><p data-pid=\"jLm-_264\">比如“兵以诈立”（〈九地〉篇），就曾遭到过挞伐。批评者的代表性人物南宋的思想家叶适在《水心先生别集·兵权》中批评道，“非诈不为兵，盖自孙、吴始甚矣，人心之不仁也！”，“至于孙武，始弃法而言智，其著兵之情奇正分合豫应天下之变百出而不穷，以诈自名于世，而曰兵徒诈而已矣。”宋代词人高似孙在其《子略卷三·孙子》中批评道，“兵流于毒始于孙武乎。武称雄于言兵，往往舍正而凿高，背义而依诈，凡其言议反复高变无常，智术相高气驱力奋，故《诗》、《书》所述，《韬》、《匮》所传，至此皆索然无余泽矣。”</p><p data-pid=\"S-Z7mRyr\">批评的语气可谓严厉，可是明眼人都清楚这其实是批评者自己不懂得战争，不知道仁义永远都只能对自己国家和民众讲，不能跟敌人讲；战争并不是和平年代的公平竞争，取胜必须靠诡诈，不能靠诚信，如果非要诚信就只有招败，使得自己国破家亡。像批评者这样把和平时期的道德观念和意识形态强加于战争，其实只能表现出自己既不懂战争究竟是什么，又不懂《孙子兵法》的语境以及讲的究竟是什么，其指责并无道理。</p><p data-pid=\"8_8U0NQL\">比如“因粮于敌”（〈作战〉篇）、“重地则掠”（〈九地〉篇），有人很是不忿于抢掠敌国百姓，认为那样做是不人道、不仁义。这也是没能设身处地理解古代军队在战争的困境下必须要做的艰难选择：要么是抢掠敌国，要么是“抢掠”本国，而且是成二十倍的“抢掠”（请参考〈作战〉篇的“解读”），二者无法兼顾。那么，应该去对敌国民众展现人道、仁义，还是对本国民众去展现人道、仁义？答案显然是选无可选的、唯一的，除非心里根本就没拿自己国家的生死存亡、民众的艰难困苦当回事。</p><p data-pid=\"shl1iQ0U\">再比如“夫兵久而国利者，未有也”（〈作战〉篇），有人批评说，孙子只说到了速胜的好，其实久也有久的好，抗日战争我们坚持下来靠的不就是“持久战”么，孙子“兵贵速，不贵久”说得太片面了。这同样是出于批评者自己的误解：《孙子兵法》说的都是进入敌境的进攻作战，并不是对付敌人的入侵，他不提持久战自然是合理的，并不片面。这还是批评者自己没能悟懂孙子。</p><p data-pid=\"0nh39UYb\">还有“凡先处战地而待战者佚，后处战地而趋战者劳”，也有人质疑，三国时期邓艾出奇兵攻蜀，历尽艰险、极其疲惫，可是一举降伏了蜀国，并未见其“劳”有何不利呀；还有，抗战时我29军在南营市艰难挖掘野战工事防御日军，疲惫不堪，虽然先处战地也未见其有多少“佚”的好处，日军后处战地也未见其有多少“劳”的坏处呀。这仍是质疑者自己没能理解孙子，仅看到了其字面，没能懂得其背后隐含的真意。〈实虚〉篇“解读”里对此作了分析，这句话的意思“完全不是敌我双方谁先赶到战场就占了休憩充分的大便宜，后赶到战场就吃了劳顿疲惫的大亏，以至于可以决定胜负，所以必须‘致人而不致于人’”。</p><p data-pid=\"SRX_U_UZ\">……</p><p data-pid=\"MUe0d1Al\">倘若自己没能悟懂悟透，分析和判断自然就会出现错误。现在我辨析《战争论》和《孙子兵法》的观点异同，对自己有着同样的担心。</p><p data-pid=\"eyY03zvX\">英国著名军事理论家李德哈特说：“《战争论》俨然是一座充满着哲学理论的迷宫，读者当中很少有人能够真正把握其逻辑路线，或者深入其理论境界而不致迷失方向。”</p><p data-pid=\"Nh3TP7uP\">因为文化背景不同，对我而言《战争论》确实冗长而繁复，甚至晦涩难懂，所以尽管我已百般谨慎，仍很担心会不会像前面的例子一样，误解《战争论》著者的本意。</p><p data-pid=\"R3h1cTkG\">如果真的有误解，敬请读者不吝批评指正。</p><h2>《战争论》与《孙子兵法》</h2><p data-pid=\"rGh4SQgf\">《战争论》诞生于19世纪初，是德国人卡尔•冯•克劳塞维茨的代表作。《孙子兵法》诞生于公元前5世纪，是中国人孙子（孙武，字长卿）的代表作。</p><p data-pid=\"lCut3AJb\">《战争论》和《孙子兵法》都是了不起的经典之作，各自有其完整的军事思想体系，各自在其理论框架内深入探讨了战争的本质和规律，被公认是西、东方军事理论的两座巅峰、世界兵学界的两朵奇葩，克劳塞维茨和孙子分别被称为西方和东方的兵圣。</p><p data-pid=\"K58IKfyA\">两部著作各有其鲜明的特点。</p><p data-pid=\"ExkxNIB3\">其一，《战争论》是一部军事哲学专著，注重于阐述军事理论，主要着眼于对战争本身的理解，讲述战争是什么。《孙子兵法》是一部用兵作战的教科书，既注重于军事理论，又注重于军事实践，讲述的是用兵作战的取胜之道，涵盖的范围比较大。</p><p data-pid=\"e0Ns3yYf\">比如要做一道美味菜肴，理论著作会告诉我们用什么食材、什么佐料、每种东西需要多少，这些东西之间会如何相互作用，会产生什么样的效果。教科书不仅要讲明这些，还要告诉我们如何去实现美味，何时以何方式放什么食材、什么佐料、分几步、每步放多少，火候要如何掌握、翻炒要如何翻炒、时间要如何控制等等操作细节。或者说，理论著作更多着墨于揭示原理和配方，教科书则不仅要揭示原理和配方，还要揭示具体的实现方法，一步一步指导如何把菜肴做出来。</p><p data-pid=\"pLF3E8sw\">其二，两位著者关注的同是军事斗争领域，在战争的某些根本性规律方面自然会英雄所见略同，可是这又不排除他们各自以自己的独特视角看问题，在站的高度、眼睛的视野以及思考的深度等方面各有特点甚至有明显差异。两部著作都涵盖了军事、政治、经济、民生等领域，了解并比较他们的一些主要论点，会给我们学习和理解孙子的军事理论提供很好的帮助。</p><p data-pid=\"phji81Fa\">克劳塞维茨的视角像是战争的旁观者，描述的画面是静态的，给我们的感觉像是在面对一张张的战场画页；孙子的视角像是战争的参与者，描述的画面是动态的，给我们的感觉像是身临其境参与一场场的战场争斗。如果读者真的能读进去，在后者的文字里，脑海里浮现的就是敌我间的引诱、压迫、冲击、对抗、穿插、奔袭、防御、避让，你冲过来、我杀过去，你用这种招法相攻、我用那种招法回应，你再攻、我再应、再反攻，是战马嘶鸣、喧嚣奔腾、刀刀见血、横尸战阵的动态景象。</p><p data-pid=\"YAN8h1Qz\">其三，就整部著作而言，非常大的不同体现在结构和文笔。这一方面无需赘言，《孙子兵法》总字数虽然仅仅不足6000字，不及《战争论》的百分之一，可是思想与文采的光芒却自然迸射，从宏观到微观、从抽象到具体、从军事到国事、从战争到战事，高明而又精微，比《战争论》的立足点更高、视野更广阔、探讨得更深入、思考得更周详、行文更流畅，全书气势恢宏、前呼后应、环环相扣，如同高山流水、水银泻地，无论是阐述战争理论还是指导实际作战，《战争论》都无法与《孙子兵法》相提并论。</p><h2>战争与政治、经济、民生</h2><p data-pid=\"XNDoQtq8\">先从克劳塞维茨最为著名的战争与政治的关系说起。</p><p data-pid=\"VFib1TX7\">《战争论》指出：“战争就是政治以其他手段的延续”，“政治意图是目的，战争是手段，没有目的的手段永远是不可想象的”，“一切战争均可视为政治行为”（第一篇第一章）……。</p><p data-pid=\"OUZD-ofW\">这一论断振聋发聩，精辟地揭示了战争的来源：是政治选择或者推动了战争。东、西方无数政治家和军事家异口同声地赞同这个论断，认为其揭示了战争的本质。</p><p data-pid=\"2ptqJwTJ\">可是，这就是战争的本质吗？要说到本质，其实还差一层。政治不是神物，而是人的意志的体现，所以说到政治只要未能落实到具体的人，就是未能触及到本质。政治本身又是什么的延续？政治的背后其实还有推手，一个叫做社会的整体利益，一个叫做政治家的个人利益，这两种利益都可能也可以推动政治去选择战争。换言之，战争背后的推手是政治，而政治背后的推手是社会利益和政治家的个人利益。</p><p data-pid=\"ma2NiwiW\">更深入一步，国家间的政治是具体的，是靠称为君主或总统的政治家来实施的。照理，代表着整个社会的政治家推动战争理所当然应该出于整个社会的共同利益而非政治家的个人利益，可实际上却未必能够完全如此，往往不可避免地还参杂有政治家个人或其小团体的私利。所以本质上，政治与战争背后的真正推手其实都是政治家。</p><p data-pid=\"4j3vIZRi\">《战争论》揭示了政治与战争的关系，可是局限在政治与战争之间关系的表象，克劳塞维茨放弃了进一步去探讨政治背后的真正推手，他说，“至于政治会有错误的方向，会优先为执政者的野心、私利和虚荣服务，不是在这里要讨论的问题，因为在任何情况下，军事艺术都不会被视为政治的导师。我们在这里只能把政治看作是整个社会的一切利益的代表”（第八篇第六章）。他揭示了政治与战争的关系，但是止步于以概念对概念，并没有真正触及政治与战争关系的本质。</p><p data-pid=\"a19fn92F\">而事实上，政治家的个人因素是无法回避的，不应该放弃探讨，不应该笼统地把整个社会的共同利益与政治家的个人利益混在一起，忽视政治会优先为执政者的野心、私利甚至虚荣服务，那样会模糊甚至扭曲政治与战争关系的本来面目。因为此时确实存在两种利益，而这两种利益有可能是矛盾甚至对立的：政治家的个人利益即使不同于整个社会的共同利益，却仍然可能成为战争的真正推手。不把战争联系到政治背后的真正推手，关于政治与战争关系的论断就是空洞的，对于认识、指导、解决实际问题没有意义。</p><p data-pid=\"9bcqSwP_\">《孙子兵法》中没有提及政治这个词，可是也讲到了《战争论》中的“政治”，而且透过表象揭示了政治与战争关系的本质。孙子直指政治背后的两个真正推手，一个是社会的整体利益，一个是政治家的个人因素。关于前者，他指出判断战争的是与非、对与错，必须要看是否符合整个社会的整体利益，如果不满足“合乎利而用，不合而止”（〈火攻〉篇）的前提，那战争就是错误的；关于后者，他指出政治家、军事家是可能会因个人因素甚至个人情绪而推动战争的，那样的战争是根本错误的，所以必须注意避免，无论是君主还是将领，都不可以把个人的意愿、好恶凌驾于社会利益之上，“主不可以怒兴军，将不可以愠用战”。</p><p data-pid=\"Tbu_cZgY\">他不仅透过政治的表象揭示了其背后的真正推手与战争之间的联系，而且还进一步给出了战争是与非、对与错的判断标准：那要看是哪一个推手因为什么推动了战争，如果战争是政治家、军事家基于个人利益甚至个人情绪推动的，那就是错误的；即使战争是由整个社会的整体利益推动的，可是如果没能同时具备有把握必胜、危险已迫在眉睫这两个条件，那么发动战争也是错误的，“非利不动，非得不用，非危不战”（〈火攻〉篇）。</p><p data-pid=\"N5Qzof6g\">《孙子兵法》本是有意回避国家政治的，可能因为孙子不认为国家政治是将领应该或者可以介入的领域，所以《孙子兵法》中他尽量避言国家政治。可他又清楚，谈到战争是不可能完全避开政治的，不能忽略政治因素的存在，既然必须涉及到政治，他就直指问题的要害，从根本上指出正确与错误的判断标准，并且指出错误的本源来自哪里，既批判了不当的战争行为和不当的政治选择，对那样的危险发出了警告，又指出了如何从源头上避免、控制或者制止错误的战争。</p><p data-pid=\"Mbk7yA0F\">事实上，细品《孙子兵法》就可以发现，孙子的心目中是把政治分为国际政治和国内政治的，前面说的政治家基于社会利益或个人因素推动战争，其实说的就是国际政治；〈计〉篇说的“道者，令民与上同意者也”、〈形〉篇所说的“修道而保法”，其实说的就是国内政治。</p><p data-pid=\"5GftupbB\">不得不说，说《战争论》在西方军事界具有划时代的意义没有错，可是有些人还是把《战争论》捧得太过了，似乎“战争就是政治以其他手段的延续”（第一篇第一章）揭示了多么伟大的真理。那确实是真理，可是克劳塞维茨也并没有多么神，并没有到达应有的深度，通过前面的分析就可以知道，他揭示的不过是一个表象而已，却放弃了去直面政治后面的真正推手，放弃了思考“政治……优先为执政者的野心、私利和虚荣服务”时应该怎么办。如果没读过、没读懂过《孙子兵法》的话，他的观点可能会振聋发聩、像是千里明灯，可是如果真读懂了《孙子兵法》，千里明灯就会黯淡。那是因为，克劳塞维茨的兵学还未能进入到“道”的境界，其哲学格局不够，《孙子兵法》虽然比《战争论》早诞生了两千多年，却是更为明亮的发光体。</p><p data-pid=\"IOfyDjjY\">有人可能会说，连毛泽东都极其重视《战争论》，甚至带着高级将领们专门学习研究过《战争论》，你这样讲是鼠目寸光。我想说我不是带着有色眼镜来看《战争论》的，毛确实重视并且亲自组织高级干部研读过《战争论》，可那有其历史背景，当时他统帅的军队遭受了种种磨难、深陷于战争的漩涡中随时随地面临生死，为了生存下去自然对顶尖的军事理论求知若渴，放着盛名滚滚于先进的西方世界且有马克思、恩格斯、列宁重视且研读在先的军事经典而不去研读，那就不是毛泽东。可是研读是为了汲取其营养部分，并不意味通盘接受和赞同。请看，毛对“战争就是政治以其他手段的延续”（第一篇第一章）的观点是接受的，说“政治发展到一定的阶段，再也不能照旧前进，于是爆发了战争，用以扫除政治道路上的障碍”、“政治是不流血的战争，战争是流血的政治”（《论持久战》）；对“战争是迫使敌人服从我们意志的一种暴力行为”、“必须将以流血的方式解决危机（努力消灭敌军）视为战争的长子”（第一篇第一章）是有批判地接受的，指出“消灭敌人，就是解除敌人的武装，也就是所谓‘剥夺敌人的抵抗力’，不是要完全消灭其肉体”（《论持久战》）；而对战争是“由各种可能性、盖然性、幸运和不幸组成的赌博”之论则是正面驳斥的，说“战争没有绝对的确实性，但不是没有某种程度的相对的确实性。我之一方是比较地确实的。敌之一方很不确实，但也有朕兆可寻，有端倪可察，有前后现象可供思索。这就构成了所谓某种程度的相对的确实性，战争的计划性就有了客观基础”（《论持久战》）。这些批判性地接受和正面驳斥所点明的，恰恰是克劳塞维茨的局限性，这些批判性地接受和正面驳斥所反映出的思想，恰恰与孙子的军事思想是一致的。</p><p data-pid=\"YB4D0a0q\">说到毛与《战争论》的关系，不由得使我联想到毛与《孙子兵法》的关系。</p><p data-pid=\"7Wtz0iHY\">仅就军事而论军事，毛是人类历史上唯一一位堪与孙子相比肩的伟大军事家，不仅西方的军事家们全都无缘于此位，就是中国古代名动青史的著名兵家孙膑、吴起、尉缭、白起、韩信、曹操、诸葛亮、李靖等等，也全都无缘得居此位，因为只有毛真正独立地在某种程度上接近或达到了孙子的军事境界。尽管毛身为大政治家，在军事理论体系的建设上远不如孙子全面和完善，可是在很多关键性军事观点的高度上真的达到了相若的层次。</p><p data-pid=\"cg6Dolki\">毛读没读过《孙子兵法》？</p><p data-pid=\"eOJegjVs\">根据毛自己的回忆，他是红军长征到达陕北后才读《孙子兵法》的，“那时我没有事情做，走路坐在担架上，做什么？我看书！他抬他的担架，我看我的书。他们又批评我，说我凭着《三国演义》和《孙子兵法》指挥打仗。其实《孙子兵法》当时我并没有看过；《三国演义》我看过几遍，但指挥作战时，谁还记得什么《三国演义》，统统忘了。我就反问他们：你们既然说我是按照《孙子兵法》指挥作战的，想必你们一定是熟读的了，那么请问：《孙子兵法》一共有几章？第一章开头讲的是什么？他们哑口无言。原来他们也根本没有看过！后来到陕北，我看了八本书，看了《孙子兵法》，克劳塞维茨的书看了，日本人写的军事操典也看了，还看了苏联人写的论战略、几种兵种配合作战的书，等等。那时看这些，是为了写革命战争的战略问题，是为了总结革命战争的经验。”（《党的文献》1993年第4期）。</p>"
        },
        "comment_permission": "all"
      },
      "brief": "{\"source\": \"TS\", \"type\": \"article\", \"id\": 1991883592071156472}",
      "attached_info": "CtsGCICBzNa/lZS0qgEQBxoJMjY4NjM3MTQ0IN/i8soGKAEwAEA0SkIKLVRTX1NPVVJDRV9UV09UT1dFUl9NVUxUSV9TQ0VORV9WMV9SRUNBTExfVEVYVBIBMBgAIAA6CnsicmF3IjoiIn1iIGE0ZTkwYzU3OTg3MTU2YmE5MWIwMjVhOTMxYWNlMTA4chMxOTkxODgzNTkyMDcxMTU2NDcyggFfaHR0cHM6Ly9waWNhLnpoaW1nLmNvbS92Mi02YjhmZmEzMTg0Zjc1OWUzNzhjMjFlZjVjMzUzNDUzNy5qcGc/c291cmNlPTdlN2VmNmUyJm5lZWRCYWNrZ3JvdW5kPTGqAQlyZWNvbW1lbmTCASA4ZDYwMjMxYzFjYjJmNjkxNmRkNTg1ZjA3ODc0ZjQ5NvIBCggMEgZOb3JtYWzyASgIChIkNDJmZmQwNzgtZGYyZC00NjBlLTg3N2MtZjAyODE4MjM2ZTM28gEFCAsSATmCAgCIAs3SxJu5M5ICIDhkNjAyMzFjMWNiMmY2OTE2ZGQ1ODVmMDc4NzRmNDk2mgIAygIURmlyc3RCcnVzaFdlaWdodFJ1bGXKAhZTaG9ySW50ZXJlc3RXZWlnaHRSdWxlygISVGhlbWVJc29sYXRpb25SdWxl2gItVFNfU09VUkNFX1RXT1RPV0VSX01VTFRJX1NDRU5FX1YxX1JFQ0FMTF9URVhU6AID+gILTk9STUFMX0ZMT1eKAyAzZGYyYmQ4MmQ0YTA0M2FlYWRhYzBkOTAxNGU1NDM0NpoDDQoCdjIQABoFb3RoZXKoAxfYAwDqAxV0ZXh0RmVlZFR3b1Rvd2VyVjFBbGz6A04SDFVOS05PV05fTU9ERSAAKg1OT19JTUFHRV9NT0RFOi0IBBDwChjwBSIjdjItNmI4ZmZhMzE4NGY3NTllMzc4YzIxZWY1YzM1MzQ1MzeABACIBACSBAZOb3JtYWyaBAEzoAQAqAQAsAQAugQCYWnCBAM0MDDIBADSBA/mjqjojZDlt7Lmm7TmlrDYBADwBAD5BAAAAEA14Gs/gQUAAAAAAAAAAIkFGSivE5G4sT+SBQCaBQNkZnSiBQNkZnSyBQExuQUAAAAAAAAAANAFAOAFAOgFAPAFCZAGAKAGNKgGAZICLgoJMjY4NjM3MTQ0EhMxOTkxODgzNTkyMDcxMTU2NDcyGAciCklNQUdFX1RFWFQ=",
      "action_card": false
    },
    {
      "id": "53_1767705225.550",
      "type": "feed",
      "offset": 53,
      "verb": "TOPIC_ACKNOWLEDGED_ARTICLE",
      "created_time": 1767705225,
      "updated_time": 1767705225,
      "target": {
        "comment_count": 7,
        "excerpt": "最近在学习C++，主要是看到大厂都要求搞AI的会这门语言——“熟练掌握C/C++”，而我只会一些python。但很奇怪的是github上也没几个C++的深度学习项目，而我又懒得从底层学C++，我一直坚信在场景中学习是最高效的。我也没那么多时间细究什么指针啥的高性能问题，然后看C++的书本、视频又感觉跟我深度学习没什么关系，感觉比较老，跟项目工程差了十万八千里。我只想先学会用一个C++项目，然后有时间再说其他的细节问题。 本笔记帮…",
        "favorite_count": 242,
        "vote_next_step": "vote",
        "type": "article",
        "url": "https://api.zhihu.com/articles/1990373677397717730",
        "author": {
          "followers_count": 16,
          "id": "87336d266c2244c1d8df5d4794fe1eaa",
          "url_token": "xiu-lin-82-84",
          "name": "修林",
          "avatar_url": "https://picx.zhimg.com/50/v2-4937a0f831b2c311af6f44ec761e521c_l.jpg?source=b6762063",
          "gender": -1,
          "is_following": false,
          "is_followed": false,
          "url": "https://api.zhihu.com/people/87336d266c2244c1d8df5d4794fe1eaa",
          "user_type": "people",
          "headline": "",
          "is_org": false
        },
        "visited_count": 2567,
        "preview_type": "default",
        "id": "1990373677397717730",
        "created": 1767591500,
        "content": "<p data-pid=\"Q393FYSP\">最近在学习C++，主要是看到大厂都要求搞AI的会这门语言——“熟练掌握C/C++”，而我只会一些python。但很奇怪的是github上也没几个C++的深度学习项目，而我又懒得从底层学C++，我一直坚信在场景中学习是最高效的。我也没那么多时间细究什么指针啥的高性能问题，然后看C++的书本、视频又感觉跟我深度学习没什么关系，感觉比较老，跟项目工程差了十万八千里。我只想先学会用一个C++项目，然后有时间再说其他的细节问题。</p><p data-pid=\"kCeqKfY8\"><b><i>本笔记帮助跟我一样想法的人入门C++，快速上手学会基本用法，然后后面的语法问题，就能很方便的边看代码边问AI来学习了！</i></b>边干边学，才是最快的方法，我们不能做好一切准备再上，没这个时间。</p><ul><li data-pid=\"8RI48XPI\"><b>所用项目</b>：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/ggml-org/llama.cpp\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/ggml-org/lla</span><span class=\"invisible\">ma.cpp</span><span class=\"ellipsis\"></span></a></li><li data-pid=\"7HxDRW6P\"><b>项目版本：</b>llama这个项目更新的挺频繁的，我用的是2026年1月3日的项目。大差不差，主要是学习C++，不重要。</li><li data-pid=\"ohCQojMG\"><b>看懂本笔记前提要求</b>：能够理解并使用一些 Python 写的深度学习项目，懂得基本的 Python 语法与常见库调用；不要求能熟练编写复杂算法，但能看懂代码并理解数据在代码中的流动逻辑即可。有一些 Linux 基本操作经验与C语言基础（数据类型、类、函数什么的），最好之前三分钟热度学过一点C++前面的知识（我就是。。）。</li><li data-pid=\"P8E5CFkU\"><b>核心目标：</b> 对C++的陌生感消失，能够清楚知道接下来我要看哪个文件，某个文件夹大概是干什么的，各个文件的交互逻辑是什么，剩下的知识都知道要问AI什么，不至于连怎么问怎么开始都不会。</li></ul><p data-pid=\"mq4pXGS9\">注：电脑端学习最佳～～</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>1. llama.cpp基础知识入门</h2><p data-pid=\"kL6o8Dbx\">C++的好处就不说了，就是快，像是很多python的底层库，就是用C++写的。不过最近看微软说2030年完全抛弃C++转投Rust了，唉，先不管这些。</p><p data-pid=\"kxyKf0ja\"><b>强烈建议使用AI来学习</b>：如果没有github copilot，建议弄个教育版，国内大学也能通过，方便代码学习与写代码。如果嫌麻烦，也可以先凑合用国内的TRAE，这个软件的SOLO模式还可以，之前成功用它进行过多文件逻辑修改。其他AI免费编程的还有腾讯的CodeBuddy，谷歌的反重力，但是我都没用过，不知道怎么样。</p><p data-pid=\"PR0lJqlA\">接下来，我们按照高层次到低层次的路径进行学习。与传统的从什么是 #include，怎么打印到函数的自底向上逻辑正好相反。 </p><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.1 C++基础知识（先把C++当app程序使用）</h3><p data-pid=\"2Fxm20op\">不要把C++看作是“带类的C语言”，现代C++（Modern C++）是一门全新的语言。</p><ul><li data-pid=\"PBk5k6Rc\"><b>静态类型 &amp; 编译型语言</b>：</li><ul><li data-pid=\"4W7rHNkX\">代码写完后，必须通过<b>编译器</b>翻译成机器码（01010...）才能运行。这不像Python是边解释边运行。</li><li data-pid=\"4cpVlG9m\"><b>优点</b>：运行速度极快，编译器能帮你检查很多错误。</li></ul><li data-pid=\"bPM7BNNV\"><b>手动管理内存（双刃剑）</b>：</li><ul><li data-pid=\"dNgV-Dva\">你需要通过指针（Pointer）直接操作内存。</li><li data-pid=\"IU65fF3r\"><b>核心概念 RAII</b>（资源获取即初始化）：这是C++的灵魂。简单说就是：<b>谁申请的资源（内存/文件），谁负责在生命周期结束时自动释放</b>。利用好这点，你就不会内存泄漏。</li></ul><li data-pid=\"cd4KE-v9\"><b>零开销抽象</b>：</li><ul><li data-pid=\"KUT2HAoG\">C++允许你写很高级的代码（比如类、模板），但生成的机器码效率和手写汇编差不多。</li></ul></ul><p data-pid=\"sVfOwLKa\">因此，当你写了代码之后必须先用编译器把它翻译成机器能识别的二进制文件（可执行程序）才能运行。<b>编译器和构建工具是必须安装的。</b></p><p data-pid=\"pc7S9hGJ\">跟python一样，c++也分版本，常见的是c++11（学校可能会用，但太老了）或c++17，现在比较稳定的就是c++17，新的版本还没完全稳定。不同版本的功能有些区别，但如果不是专业C++程序员应该不用太花心思学他们的区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（1）编译器</h3><p data-pid=\"to84ysbG\">你写的文本文件（.cpp）变成可执行文件（.exe或 Linux下的可执行程序），需要经历<b>编译工具链</b>的处理。</p><blockquote data-pid=\"0aT-OE39\">在 C++ 中，.cpp 文件是<b>源文件</b>，用来写程序的具体实现代码（函数怎么做、逻辑怎么跑）；.h 文件是<b>头文件</b>，用来声明接口（有哪些函数、类、变量可以被别人使用），相当于“说明书”。编译时，编译器先通过 .h 文件知道“有什么可用”，再通过 .cpp 文件找到“具体实现”。<br/>除了这两种，.hpp 也是头文件的一种写法，.c 是 C 语言源文件，.cc 也是 C++ 源文件，.o 是编译后的中间目标文件，最终由链接器把多个 .o 合成一个可执行程序或库。</blockquote><p data-pid=\"9P23w-MF\">1. 常见的编译器（三大巨头）</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>编译器</th><th>全称/前端</th><th>平台支持</th><th>优点</th><th>缺点</th><th>标准支持（截至 2026）</th></tr><tr><td>GCC</td><td>GNU Compiler Collection</td><td>Linux、Windows (MinGW)、macOS</td><td>免费开源、优化强、生态成熟</td><td>错误提示较啰嗦</td><td>优秀（C++23 完整，C++26 部分）</td></tr><tr><td>Clang</td><td>LLVM 项目的前端</td><td>Linux、macOS、Windows</td><td>错误提示超级友好、编译快、诊断优秀</td><td>某些优化稍逊 GCC</td><td>领先（C++23/26 支持最好）</td></tr><tr><td>MSVC</td><td>Microsoft Visual C++</td><td>Windows 主力</td><td>与 Visual Studio 集成完美、Windows 优化好</td><td>非 Windows 支持差、闭源</td><td>良好（C++23 完整，C++26 跟进中）</td></tr></tbody></table><p data-pid=\"22oHpfEx\">我个人推荐win的话用GCC，mac用Clang就行。这两个都是三端互通。</p><p data-pid=\"_5UafMtD\">不同的编译器所使用的命令行是不一样的，但整体逻辑差不多。</p><p data-pid=\"lAVTo54f\">2. 编译的四个步骤（必知！）</p><p data-pid=\"yRjm-vWg\">如果你理解了这个，就能看懂90%的报错信息：</p><ul><li data-pid=\"cDvvTYUz\"><b>预处理 (Preprocessing)</b>：处理所有 # 开头的指令（如 #include）。也就是把头文件的内容直接复制粘贴到你的代码里。</li><li data-pid=\"0INa0j_R\"><b>编译 (Compilation)</b>：把C++代码翻译成汇编代码，再转成<b>目标文件</b>（.o 或 .obj）。</li><ul><li data-pid=\"n1iohmKR\"><i>小白注意</i>：这一步只检查语法错误。</li></ul><li data-pid=\"kQ15SFyy\"><b>汇编 (Assembly)</b>：将汇编代码转为机器码。</li><li data-pid=\"mSe5LXEx\"><b>链接 (Linking)</b>：把所有的目标文件和库文件（Library）“打包”在一起，生成最终的可执行文件。</li><ul><li data-pid=\"yqFaQZsr\"><i>常见报错</i>：Undefined reference（未定义引用）通常就是链接错误，意思是“我找到了函数的声明，但找不到它的实现”。</li></ul></ul><div class=\"highlight\"><pre><code class=\"language-text\">多个 .cpp 和 .h/.hpp 源文件\n          ↓\n驱动程序（g++ / clang++ / cl）\n   ├─ 预处理器 (cpp)\n   ├─ 编译器本体 (cc1 / cc1plus)\n   ├─ 汇编器 (as)\n   ↓\n每个 .cpp 生成一个目标文件（.o 或 .obj）\n          ↓\n链接器（ld / lld / link.exe）\n          ↓\n可执行文件（Linux/macOS: 无后缀，Windows: .exe）\n或\n库文件（.a .lib .so .dll .dylib）</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>（2）构建工具</h3><p data-pid=\"ky3GSN4Q\">单文件项目直接用编译器就行，但真实项目有几十上百个文件、库、不同配置（Debug/Release），就需要构建工具自动化管理。</p><p data-pid=\"CBHh63A9\"><b><i>构建工具 = 把源代码 → 自动、正确、高效地变成可执行程序 / 库</i></b></p><p data-pid=\"N86CbhpM\"><b>具体来说，构建工具负责：</b></p><ul><li data-pid=\"y2zuIPLm\">哪些文件要编译？</li><li data-pid=\"vXbKjREr\">谁先谁后？</li><li data-pid=\"bYB0xxCr\">哪些文件变了要重新编？</li></ul><p data-pid=\"3dtbQ9Gz\">常见构建工具对比：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>工具</th><th>类型</th><th>优点</th><th>缺点</th><th>典型使用场景</th></tr><tr><td>Make</td><td>经典 Makefile</td><td>简单、历史悠久、灵活</td><td>Makefile 语法复杂、易出错</td><td>小项目、Linux 原生</td></tr><tr><td>CMake</td><td>元构建系统（生成器）</td><td>跨平台、语法清晰、生态强大</td><td>学习曲线稍陡、间接一层</td><td>大中型跨平台项目</td></tr><tr><td>Ninja</td><td>底层构建执行器</td><td>极快（并行构建优秀）</td><td>本身不管理依赖，需要前端生成</td><td>与 CMake 搭配</td></tr><tr><td>Meson</td><td>现代构建系统</td><td>速度快、Python 风格语法</td><td>社区较 CMake 小</td><td>新项目、追求速度</td></tr><tr><td>Bazel</td><td>Google 的构建系统</td><td>可缓存、可复用、支持大规模</td><td>配置复杂</td><td>超大型项目（如 Google）</td></tr></tbody></table><p data-pid=\"FkRyN2Ye\">这里只用学习CMake和Ninja，也是本项目着重使用的工具。</p><p data-pid=\"gn8cPXAU\"><b>CMake</b>：一个“配置工具”（不是直接编译的）。它读取你写的描述文件（CMakeLists.txt），然后<b>生成</b>适合你平台的构建脚本。</p><ul><li data-pid=\"6v9E0CoZ\">它跨平台：Windows 生成 Visual Studio 项目，Linux/macOS 可以生成 Makefile 或 Ninja 文件。</li><li data-pid=\"FDvpurpC\">优点：语法简单、强大，能自动找库、设置编译选项。</li></ul><p data-pid=\"x0H4Ms8u\"><b>Ninja</b>：一个“超级快的执行工具”。它只负责真正调用编译器（g++/clang++/cl）来编译和链接。</p><ul><li data-pid=\"5uiirD4E\">为什么快？它专门设计为并行构建（同时编译多个文件），比老的 Make 快很多。</li><li data-pid=\"KMu2Jsqo\">Ninja 自己不会配置项目，它只执行 CMake 生成的 “build.ninja” 文件。</li></ul><p data-pid=\"q9Oh2HQ2\">基本流程：</p><ol><li data-pid=\"4wDxCnbI\">项目根目录写 CMakeLists.txt</li><li data-pid=\"Zh8IOctC\">创建 build 目录：mkdir build &amp;&amp; cd build</li><li data-pid=\"p37oVhB8\">生成：cmake .. -G &#34;Ninja&#34;（或默认生成 Makefile）</li><li data-pid=\"HufxWO9X\">构建：cmake --build . 或 ninja</li></ol><p data-pid=\"AZWKvDEx\">简单说：CMake 配置 → 生成 Ninja 文件 → Ninja 真正构建。</p><ul><li data-pid=\"57tRVU_t\"><b>CMake 是设计图</b></li><li data-pid=\"3sdI3nRJ\"><b>Ninja 是施工队</b></li></ul><p data-pid=\"JK-IE4CB\">注意，这两个其实都能当编程语言来学习了（你编译完了可以看到多了一堆文件夹，很复杂），但是这里不细究细节，能完成前期编译构建工具就行。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（3）怎么编译，项目会发生什么事情</h3><p data-pid=\"a2BCDGD4\">上面的介绍可能还是比较难以理解，这里详细说明一下构建和编译的具体场景（其实vscode的CMake tools插件可以自动构建编译，对小白很友好，但我们还是了解一下）。</p><p data-pid=\"bLK2Wurx\"><b>我们从一个中型C++项目来感受一下编译这件事。</b></p><p data-pid=\"o5mth4vw\">假设我们的项目长这个样子：</p><div class=\"highlight\"><pre><code class=\"language-text\">myproject/\n├── CMakeLists.txt          ← 根配置文件\n├── main.cpp # 暴露在外的接口，类似python的train脚本之类的\n├── src/ # 核心源码文件夹\n│   ├── utils.cpp\n│   └── utils.h\n└── include/ # 头文件目录\n    └── mylib.h</code></pre></div><p data-pid=\"iPXMGXTl\">最简单的CMakeLists.txt内容：</p><div class=\"highlight\"><pre><code class=\"language-text\">cmake_minimum_required(VERSION 3.15) # 要求的 CMake 最低版本\nproject(MyApp LANGUAGES CXX)  # 定义项目名称和语言\n\nset(CMAKE_CXX_STANDARD 20)\n\n# 收集 src 目录所有 .cpp 文件\nfile(GLOB SOURCES &#34;src/*.cpp&#34;)\n\nadd_executable(myapp main.cpp ${SOURCES}) # 定义要生成的可执行文件或库\n\n# 让 main.cpp 能找到 include 目录的头文件\ntarget_include_directories(myapp PRIVATE include src) # 添加头文件搜索路径</code></pre></div><blockquote data-pid=\"G3WzlbN2\">CMakeLists.txt 是 <b>CMake 构建系统的核心配置文件</b>，用来告诉 CMake <b>这个项目应该如何被构建</b>，它包含了项目的基本信息、要编译哪些源文件、要生成哪些目标（可执行程序或库）、如何链接依赖库、设置编译选项等规则，是整个项目自动化构建的“说明书”。<br/>这里我们先不管，就当python的requirement.txt来使用，看得懂就行。<br/><b>一个大型项目通常不仅仅有一个 CMakeLists.txt。每个子目录也可以有自己的 CMakeLists.tx</b>t，形成树状结构，由根目录的文件递归调用，适合模块化管理。</blockquote><p data-pid=\"gd99cWkC\">一般我们把构建的东西专门放一个文件夹：</p><div class=\"highlight\"><pre><code class=\"language-text\">mkdir build # 创建文件夹 build\ncd build # 进入 build 文件夹</code></pre></div><p data-pid=\"kzZimZ2z\">构建命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">cmake .. -G &#34;Ninja&#34;</code></pre></div><p data-pid=\"8vAghuv5\">CMake 读取 CMakeLists.txt，检查编译器，生成：</p><ul><li data-pid=\"Oj3eAZFO\">build.ninja（Ninja 的构建规则）</li><li data-pid=\"KPXCnObe\">CMakeCache.txt（配置缓存）</li><li data-pid=\"dhbHUouQ\">其他临时文件</li></ul><p data-pid=\"THZ_jR7c\">真正编译命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">ninja</code></pre></div><ul><li data-pid=\"HqA3N7T0\">Ninja 并行编译多个 .cpp（比如同时编 utils.cpp 和 main.cpp）。</li><li data-pid=\"Wy0QshFs\">产生：myapp 可执行文件 + 多个 .o 文件。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"oGhvIPaA\"><b>大项目结构更复杂，但原理相同：</b></p><p data-pid=\"Z8PrRgiW\">用子目录：每个模块一个子文件夹 + 自己的 CMakeLists.txt 生成多个目标：可执行文件 + 静态/动态库 支持 Debug/Release：cmake .. -G “Ninja” -DCMAKE_BUILD_TYPE=Release</p><p data-pid=\"bpKDO8He\">额外常用命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">ninja clean：清理所有生成的文件\ncmake .. -G “Ninja” -DCMAKE_BUILD_TYPE=Debug：生成带调试信息的版本 \nninja -j8：用 8 个核心并行构建（更快） </code></pre></div><blockquote data-pid=\"8fr2Mf16\">PS：用 IDE：VS Code + CMake 插件、CLion、Visual Studio 都能直接打开 CMake 项目，一键构建！</blockquote><p data-pid=\"kh1cttcG\">产生的东西总结：</p><ul><li data-pid=\"XWgmyQY_\">build/ 目录：</li><ul><li data-pid=\"-3bS1TAm\">build.ninja + CMakeCache.txt（配置后产生）</li><li data-pid=\"FirANwTH\">CMakeFiles/（临时缓存）</li><li data-pid=\"t0yCvJNb\">*.o / *.obj（每个 .cpp 的目标文件）</li><li data-pid=\"zT2dt3ie\">最终：可执行文件 / 库文件 (.a/.lib/.so/.dll)</li></ul><li data-pid=\"m6I5BNX1\">源码目录：保持干净（所有生成物都在 build/）</li></ul><p data-pid=\"24shAl0z\">为什么大项目都爱 CMake + Ninja？</p><p data-pid=\"dzxluvuA\">跨平台：同一套 CMakeLists.txt，在 Windows/Linux/macOS 都行。 快：Ninja 是目前最快的构建执行器。 智能：自动处理依赖、增量构建、缓存。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（4）文件后缀概念</h3><ol><li data-pid=\"gT19WgUP\">核心文件类型：</li></ol><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>类型</th><th>用途说明</th><th>常见搭配/推荐</th><th>出现频率</th></tr><tr><td>.cpp</td><td>源文件（实现文件）</td><td>存放函数定义、main 函数等实际代码。现代最主流的 C++ 源文件后缀。</td><td>与 .h 或 .hpp 搭配</td><td>最高（Windows、跨平台项目）</td></tr><tr><td>.h</td><td>头文件</td><td>存放类声明、函数原型、宏、inline 函数等。被 #include 包含，不直接编译。</td><td>与 .cpp 搭配（最常见）</td><td>极高（标准库也用无后缀，但自定义常用 .h）</td></tr><tr><td>.hpp</td><td>纯 C++ 头文件</td><td>类似 .h，但明确表示“只用于 C++”（包含模板、class 等不兼容 C 的内容）。</td><td>与 .cpp 搭配（推荐现代项目）</td><td>很高（Boost 等库常用）</td></tr><tr><td>.o / .obj</td><td>目标文件</td><td>编译中间产物（每个 .cpp 编译后生成）。二进制，不用人读。</td><td>构建过程自动生成</td><td>高（build 目录中）</td></tr><tr><td>CMakeLists.txt</td><td>构建配置文件</td><td>CMake 项目必备，描述如何编译、链接、找库等。不是代码文件，而是脚本。</td><td>项目根目录和子目录</td><td>极高（现代大项目标准）</td></tr></tbody></table><p data-pid=\"wKazzjbQ\">2. 非核心文件类型（不完整）：</p><p data-pid=\"hPaqqhr9\"><b>源文件变体（与.cpp的功能几乎一样）：</b></p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>说明</th><th>常见场景</th></tr><tr><td>.cc</td><td>Unix/Linux 社区偏好（Google、LLVM 等项目常用）。</td><td>开源项目、GCC/Clang</td></tr><tr><td>.cxx</td><td>“xx” 代表 ++，强调 C++。少见，但一些老项目或严格命名用。</td><td>学术代码、某些 Unix 项目</td></tr><tr><td>.C</td><td>大写 C，早起 Unix 区分 C（.c）和 C++（.C）。现在几乎不用（大小写敏感问题）。</td><td>极少（历史遗留）</td></tr><tr><td>.c++</td><td>字面意思“c plus plus”。罕见，因为 + 在一些工具中是特殊字符。</td><td>几乎不遇</td></tr></tbody></table><p data-pid=\"9cL0RG5d\"><b>头文件变体：</b></p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>说明</th><th>常见场景</th></tr><tr><td>.hh</td><td>与 .cc 搭配，类似 .hpp。</td><td>Google 风格项目</td></tr><tr><td>.hxx</td><td>与 .cxx 搭配。少见。</td><td>某些 Boost 子库</td></tr><tr><td>.H</td><td>大写，早起区分。几乎不用。</td><td>历史遗留</td></tr></tbody></table><p data-pid=\"fderkENd\"><b>模板/内联专用（高级，模板实现常用）</b>：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>说明</th><th>常见场景</th></tr><tr><td>.inl</td><td>Inline 文件，存放 inline 函数或模板实现，常 #include 到 .h 底部。</td><td>一些库分离实现，与 .hpp 搭配（模板库常见）</td></tr><tr><td>.ipp</td><td>Implementation of Pure Header，类似 .inl，模板实现。</td><td>Boost 等库</td></tr><tr><td>.tpp / .tpl</td><td>Template implementation，专门放模板代码。</td><td>老项目分离模板</td></tr></tbody></table><p data-pid=\"EUCb-RzO\"><b>C++20 模块相关（新兴，2026 年已较成熟）</b>：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>说明</th><th>常见场景</th></tr><tr><td>.cppm</td><td>模块接口文件（module interface unit）。Clang/MSVC 支持。</td><td>现代模块项目</td></tr><tr><td>.ixx</td><td>MSVC 默认的模块接口后缀。</td><td>Visual Studio 项目</td></tr></tbody></table><p data-pid=\"--hDf6RA\"><b>构建/中间/输出文件（非源码）</b>：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>说明</th></tr><tr><td>.a / .lib</td><td>静态库（打包多个 .o）。</td></tr><tr><td>.so / .dll / .dylib</td><td>动态库（运行时加载）。</td></tr><tr><td>.exe</td><td>Windows 可执行文件（Linux/macOS 无后缀）。</td></tr><tr><td>.i / .ii</td><td>预处理后文件（g++ -E 生成，用于调试宏）。</td></tr><tr><td>.s</td><td>汇编文件（g++ -S 生成）。</td></tr><tr><td>build.ninja</td><td>Ninja 构建脚本（CMake 生成）。</td></tr></tbody></table><p data-pid=\"XIOMrbjm\"><b>其他补充：</b></p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>后缀</th><th>类型</th><th>用途说明</th><th>常见搭配/推荐</th><th>出现频率</th></tr><tr><td>.cmake</td><td>CMake 模块/脚本文件</td><td>自定义 CMake 函数、宏、配置脚本。通常放在 cmake/ 目录下，被 include() 使用。常见示例：FindXXX.cmake（查找库模块）、<a href=\"https://link.zhihu.com/?target=http%3A//Config.cmake.in\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">Config.cmake.in</span><span class=\"invisible\"></span></a>（包配置模板）。</td><td>include() 或 find_package() 使用</td><td>高（中大型项目常见）</td></tr><tr><td>CMakeCache.txt</td><td>CMake 缓存文件</td><td>CMake 配置阶段生成的缓存文件，记录所有缓存变量（用户通过 -D 设置的选项）。不要手动编辑，不加入版本控制。</td><td>build 目录中自动生成</td><td>高（每次配置生成）</td></tr><tr><td>cmake_install.cmake</td><td>CMake 安装脚本</td><td>自动生成的安装规则脚本，由 install() 命令产生。</td><td>build 目录中</td><td>高</td></tr><tr><td>*.<a href=\"https://link.zhihu.com/?target=http%3A//cmake.in\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">cmake.in</span><span class=\"invisible\"></span></a></td><td>CMake 配置模板文件</td><td>常用于生成 XXXConfig.cmake 包配置文件（如 <a href=\"https://link.zhihu.com/?target=http%3A//MyProjectConfig.cmake.in\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">MyProjectConfig.cmake.in</span><span class=\"invisible\"></span></a>），配合 configure_package_config_file() 使用。</td><td>cmake/ 目录下，生成安装包时使用</td><td>中等（发布库时常见）</td></tr><tr><td>compile_commands.json</td><td>编译数据库</td><td>记录每个源文件的完整编译命令，用于 clang-tidy、YouCompleteMe 等工具。</td><td>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</td><td>高（现代项目推荐开启）</td></tr></tbody></table><p class=\"ztext-empty-paragraph\"><br/></p><h3>（5）一个基本C++项目包含的内容</h3><p data-pid=\"uP3y8PZj\">根据上面我们介绍的编译过程，一个经典的C++项目可能长这个样子：</p><div class=\"highlight\"><pre><code class=\"language-text\">MyLargeProject/\n├── CMakeLists.txt          # 根文件：全局设置、选项、子目录包含\n├── cmake/                  # 自定义模块/脚本（如 FindCustomLib.cmake）\n├── src/                    # 源代码模块\n│   ├── module1/            # 子模块1\n│   │   ├── CMakeLists.txt  # 定义 module1 的库/目标\n│   │   ├── include/        # 头文件\n│   │   ├── src/            # 源文件\n│   │   ├── tests/          # 测试\n│   │   └── data/           # 数据文件\n│   └── module2/            # 子模块2（类似）\n├── examples/               # 示例应用\n│   └── CMakeLists.txt\n├── tests/                  # 全局测试\n├── libs/                   # 外部依赖（vendored 或 header-only）\n│   └── CMakeLists.txt\n├── doc/                    # 文档配置（如 Doxyfile.in）\n├── conanfile.txt           # 如果用 Conan 依赖管理\n├── create_module.sh        # 脚本自动化创建新模块\n└── README.md</code></pre></div><p data-pid=\"qIrOGRlK\">一个比较完整的CMakeLists.txt的语法模版（建议直接让AI解释llama.cpp中的CMakeLists.txt来构建认知）：</p><div class=\"highlight\"><pre><code class=\"language-text\"># CMakeLists.txt 文件是 CMake 构建系统的核心配置文件。\n# 它使用 CMake 的脚本语言来描述项目的构建过程，包括源文件、依赖、编译选项等。\n# CMake 会读取这个文件，生成特定平台的构建文件（如 Makefile 或 Visual Studio 项目）。\n# 命令不区分大小写（推荐用小写），参数和变量区分大小写。\n# 变量用 ${VAR} 引用，字符串用双引号包围。\n# 注释用 # 开头。\n\n# 指定 CMake 的最低版本要求。\n# VERSION 参数指定最低版本号，如果用户 CMake 版本低于此，会报错。\n# 这有助于确保项目使用特定特性时兼容性。\n# 推荐在文件开头写这个。\ncmake_minimum_required(VERSION 3.18)\n\n# 定义项目名称、版本和支持的语言。\n# project() 命令设置项目全局变量，如 PROJECT_NAME、PROJECT_VERSION。\n# VERSION 指定版本号（可选），LANGUAGES 指定语言（如 C、CXX 为 C++）。\n# 这会自动设置一些变量，如 ${PROJECT_NAME} = &#34;MyProject&#34;。\nproject(MyProject VERSION 1.0.0 LANGUAGES CXX)\n\n# 设置用户可配置的选项。\n# option() 命令定义一个布尔选项，用户可以通过 cmake -DBUILD_TESTS=OFF 来设置。\n# 第一个参数是选项名，第二个是描述字符串，第三个是默认值（ON 或 OFF）。\noption(BUILD_TESTS &#34;Enable building of unit tests&#34; ON)\noption(USE_SANITIZER &#34;Enable address sanitizer for debugging&#34; OFF)\n\n# 设置变量。\n# set() 命令定义变量，可以是普通变量或缓存变量。\n# 这里设置 C++ 标准为 17，并要求强制使用（REQUIRED ON）。\n# CMAKE_CXX_STANDARD 是内置变量，用于全局设置编译器标准。\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# 生成 compile_commands.json 文件，用于 IDE 和工具如 clang-tidy。\n# 这是一个缓存变量（CACHE BOOL），用户可以在 cmake-gui 中修改。\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON CACHE BOOL &#34;Generate compile commands for IDEs&#34; FORCE)\n\n# 消息输出，用于调试或信息提示。\n# message() 可以有 STATUS（信息）、WARNING（警告）、FATAL_ERROR（错误停止）。\n# 这里打印项目版本，使用 ${PROJECT_VERSION} 变量。\nmessage(STATUS &#34;Building ${PROJECT_NAME} version ${PROJECT_VERSION}&#34;)\n\n# 创建一个接口库，用于传播全局编译选项。\n# add_library() 命令创建库，INTERFACE 表示无源代码的库，只用于属性传播。\n# 这是一种现代 CMake 实践，避免全局修改编译选项。\nadd_library(project_options INTERFACE)\n\n# 为目标设置编译特性。\n# target_compile_features() 指定编译器特性，如 cxx_std_17 确保 C++17 支持。\n# INTERFACE 表示这些特性会传播给链接此库的目标。\ntarget_compile_features(project_options INTERFACE cxx_std_17)\n\n# 为目标设置编译选项。\n# target_compile_options() 添加编译标志，如 -Wall（所有警告）、-Wextra（额外警告）。\n# INTERFACE/PRIVATE/PUBLIC 控制可见性：PUBLIC 传播给依赖，PRIVATE 只本地，INTERFACE 只传播。\ntarget_compile_options(project_options INTERFACE -Wall -Wextra -pedantic)\n\n# 条件判断。\n# if() 命令用于逻辑分支，这里检查 USE_SANITIZER 选项。\n# 如果启用，则添加 sanitizer 选项（用于内存错误检测）。\nif(USE_SANITIZER)\n    target_compile_options(project_options INTERFACE -fsanitize=address)\n    target_link_libraries(project_options INTERFACE -fsanitize=address)\n    message(STATUS &#34;Address sanitizer enabled&#34;)\nendif()\n\n# 包含外部依赖管理模块。\n# include() 命令加载其他 CMake 文件或模块。\n# FetchContent 是 CMake 内置模块，用于从 Git 等下载依赖。\ninclude(FetchContent)\n\n# 声明一个外部依赖。\n# FetchContent_Declare() 定义依赖的来源，如 Git 仓库和标签。\n# 这里下载 fmt 库（一个格式化库）。\nFetchContent_Declare(\n    fmt\n    GIT_REPOSITORY https://github.com/fmtlib/fmt.git\n    GIT_TAG 10.0.0\n)\n\n# 使依赖可用。\n# FetchContent_MakeAvailable() 会下载、构建并添加依赖到项目。\nFetchContent_MakeAvailable(fmt)\n\n# 添加子目录。\n# add_subdirectory() 包含子目录的 CMakeLists.txt，实现模块化。\n# 假设项目有 src/module1 和 src/module2 子模块。\nadd_subdirectory(src/module1)\nadd_subdirectory(src/module2)\n\n# 收集源文件。\n# aux_source_directory() 将目录中的所有源文件收集到变量中。\n# 这里收集 src 目录的 .cpp 文件到 SRC_LIST（但大型项目推荐手动列出文件以避免问题）。\naux_source_directory(src SRC_LIST)\n\n# 创建静态库。\n# add_library() 创建库，STATIC 表示静态库（.a 或 .lib）。\n# 源文件可以是列表或变量如 ${SRC_LIST}。\nadd_library(core_lib STATIC ${SRC_LIST})\n\n# 为库设置包含目录。\n# target_include_directories() 添加头文件搜索路径。\n# PUBLIC 表示路径会传播给链接此库的目标。\ntarget_include_directories(core_lib PUBLIC include)\n\n# 链接库和选项。\n# target_link_libraries() 链接其他库或目标。\n# 这里链接 project_options（传播选项）和 fmt::fmt（从 FetchContent）。\ntarget_link_libraries(core_lib PUBLIC project_options fmt::fmt)\n\n# 创建可执行文件。\n# add_executable() 创建可执行目标，源文件如 main.cpp。\nadd_executable(my_app src/main.cpp)\n\n# 链接主库到可执行文件。\n# PRIVATE 表示依赖不传播（因为 app 是最终目标）。\ntarget_link_libraries(my_app PRIVATE core_lib)\n\n# 启用测试。\n# enable_testing() 激活 CTest 测试框架。\nif(BUILD_TESTS)\n    enable_testing()\n    # 添加测试子目录。\n    add_subdirectory(tests)\n    \n    # 添加自定义测试。\n    # add_test() 定义一个测试，NAME 是测试名，COMMAND 是运行命令。\n    add_test(NAME MyTest COMMAND my_app --test)\nendif()\n\n# 安装规则。\n# install() 命令定义安装目标，如将可执行文件安装到 bin 目录。\n# DESTINATION 指定安装路径，相对 CMAKE_INSTALL_PREFIX。\ninstall(TARGETS my_app core_lib\n        RUNTIME DESTINATION bin\n        LIBRARY DESTINATION lib\n        ARCHIVE DESTINATION lib)\n\n# 导出目标。\n# install(EXPORT) 生成导出文件，便于其他项目用 find_package() 导入此项目。\ninstall(EXPORT MyProjectTargets\n        FILE MyProjectTargets.cmake\n        NAMESPACE MyProject::\n        DESTINATION lib/cmake/MyProject)\n\n# 包含 CPack 用于打包。\n# include(CPack) 启用 CPack 生成安装包（如 deb、rpm）。\ninclude(CPack)\n\n# 自定义函数示例。\n# function() 定义函数，类似于宏但有局部作用域。\nfunction(print_info ARG)\n    message(STATUS &#34;Info: ${ARG}&#34;)\nendfunction()\n\n# 调用函数。\nprint_info(&#34;Project built successfully&#34;)</code></pre></div><p data-pid=\"1gqZuWrZ\"><b>至此，我们已经建立了C++项目长怎么样，前期编译构建的基础认知🎉</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.2 llama总览（厘清重点部分）</h3><p data-pid=\"jK2ffJyI\">先下载llama.cpp这个仓库，使用vscode打开（我看大型项目好像用的是Visual Studio，这里为了轻度学习，就先不管这个）。关于什么是llama（能点进来的基本都是python深度学习入门了吧），怎么在本地安装C++环境，可以简单搜索、AI一下就知道了（vscode就是加个插件的事）——主要就是下载编译器（gcc或clang）和构建工具（CMake、Ninja）。</p><blockquote data-pid=\"vlJCmyYU\">PS：vscode安装CMake tools插件</blockquote><p data-pid=\"5pWCxyA5\">如果你安装好了编译器和构建工具，那么每次用vscode打开这个项目的时候，会自动配置（尚未编译），在终端输出部分会显示（如果你想换一个配置，你可以删除build文件夹，然后在CMake tools里面的配置重新选择，新手建议使用debug版本）：</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-a3417bc765f1c159354e1f4cb75e97c0_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"1990\" data-rawheight=\"556\" data-original-token=\"v2-dc33ee7281c077b50861877ecebbf2ef\" class=\"origin_image zh-lightbox-thumb\" width=\"1990\" data-original=\"https://pic1.zhimg.com/v2-a3417bc765f1c159354e1f4cb75e97c0_r.jpg\"/><figcaption>配置成功，如果好奇发生了什么可以将终端内容复制给AI，一条条解释什么意思，然后缺什么就安装什么就行。我这里不是git clone下来的，直接下载的zip，所以不是git仓库。</figcaption></figure><figure data-size=\"normal\"><img src=\"https://picx.zhimg.com/v2-1f18418e08d6a9e8f9d797554b688e89_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"776\" data-original-token=\"v2-c27a8bed31eed953ec4253f1f80de63d\" class=\"origin_image zh-lightbox-thumb\" width=\"622\" data-original=\"https://picx.zhimg.com/v2-1f18418e08d6a9e8f9d797554b688e89_r.jpg\"/><figcaption>Cmake tools工具，可以对整体文件有一个认知，我的是mac。生成就是build，可用来选择编译部分源码，而不是默认全部。关于CMake tools，可以看其他文章、视频讲解。</figcaption></figure><p data-pid=\"y-emWQCu\">面对繁多的文件夹与文件，首先你要做的是用github copilot（或TRAE），<b>让AI告诉你每个文件夹、文件的作用是什么</b>。先建立起对整个项目的大概理解，知道我大概要学习哪些文件。</p><p data-pid=\"meqyY-EM\">这里我根据AI整理如下（每个人基础不同，建议自己也AI一下，然后哪些名词看不懂自己再AI一下，先把一级节点的文件夹、文件厘清一下）：</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-da4726de86e54a296a3a8abc43f7ffe4_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"6805\" data-rawheight=\"5628\" data-original-token=\"v2-d68d4e3e98e258736c767047d0dea7a4\" class=\"origin_image zh-lightbox-thumb\" width=\"6805\" data-original=\"https://pica.zhimg.com/v2-da4726de86e54a296a3a8abc43f7ffe4_r.jpg\"/><figcaption>最外面的文件概览</figcaption></figure><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-7b024c0e2273802be180c57dd371bcac_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"6199\" data-rawheight=\"4236\" data-original-token=\"v2-003389f84fbf0a9035737cc41ae2af4d\" class=\"origin_image zh-lightbox-thumb\" width=\"6199\" data-original=\"https://pica.zhimg.com/v2-7b024c0e2273802be180c57dd371bcac_r.jpg\"/><figcaption>最外面的文件夹概览</figcaption></figure><p data-pid=\"XkdlVTQL\">图像可以在新浏览器窗口放大看，原图可以在这里获取：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/XiuLinO/Llama.cpp-Study-Notes\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/XiuLinO/Llam</span><span class=\"invisible\">a.cpp-Study-Notes</span><span class=\"ellipsis\"></span></a></p><p data-pid=\"W5WPsCrV\">绿色表示与C++直接相关，红色表示与AI直接相关，蓝色为技术关键词。</p><p data-pid=\"qJylECyO\"><b>项目结构概述（无需懂 C++）</b></p><ul><li data-pid=\"sPUBOjwT\"><b><code><span class=\"nolink\">ggml/</span></code></b>：核心张量运算库（“肌肉”）。负责底层数学计算，如矩阵乘法。文件多是因为支持多种硬件优化。</li><li data-pid=\"ipL3r-x3\"><b><code><span class=\"nolink\">src/</span></code></b>：LLM 推理逻辑（“大脑”）。包含模型加载、Token 处理、推理循环。</li><li data-pid=\"W7AfpLI7\"><b><code><span class=\"nolink\">examples/</span></code></b>：实际应用示例。从简单（如 <code><span class=\"nolink\">examples/simple/</span></code>）到复杂（如服务器）。这是你最该看的——它们展示了如何使用库。</li><li data-pid=\"u0Z2L__I\"><b><code><span class=\"nolink\">common/</span></code></b>：通用工具，如命令行解析、采样策略。</li><li data-pid=\"R0VAt-89\"><b><code><span class=\"nolink\">docs/</span></code></b>：文档。[<code>docs/build.md</code>]<span class=\"nolink\">build.md</span> &#34;docs/build.md&#34;) 解释构建，<code><span class=\"nolink\">docs/backend/</span></code> 描述硬件支持。</li><li data-pid=\"5g1hzJ-G\"><b><code><span class=\"nolink\">CMakeLists.txt</span></code></b>：构建脚本（非代码）。告诉编译器如何组织文件。</li><li data-pid=\"ip2LNffv\">其他：测试（<span class=\"nolink\">tests</span>）、工具（<span class=\"nolink\">tools</span>）、脚本（<span class=\"nolink\">scripts</span>）。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.3 编译构建llama.cpp</h3><p data-pid=\"Ab0HpAM5\">任何一个项目要上手都要看它的文档，也就是doc文件夹以及放在外面的md文件。llama.cpp的文档用AI总结如下：</p><p data-pid=\"1ROkZkfR\">根级文件含义和作用</p><ul><li data-pid=\"TkbOubv3\"><b>android.md</b>：Android 平台构建和运行指南。作用：教如何在 Android 设备上编译和部署 llama.cpp。</li><li data-pid=\"uvUY3vfq\"><b>build-riscv64-spacemit.md</b>：RISC-V 64 位架构（Spacemit 芯片）构建指南。作用：针对特定硬件优化编译。</li><li data-pid=\"xXz6c8r0\"><b>build-s390x.md</b>：s390x 架构（IBM z/Systems）构建指南。作用：支持大型机平台。</li><li data-pid=\"RsapZmk_\"><b>build.md</b>：通用构建指南）。作用：教如何使用 CMake 编译项目，支持 CPU、GPU 等后端。</li><li data-pid=\"ZscE3-Dv\"><b>docker.md</b>：Docker 容器使用指南。作用：简化环境设置，在容器中运行 llama.cpp。</li><li data-pid=\"gMISTAP7\"><b>function-calling.md</b>：函数调用功能文档。作用：解释如何在 LLM 中实现工具调用（如 API 集成）。</li><li data-pid=\"RRVotYLL\"><b>install.md</b>：安装指南。作用：快速安装预编译版本或依赖。</li><li data-pid=\"-5A3im9a\"><b>llguidance.md</b>：LLGuidance 库集成文档。作用：描述结构化输出库的使用。</li><li data-pid=\"b9zABoZf\"><b>multimodal.md</b>：多模态模型支持。作用：处理文本+图像等输入。</li><li data-pid=\"hHnGuFPb\"><b>ops.md</b>：操作（Ops）文档。作用：列出支持的张量运算和性能基准。</li></ul><p data-pid=\"GcHB-h7b\">子文件夹含义和作用</p><ul><li data-pid=\"Y5eRLKd2\"><b>android/</b>：Android 特定文档。作用：深入 Android 开发和部署。</li><li data-pid=\"seekaOZ0\"><b>backend/</b>：后端支持文档（如 CUDA.md, Metal.md）。作用：硬件加速指南（GPU、CPU 等）。</li><li data-pid=\"Q1QH09Tk\"><b>development/</b>：开发相关文档（如 HOWTO-add-model.md）。作用：教如何添加新模型或调试。</li><li data-pid=\"cvzYM5xn\"><b>llama-star/</b>：Llama-Star 工具文档。作用：特定工具的使用。</li><li data-pid=\"o4nV6DOC\"><b>multimodal/</b>：多模态模型文档（如 llava.md）。作用：支持视觉+文本模型。</li><li data-pid=\"jPaLdpcl\"><b>ops/</b>：操作性能数据（CSV 文件）。作用：基准测试结果，用于优化。</li></ul><p data-pid=\"WSY9Jqny\">这里相关的是两个：install.md和build.md。前者是真的把llama当作app用——安装<b>预编译的二进制包</b>（直接可用，不修改源码）；后者就是开发修改（添加功能），继续从源代码编译。</p><p data-pid=\"JvgXvJ30\">这里我们的目的是学习源码，所以选择build.md。如果好奇前者会发生什么，我看b站挺多教学视频的，什么用qwen3来本地部署之类的。</p><p data-pid=\"NJrJUXbL\">用AI讲解build.md的内容，可以获知各个平台下的编译方法。这里为了统一win和mac用户，我用CMake tools插件来说明：</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-4cb9718c1cca9836446afff01aa79ae8_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"856\" data-original-token=\"v2-dca733f7ed5db98003a1a92d424a38a6\" class=\"origin_image zh-lightbox-thumb\" width=\"722\" data-original=\"https://pic1.zhimg.com/v2-4cb9718c1cca9836446afff01aa79ae8_r.jpg\"/><figcaption>选择插件，配置选择debug模式，生成选择all</figcaption></figure><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-6067c2c78d777ddaa86d6e4e84db5114_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"236\" data-original-token=\"v2-a3d28af60223007332dced2acd318a68\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pica.zhimg.com/v2-6067c2c78d777ddaa86d6e4e84db5114_r.jpg\"/><figcaption>点击生成</figcaption></figure><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-5444df5bb686dc93c68bc1779a3f8eb1_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"302\" data-original-token=\"v2-3625c2bdf2e91eb45c5f997a519ec2c1\" class=\"origin_image zh-lightbox-thumb\" width=\"618\" data-original=\"https://pic2.zhimg.com/v2-5444df5bb686dc93c68bc1779a3f8eb1_r.jpg\"/><figcaption>输出显示“生成已完成”</figcaption></figure><p data-pid=\"FNwrVO33\">我们简单测试一下有无问题:</p><p data-pid=\"Eklr7Yzc\"><b>验证</b>：在终端运行 <code>./build/bin/llama-cli -h</code> 检查帮助信息。</p><p data-pid=\"8Nbhdd8Y\">注意你的build文件夹叫什么，像我默认是build-arm64-apple-clang-debug，根据实际修改。</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-601bf422ac8e38857d7aa406a161796d_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"1568\" data-rawheight=\"234\" data-original-token=\"v2-601bf422ac8e38857d7aa406a161796d\" class=\"origin_image zh-lightbox-thumb\" width=\"1568\" data-original=\"https://pic4.zhimg.com/v2-601bf422ac8e38857d7aa406a161796d_r.jpg\"/><figcaption>没问题的话，会输出一堆这些指令介绍</figcaption></figure><p data-pid=\"86ofJ52p\"><b>llama-cli</b> 是该项目提供的一个 <b>命令行工具（CLI）</b>，用于直接在终端运行和交互式使用模型。如果是按照 install.md 里的步骤安装，你可以通过这个命令行像运行一个应用程序一样 <b>加载模型、输入 prompt 并得到输出</b>，就像使用 conda、pip 等命令一样方便。这里我们是源码编译，所以需要带上路径。</p><p data-pid=\"azDWiojL\"><b>至此，我们构建并编译好了源码环境！</b>🎉</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.4 运行示例程序</h3><p data-pid=\"nc6kndKu\">我们继续在实践中学习，下面我们尝试在本地运行一个LLM。</p><p data-pid=\"A7x8hEMk\">首先，我们总结整理一下模型权重有什么：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>格式</th><th>常见框架</th><th>用途</th><th>优点/特点</th></tr><tr><td>.pt/.pth</td><td>PyTorch</td><td>通用</td><td>灵活，但不安全（pickle）</td></tr><tr><td>.ckpt</td><td>TensorFlow</td><td>Checkpoint</td><td>可恢复训练状态</td></tr><tr><td>.h5</td><td>Keras/TensorFlow</td><td>单文件模型</td><td>支持模型+权重</td></tr><tr><td>SavedModel</td><td>TensorFlow</td><td>生产部署</td><td>标准完整模型</td></tr><tr><td>.onnx</td><td>多</td><td>跨平台推理</td><td>硬件优化、框架独立</td></tr><tr><td>TorchScript</td><td>PyTorch</td><td>C++/移动推理</td><td>无 Python 依赖</td></tr><tr><td>.safetensors</td><td>HF/PyTorch</td><td>安全权重</td><td>快、安全、不执行代码</td></tr><tr><td>.tflite</td><td>TF Lite</td><td>移动推理</td><td>轻量高效</td></tr><tr><td>.mlmodel</td><td>Core ML</td><td>iOS/macOS 推理</td><td>Apple 优化</td></tr><tr><td>.gguf</td><td>LLaMA.cpp</td><td>本地 LLM 推理</td><td>性能/量化优化</td></tr><tr><td>.engine</td><td>TensorRT</td><td>GPU 推理</td><td>高性能定制</td></tr></tbody></table><p data-pid=\"HdCk-iMY\">可以看到，llama项目所需权重类型是.gguf。我们可以在huggingface（<a href=\"https://link.zhihu.com/?target=https%3A//huggingface.co/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">huggingface.co/</span><span class=\"invisible\"></span></a>）上下载模型权重，如果你不在境外，可以在镜像网址：<a href=\"https://link.zhihu.com/?target=https%3A//hf-mirror.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HF-Mirror</a>上下载相关权重。</p><p data-pid=\"tIhsqiPP\">当然，如果你本来有一个权重，但不是gguf类型的，llama也有转换类型的脚本，实在不行问AI看看能不能转。</p><p data-pid=\"uz7i0VGn\">考虑到大部分人显存情况，我们这里用qwen2.5-0.5B的权重来作为展示（<a href=\"https://link.zhihu.com/?target=https%3A//huggingface.co/Qwen/Qwen2.5-0.5B-Instruct-GGUF\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">huggingface.co/Qwen/Qwe</span><span class=\"invisible\">n2.5-0.5B-Instruct-GGUF</span><span class=\"ellipsis\"></span></a>），也节省下载时间，毕竟只是为了看效果，想一步到位也可以直接下载更大的显存，根据个人情况参考：</p><div class=\"highlight\"><pre><code class=\"language-text\">显存_req ≈ 参数数量 × 每参数字节数</code></pre></div><p data-pid=\"yyZfFbI-\">例如：</p><ul><li data-pid=\"7bWum4o5\">7B 模型（FP16）：7,000,000,000 × 2 B ≈ <b>14 GB</b></li><li data-pid=\"ejjqb1D-\">7B 模型（INT8）：7,000,000,000 × 1 B ≈ <b>7 GB</b></li><li data-pid=\"3BxJDBfZ\">70B 模型（FP16）：70,000,000,000 × 2 B ≈ <b>140 GB</b></li><li data-pid=\"Laer4U4A\">70B 模型（INT4）：70,000,000,000 × 0.5 B ≈ <b>35 GB</b> </li></ul><p data-pid=\"76lOTM0w\">最好就是推算出来还富裕2GB，这样运行起来大概率不会有问题。</p><p data-pid=\"mXG-JPDX\">点开网址，在Files and versions里面可以看到所有权重，我们一一下载下来，用浏览器、迅雷都行。也可以用脚本来下载，会方便一些。其他的还有什么专门的终端命令行，不过我之前捣鼓过，碰到各种问题没运行成功就算了。</p><p data-pid=\"Q1QcRUrI\">python脚本下载：需要安装huggingface_hub。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">from</span> <span class=\"nn\">huggingface_hub</span> <span class=\"k\">import</span> <span class=\"n\">snapshot_download</span>\n\n<span class=\"c1\"># 记得安装huggingface_hub，conda或者pip都行，我的路径是Mac，win可能要改一下</span>\n<span class=\"c1\"># 开镜像，在终端输入：export HF_ENDPOINT=https://hf-mirror.com</span>\n<span class=\"c1\"># HuggingFace 上模型仓库的 ID</span>\n<span class=\"n\">repo_id</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;Qwen/Qwen2.5-0.5B-Instruct-GGUF&#34;</span>\n\n<span class=\"c1\"># 下载到本地指定文件夹（例如 &#34;./models/Qwen2_5_0.5B&#34;）</span>\n<span class=\"n\">local_dir</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;./models/Qwen2_5_0.5B&#34;</span>\n\n<span class=\"n\">snapshot_download</span><span class=\"p\">(</span>\n    <span class=\"n\">repo_id</span><span class=\"o\">=</span><span class=\"n\">repo_id</span><span class=\"p\">,</span>\n    <span class=\"n\">local_dir</span><span class=\"o\">=</span><span class=\"n\">local_dir</span><span class=\"p\">,</span>\n    <span class=\"n\">resume_download</span><span class=\"o\">=</span><span class=\"kc\">True</span>  <span class=\"c1\"># 断点续传，如果网络中断也能接着下</span>\n<span class=\"p\">)</span></code></pre></div><p data-pid=\"d1mAvL7h\">如果你跟我一样遇到了huggingface镜像网址封锁IP问题：</p><figure data-size=\"normal\"><img src=\"https://pica.zhimg.com/v2-9a0d6e8816450d8a2ecc62992953458e_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"1786\" data-rawheight=\"116\" data-original-token=\"v2-9a0d6e8816450d8a2ecc62992953458e\" class=\"origin_image zh-lightbox-thumb\" width=\"1786\" data-original=\"https://pica.zhimg.com/v2-9a0d6e8816450d8a2ecc62992953458e_r.jpg\"/><figcaption>好像全网没几个网页讲解这个问题的</figcaption></figure><p data-pid=\"tu4Pn4Ml\">可以通过输入token来解决：</p><p data-pid=\"7_Xr1wFH\">先注册个huggingface官网账号（建议不管遇没遇到都弄一个，搞深度学习的跟这个网站强绑定，所有大模型开源权重基本都在这），然后在Acess Tokens中create一个Permissions为READ的token，然后一定要复制这个Vaule，这个只会出现一次，没保存就得重弄了。</p><p data-pid=\"uRcCMoZn\">可能需要安装huggingface-cli</p><p data-pid=\"PDNKhMnv\">然后在vscode终端输入：hf auth login，然后输入你的token，即可。</p><p data-pid=\"aURvgETw\">下载结束将模型权重放到llama.cpp下，文件路径如下：</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-5940fbfe669c812a5006ff6bf783539d_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"656\" data-original-token=\"v2-ede8be1efd99a4aaee9c29c0aeb4d4b9\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic4.zhimg.com/v2-5940fbfe669c812a5006ff6bf783539d_r.jpg\"/></figure><p data-pid=\"Wyelqmtd\">vscode终端输入（build路径根据实际修改）：</p><div class=\"highlight\"><pre><code class=\"language-text\">./build-arm64-apple-clang-debug/bin/llama-cli -m ./models/Qwen2_5_0.5B/qwen2.5-0.5b-instruct-fp16.gguf -p &#34;Hello, how are you?&#34; -n 32</code></pre></div><ul><li data-pid=\"NzEztA8C\"><code>-m</code>：指定模型路径。</li><li data-pid=\"Ndn54hvI\"><code>-p</code>：输入提示词（Prompt）。</li><li data-pid=\"CQ4nn53v\"><code>-n</code>：生成 token 数量。</li></ul><p data-pid=\"MtsvyNpg\">你会得到新世界大门——</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-85041aa134f19a1f0c2326c9e398e97b_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1858\" data-rawheight=\"1488\" data-original-token=\"v2-99f30296ff3ea2a62150165d5f33ee9a\" class=\"origin_image zh-lightbox-thumb\" width=\"1858\" data-original=\"https://pic2.zhimg.com/v2-85041aa134f19a1f0c2326c9e398e97b_r.jpg\"/></figure><p data-pid=\"v7FouHnP\">新世界大门很快就关上了：</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-e922c593d2c1006618e5ee29f7442078_1440w.jpg\" data-size=\"normal\" data-rawwidth=\"1588\" data-rawheight=\"120\" data-original-token=\"v2-e922c593d2c1006618e5ee29f7442078\" class=\"origin_image zh-lightbox-thumb\" width=\"1588\" data-original=\"https://pic1.zhimg.com/v2-e922c593d2c1006618e5ee29f7442078_r.jpg\"/><figcaption>可见参数量还是很重要的</figcaption></figure><p data-pid=\"7x38wH9d\">我们再尝试一个简单的例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">./build-arm64-apple-clang-debug/bin/llama-simple -m ./models/Qwen2_5_0.5B/qwen2.5-0.5b-instruct-fp16.gguf &#34;Hello my name is&#34;</code></pre></div><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-c1bbbb7896b707745235d75897468c46_1440w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1938\" data-rawheight=\"306\" data-original-token=\"v2-c1bbbb7896b707745235d75897468c46\" class=\"origin_image zh-lightbox-thumb\" width=\"1938\" data-original=\"https://pic1.zhimg.com/v2-c1bbbb7896b707745235d75897468c46_r.jpg\"/></figure><p data-pid=\"ZDtNvUmu\">这个终端输出是<code>llama-simple</code>示例程序成功运行的详细日志，展示了 llama.cpp 如何加载模型、初始化硬件并进行推理。</p><p data-pid=\"dWONKx3M\">主要阶段：</p><ul><li data-pid=\"Y_mqGkmc\"><b>硬件初始化</b>：</li><ul><li data-pid=\"pywYFMAu\"><b>Metal GPU 检测</b>：输出显示检测到 Apple M4 Pro GPU，启用 Metal 加速（e.g., &#34;ggml_metal_device_init: GPU name: Apple M4 Pro&#34;）。</li><li data-pid=\"SJMPFsGA\"><b>后端注册</b>：注册 Metal、BLAS（CPU 加速）、CPU 后端。</li><li data-pid=\"uCPw3lZz\"><b>内存分配</b>：分配 GPU 内存（e.g., 1202.09 MiB），模型层分配到 GPU。</li></ul><li data-pid=\"jha5AF-A\"><b>模型加载</b>：</li><ul><li data-pid=\"j7Kl6wHD\"><b>模型信息</b>：加载 Qwen2.5-0.5B-Instruct 模型（GGUF 格式，F16 精度，1.17 GiB）。</li><li data-pid=\"C13tcmW5\"><b>元数据</b>：显示模型架构（qwen2）、参数（630M）、词汇表（151936 tokens）。</li><li data-pid=\"tkW6qi42\"><b>张量加载</b>：逐层加载权重到 GPU（e.g., &#34;layer 0 assigned to device Metal&#34;）。</li></ul><li data-pid=\"o9T0dd64\"><b>上下文初始化</b>：</li><ul><li data-pid=\"1rpYJ_-a\"><b>推理设置</b>：上下文长度 256，批大小 4，启用 Flash Attention。</li><li data-pid=\"8BEMGsrE\"><b>KV 缓存</b>：分配 GPU KV 缓存（3.00 MiB）。</li><li data-pid=\"DFwFNg3t\"><b>计算缓冲</b>：分配 Metal 和 CPU 缓冲区。</li></ul><li data-pid=\"ipMkIvuX\"><b>推理过程</b>：</li><ul><li data-pid=\"LR0Ap3WK\"><b>输入处理</b>：处理提示词（默认 &#34;Hello&#34;，但输出显示生成文本）。</li><li data-pid=\"7lGUmTKk\"><b>生成输出</b>：模型生成 32 tokens 的文本（e.g., &#34;Hello my name is Sarah...&#34;）。</li><li data-pid=\"5gfLemXh\"><b>性能统计</b>：加载时间 1069.98 ms，推理速度 166.43 tokens/s。</li></ul><li data-pid=\"aX_DUO1X\"><b>清理</b>：</li><ul><li data-pid=\"cQRr8uIO\">释放内存，程序结束。</li></ul></ul><p data-pid=\"eUC6rbgI\">通过上面的步骤我们可以看出，在编译构建完成之后，<b>直接使用 build 目录下的 bin 文件夹中的可执行文件来运行和测试程序即可。</b></p><p data-pid=\"v4JeFEpB\">至此，我们已经掌握了在llama.cpp中最基础的使用LLM能力！🎉</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>2. C++语法入门（极简版）</h2><p data-pid=\"wD7jA6qV\">这里我通过学习examples/simple/simple.cpp来入门C++基本语法。只针对本文档，主要是学习大部分的语法，以后遇到新的代码用AI显学即可。</p><p data-pid=\"tCAOjRa_\">这一节的核心目标是：看懂C++文件的大部分语法。像是应试英语一样能大概看懂文章就行，遇到重要的不认识的单词再现查。不过很基础的C语言比如数据类型、变量、常量、循环、if什么的我就略过了，默认会。</p><p data-pid=\"uSpMhy66\">如果想要学习的全面，上面你已经入门了C++的整体感觉了，剩下的可以去菜鸟教程之类的网址系统的学习，我这里还是习惯在项目中遇到了什么就学习什么。</p><h3>2.1 llama.h头文件</h3><p data-pid=\"sbOYMXkb\">打开examples/simple/simple.cpp，一般的.cpp文件都有这个开头：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;llama.h&#34;  // 双引号表示这是项目自带的头文件（llama库的接口） include/llama.h</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"c1\">// 下面包含标准库或系统头文件\n</span><span class=\"c1\"></span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt; // 输入输出函数，如 printf(), scanf()</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstring&gt; // 字符串处理，如 memcpy(), strlen()</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;string&gt; // C++ 风格字符串 std::string</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt; // 模板容器 std::vector&lt;T&gt;</span><span class=\"cp\">\n</span></code></pre></div><p data-pid=\"hP_zJzxJ\">如果学过python的话，可以简单理解为import 库，但是有本质区别：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>特性</th><th>Python 的 import</th><th>C/C++ 的 #include</th></tr><tr><td>何时发生</td><td>运行时或解释器加载时</td><td>编译前 预处理阶段</td></tr><tr><td>真正做的事</td><td>把模块加载进内存，执行其顶层代码，然后建立引用</td><td>把另一个文件的源代码“粘贴”到当前位置，然后再编译</td></tr><tr><td>命名空间</td><td>有独立模块命名空间</td><td>被包含文件的代码直接进入当前文件的编译空间</td></tr><tr><td>是否重复执行</td><td>模块只会加载一次</td><td>如果没有 include guard 可能会重复展开内容（需要防护）</td></tr></tbody></table><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"OMGiL0ab\">这里插一嘴，如果你从别的地方学过C++的话，可能会经常看到这玩意，甚至可能是新手必教：</p><div class=\"highlight\"><pre><code class=\"language-text\">using namespace std;</code></pre></div><p data-pid=\"4ojqtQnQ\">这种写法我看有些评论是批判的，因为会导致一些奇奇怪怪的bug，如果你打算法竞赛追求速度倒是无所谓，但是搞项目不太行。知乎上挺多讲解这个问题的“为什么不能用 using namespace std”。这里我们留个印象就行，回头再学习为什么不行。</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"lMpznw6B\">我们转到include/llama.h查看头文件具体代码，1458行代码，让AI帮我们总结相关C++语法，你甚至可以用agent让AI帮你详细注释这个文件。</p><blockquote data-pid=\"EgL5aHIs\">这个文件是 llama.cpp 项目的核心头文件，定义了 C 风格的 API 接口，用于加载模型、推理和采样。它主要是 C 代码，但包含 C++ 兼容性元素（如<code>extern &#34;C&#34;</code>），以便在 C++ 项目中使用。</blockquote><ul><li data-pid=\"rHwphINj\"><b>使用</b>：在 C++ 程序中 <code>#include &#34;llama.h&#34;</code>，然后调用函数。见 <code><span class=\"nolink\">examples/simple/simple.cpp</span></code> 示例。</li><li data-pid=\"vfpwilOX\"><b>注意</b>：这是 API 文档，不是实现。函数内部由其他文件（如 <span class=\"nolink\">llama.cpp</span>）实现。</li></ul><p data-pid=\"OKfNZcdR\">文件中涉及到的所有语法与概念（汇总并按学习顺序）</p><ul><li data-pid=\"CfDsFsth\">预处理器与宏</li><ul><li data-pid=\"wvG5TLom\">#include, #define, #ifdef/#ifndef/#endif, #undef（若出现）</li><li data-pid=\"KCnRYDdU\"> 宏参数与宏展开（如 DEPRECATED、LLAMA_API） </li><li data-pid=\"n6mLryAH\">include guard（防重复包含） </li></ul><li data-pid=\"9bbh0Bl3\">类型系统与固定宽度整数</li><ul><li data-pid=\"-vfJ4QLj\">基本类型：int, float, double </li><li data-pid=\"WMaOOFQ0\">固定宽度类型：int32_t, int64_t, uint32_t, uint64_t size_t, ssize_t bool（C99/C++）</li></ul><li data-pid=\"bTEOd-i4\"> 指针与引用（本文件仅声明指针）</li><ul><li data-pid=\"7Kgkrw42\">指针语法：type *, 指向结构体的指针前向声明 </li><li data-pid=\"n7dWCC24\">const 修饰符与指针位置（const char * vs char * const） </li></ul><li data-pid=\"3KOCZInm\">typedef 与别名</li><ul><li data-pid=\"rpwKwvDk\">typedef  ;</li><li data-pid=\"Tk0xwSRh\"> 用于简化复杂类型（函数指针、结构体指针） </li></ul><li data-pid=\"kQmTiT2p\">struct 与 union</li><ul><li data-pid=\"qoYL_23l\">结构体定义、嵌套结构体 </li><li data-pid=\"P1vDfLji\">匿名 union（用于节省内存或实现变体字段） </li><li data-pid=\"ORT2h0Vq\">结构体作为参数或返回值（注意拷贝语义） </li></ul><li data-pid=\"lLHxOE9I\">enum（枚举类型）</li><ul><li data-pid=\"uwh4fQNJ\">常规枚举值与显式赋值 </li><li data-pid=\"BnCA1-OS\">用于选项集（如 llama_vocab_type） </li></ul><li data-pid=\"_89S3wN_\">函数声明与定义差异</li><ul><li data-pid=\"ChSoFSsa\">返回类型、参数列表、指针作为参数</li><li data-pid=\"2gDnsPbD\">void 参数、返回 void </li><li data-pid=\"Zmgb0l_C\">函数属性（通过宏加上编译器属性） </li></ul><li data-pid=\"mhSyD8W8\">extern “C”（C/C++ 互操作）</li><ul><li data-pid=\"1tv9zbNu\">防止 C++ 名称改编，确保链接兼容性</li></ul><li data-pid=\"js8bWstO\">函数指针与回调</li><ul><li data-pid=\"E2Tuq3Kb\">指针到函数类型、调用约定、回调上下文（void * user_data） </li></ul><li data-pid=\"RvuaWOft\">API 可见性与编译器属性</li><ul><li data-pid=\"kh5sRfeR\">__declspec(dllexport/import), <b>attribute</b>((visibility(“default”))) </li><li data-pid=\"uHF9x3yc\"><b>attribute</b>((deprecated(“…”))) </li></ul><li data-pid=\"W5fTvekL\">注释与文档风格</li><ul><li data-pid=\"1wT37uEe\">// 单行、/* … */ 多行 </li><li data-pid=\"8iM1rWYe\">文档注释（可用于生成文档） </li></ul><li data-pid=\"njWobdYh\">错误/弃用处理约定</li><ul><li data-pid=\"yBbM-DjW\">返回码（int32_t）、布尔值、NULL 指针错误信号 </li></ul><li data-pid=\"ozklZo4f\">C 风格接口设计习惯（面向 C API）</li><ul><li data-pid=\"F6JOtE8V\">以 struct * 句柄传递，用户负责释放资源（llama_free、llama_model_free） *_init, <i>_free、get</i>* 命名规范</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"Nj5BsT8s\">需要注意，<b><i>llama这里用的是C语言风格写的</i></b>，所以有一些本来是C++语法的东西用了C来替代。</p><p data-pid=\"cVJRVmWT\">这里我挑几个我个人认为重要的整理出来，其他的问AI也很快的。</p><h3>（1）头文件保护（最重要的第一层）</h3><p data-pid=\"palJtAlC\">首先看到的是 <b>#ifndef ... #endif</b>语法。</p><div class=\"highlight\"><pre><code class=\"language-text\">#ifndef LLAMA_H\n#define LLAMA_H\n...\n#endif // LLAMA_H 最后一行</code></pre></div><p data-pid=\"H7iGULdK\">这个语法是include guard——防止同一个头文件被 <b>重复 include</b> 导致 <b>重复定义错误</b>。</p><p data-pid=\"eMW9ztrU\">我个人理解就是 if not define LLAMA_H，那么执行，然后有一个endif来结尾。</p><p data-pid=\"6hv_DQ26\">下面还有类似的if结构，只不过这个是如果LLAMA_SHARED被定义了，那么就执行。</p><div class=\"highlight\"><pre><code class=\"language-text\">#ifdef LLAMA_SHARED\n#    if defined(_WIN32) &amp;&amp; !defined(__MINGW32__)\n#        ifdef LLAMA_BUILD\n#            define LLAMA_API __declspec(dllexport)\n#        else\n#            define LLAMA_API __declspec(dllimport)\n#        endif\n#    else\n#        define LLAMA_API __attribute__ ((visibility (&#34;default&#34;)))\n#    endif\n#else\n#    define LLAMA_API\n#endif</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>（2）依赖头文件</h3><div class=\"highlight\"><pre><code class=\"language-text\">#include &#34;ggml.h&#34;\n#include &#34;ggml-cpu.h&#34;\n#include &#34;ggml-backend.h&#34;\n#include &#34;ggml-opt.h&#34;</code></pre></div><p data-pid=\"0qCisEKa\">有双引号代表在本地。</p><div class=\"highlight\"><pre><code class=\"language-text\">#include &lt;stddef.h&gt;   // size_t\n#include &lt;stdint.h&gt;   // int32_t, uint64_t\n#include &lt;stdio.h&gt;    // FILE*\n#include &lt;stdbool.h&gt;  // bool (C风格)</code></pre></div><p data-pid=\"0-a-pYR1\">&lt;&gt;代表是标准C头文件。</p><p data-pid=\"vSOGrOge\">这里先不用管这些具体的含义，以后科研遇到了再现学。</p><p data-pid=\"-WtK7Mtr\">📌 llama 是 <b>C API风格</b>，不是纯 C++，所以大量用这些。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（3）导出/可见性宏（跨平台 DLL/SO 支持）</h3><div class=\"highlight\"><pre><code class=\"language-text\">// 如果定义了 LLAMA_SHARED，说明我们在使用 / 构建“动态库（shared library）”\n#ifdef LLAMA_SHARED\n\n// 如果是 Windows 平台（_WIN32），并且不是 MinGW 编译器\n#    if defined(_WIN32) &amp;&amp; !defined(__MINGW32__)\n\n        // 如果当前正在“编译 llama 库本身”\n        // 此时需要把符号（函数/变量）导出到 DLL，DLL是win专有的\n#        ifdef LLAMA_BUILD\n#            define LLAMA_API __declspec(dllexport)\n\n        // 否则：当前是在“使用 llama 库”（链接别人编译好的 DLL）\n        // 此时需要从 DLL 中导入符号\n#        else\n#            define LLAMA_API __declspec(dllimport)\n#        endif\n\n    // 非 Windows 平台（Linux / macOS 等，通常使用 GCC / Clang）\n    // 使用 visibility 属性将符号标记为对外可见\n#    else\n#        define LLAMA_API __attribute__ ((visibility (&#34;default&#34;)))\n#    endif\n\n// 如果没有定义 LLAMA_SHARED，说明不是以动态库形式使用（例如静态库或直接编译）\n#else\n    // 此时不需要任何导出/导入修饰，宏展开为空即可\n#    define LLAMA_API\n#endif</code></pre></div><p data-pid=\"ahtPIDW1\">这段代码的核心目的就是跨平台、跨构建类型地正确导出API，让llama.cpp既能编译成静态库，又能编译成动态库，并且在Windows和Unix系统上都正常工作。</p><p data-pid=\"1ZV3kcei\">这里看懂这些就差不多了，其他细节科研用到了再说：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>语法</th><th>示例</th><th>说明</th></tr><tr><td>#ifdef / #endif</td><td>#ifdef LLAMA_SHARED</td><td>如果宏已定义，就编译中间代码</td></tr><tr><td>#if defined()</td><td>#if defined(_WIN32)</td><td>更灵活的条件检查（可以组合逻辑运算）</td></tr><tr><td>嵌套条件编译</td><td>多层#if/#ifdef</td><td>实现复杂的平台/配置判断</td></tr><tr><td>#define 宏 值</td><td>#define LLAMA_API xxx</td><td>定义宏替换，后续代码中LLAMA_API会被替换成xxx</td></tr><tr><td>空宏定义</td><td>#define LLAMA_API</td><td>替换成空，什么都不加</td></tr><tr><td>编译器特定扩展</td><td>__declspec() / __attribute__</td><td>非标准C++，但主流编译器支持，用于控制符号导出</td></tr></tbody></table><blockquote data-pid=\"r6zy4fzK\">什么是静态库？链接器把库的全部代码直接复制进可执行文件。程序运行时不需要库文件存在。<br/>什么是动态库？链接器只记录“需要哪些函数”，运行时由操作系统加载库文件，把函数地址填进去。多个程序可以同时使用内存中的同一份库代码。<br/>导出符号（Export）：库文件里标记“可以被外部使用”的函数/变量。<br/>导入符号（Import）：可执行文件或另一个库里声明“需要从外部库获取”的函数/变量。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h3>（4）弃用标记宏</h3><div class=\"highlight\"><pre><code class=\"language-text\">// 如果使用的是 GCC 或兼容 GCC 的编译器（如 Clang）\n#ifdef __GNUC__\n\n// 定义一个宏 DEPRECATED\n// 用法：DEPRECATED(返回值 函数名(参数), &#34;弃用提示信息&#34;)\n// __attribute__((deprecated(hint))) 会在编译时产生“弃用警告”\n#    define DEPRECATED(func, hint) func __attribute__((deprecated(hint)))\n\n// 否则，如果是 MSVC（微软的 Visual C++ 编译器）\n#elif defined(_MSC_VER)\n\n// MSVC 使用 __declspec(deprecated(&#34;提示信息&#34;)) 来标记弃用函数\n#    define DEPRECATED(func, hint) __declspec(deprecated(hint)) func\n\n// 其他不支持弃用属性的编译器\n#else\n\n// 直接展开为原函数，不做任何弃用标记\n#    define DEPRECATED(func, hint) func\n\n#endif</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>（4）常量宏</h3><div class=\"highlight\"><pre><code class=\"language-text\">#define LLAMA_DEFAULT_SEED 0xFFFFFFFF\n\n#define LLAMA_TOKEN_NULL -1\n\n#define LLAMA_FILE_MAGIC_GGLA 0x67676c61u // &#39;ggla&#39;\n#define LLAMA_FILE_MAGIC_GGSN 0x6767736eu // &#39;ggsn&#39;\n#define LLAMA_FILE_MAGIC_GGSQ 0x67677371u // &#39;ggsq&#39;\n\n#define LLAMA_SESSION_MAGIC   LLAMA_FILE_MAGIC_GGSN\n#define LLAMA_SESSION_VERSION 9\n\n#define LLAMA_STATE_SEQ_MAGIC   LLAMA_FILE_MAGIC_GGSQ\n#define LLAMA_STATE_SEQ_VERSION 2</code></pre></div><p data-pid=\"0LuoIYg7\">可以简单理解为全局变量，比如：LLAMA_DEFAULT_SEED=0xFFFFFFFF。便于维护和更改常量</p><p data-pid=\"0a1_Rdoe\">与在代码中定义的区别（const的意思是定义了之后不能修改值，#define也是不能修改值）：</p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>对比</th><th>#define</th><th>const int</th></tr><tr><td>发生阶段</td><td>预处理</td><td>编译</td></tr><tr><td>是否占内存</td><td>❌</td><td>✅</td></tr><tr><td>是否有类型</td><td>❌</td><td>✅</td></tr><tr><td>能否用于 C API</td><td>✅</td><td>有限制</td></tr></tbody></table><p data-pid=\"qXsQyohV\">不但能定义数值，还能定义字符串等等。这里的常量宏涉及的语法知识点挺多的，可以让AI总结一下，这里就不整理出来了，我感觉看到了十之八九能知道什么意思。</p><p data-pid=\"iRwUJwTY\">关于宏，可参考：<a href=\"https://link.zhihu.com/?target=https%3A//light-city.github.io/stories_things/cpp-things/macro/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">宏那些事： 深入理解C++宏的使用与最佳实践 - C++那些事</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（5）枚举类型(C语言)</h3><div class=\"highlight\"><pre><code class=\"language-text\">    enum llama_vocab_type {\n        LLAMA_VOCAB_TYPE_NONE   = 0, // For models without vocab\n        LLAMA_VOCAB_TYPE_SPM    = 1, // LLaMA tokenizer based on byte-level BPE with byte fallback\n        LLAMA_VOCAB_TYPE_BPE    = 2, // GPT-2 tokenizer based on byte-level BPE\n        LLAMA_VOCAB_TYPE_WPM    = 3, // BERT tokenizer based on WordPiece\n        LLAMA_VOCAB_TYPE_UGM    = 4, // T5 tokenizer based on Unigram\n        LLAMA_VOCAB_TYPE_RWKV   = 5, // RWKV tokenizer based on greedy tokenization\n        LLAMA_VOCAB_TYPE_PLAMO2 = 6, // PLaMo-2 tokenizer based on Aho-Corasick with dynamic programming\n    };</code></pre></div><p data-pid=\"kYcC49tF\">这是 <b>“跨模块 / 跨语言 / 可序列化的状态枚举”。</b></p><div class=\"highlight\"><pre><code class=\"language-text\">enum 枚举类型名 {\n    枚举值名1 = 整数,\n    枚举值名2 = 整数,\n    ...\n};</code></pre></div><p data-pid=\"WSDsCAcp\"><b>本质：编译期整型常量</b></p><ul><li data-pid=\"Fzn4msEF\">类型是 int（C / 传统 enum）</li><li data-pid=\"JTWcik7R\">值在编译期确定</li><li data-pid=\"Y-uf1I2J\">不占运行时内存</li></ul><p data-pid=\"ok1bv4oN\"><b>enum相比</b> <b>#define的核心优势</b></p><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>对比</th><th>#define</th><th>enum</th></tr><tr><td>有类型</td><td>❌</td><td>✅</td></tr><tr><td>可调试</td><td>❌（调试器只看到数字）</td><td>✅</td></tr><tr><td>可读性</td><td>一般</td><td>很强</td></tr><tr><td>作用域</td><td>全局污染</td><td>有类型名</td></tr><tr><td>IDE 补全</td><td>❌</td><td>✅</td></tr></tbody></table><p data-pid=\"uZ6FVVhg\">这里显式写了 =0，=1，但其实也可以不写，会自动编号。但这不是良好的代码习惯，可能会导致后续更新代码的时候出现一些bug。</p><p data-pid=\"ZFOG2tLY\">其他的内容可参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cprogramming/c-enum.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">runoob.com/cprogramming</span><span class=\"invisible\">/c-enum.html</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（6）Struct 结构体</h3><p data-pid=\"5TvDYrzf\">可参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cprogramming/c-structures.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 结构体 | 菜鸟教程</a>，<a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cplusplus/cpp-struct.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C++ 结构体(struct) | 菜鸟教程</a>，<a href=\"https://link.zhihu.com/?target=https%3A//light-city.github.io/stories_things/cpp-things/struct/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">struct那些事：一文搞懂C和C++中struct</a></p><p data-pid=\"2J_KRHEB\">有什么区别？</p><blockquote data-pid=\"vXaXkDcF\"><b>C 的 struct 是“纯数据容器”；也就是C 的 struct 只能装数据；</b><br/><b>C++ 的 struct 是“一种类（class）”，只是默认是 public。</b><br/><b>在只含数据成员时，两者内存布局兼容，这也是 C API 能被 C++ 实现的根本原因。</b></blockquote><table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>对比点</th><th>C struct</th><th>C++ struct</th></tr><tr><td>是否是类型</td><td>✅</td><td>✅</td></tr><tr><td>是否需要 struct 关键字</td><td>✅</td><td>❌</td></tr><tr><td>能否有成员函数</td><td>❌</td><td>✅</td></tr><tr><td>能否有构造函数</td><td>❌</td><td>✅</td></tr><tr><td>能否继承</td><td>❌</td><td>✅</td></tr><tr><td>访问控制（public/private）</td><td>❌</td><td>✅</td></tr><tr><td>能否模板化</td><td>❌</td><td>✅</td></tr><tr><td>能否重载运算符</td><td>❌</td><td>✅</td></tr><tr><td>本质</td><td>数据布局</td><td>类（class）</td></tr></tbody></table><p data-pid=\"RUsHW7Kr\">再次强调：这个头文件是用 C 风格写的（C API），但为能在 C++ 中安全使用做了兼容处理 —— 本身几乎没有 C++ 专有语法。</p><div class=\"highlight\"><pre><code class=\"language-text\">struct llama_context;</code></pre></div><p data-pid=\"JO7W1YUE\">这是：</p><ul><li data-pid=\"uWg4ZjrS\">前向声明</li><li data-pid=\"00wMyJw9\">不暴露内部结构</li><li data-pid=\"pYD0hxmn\">C / C++ 都能用</li></ul><p data-pid=\"WpeG54qy\"><b>头文件是 C 视角，源文件是 C++ 视角，这是大型库的标准写法。</b></p><blockquote data-pid=\"7uKSgQGJ\"><b>头文件给“别人用” → 写 C 风格 struct</b><br/><b>源文件自己用 → C++ struct / class 随便</b></blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h3>（7）typedef</h3><p data-pid=\"PJJ5-75U\">可参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cprogramming/c-typedef.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C typedef | 菜鸟教程</a></p><p data-pid=\"8fc6ICI0\">简单来说：</p><blockquote data-pid=\"b7sdsf5j\"><b>typedef 只是“给类型起别名”，它不创建新类型、不改变内存、不引入语义。</b></blockquote><p data-pid=\"b0ZbbNyW\">typedef struct是 C 专属写法。现阶段需要注意三点：</p><blockquote data-pid=\"VvZBDBVO\">① typedef 不会创建新类型<br/>② const 修饰的是 typedef 后的整体（const这个语法也是很重要的，可参考：<a href=\"https://link.zhihu.com/?target=https%3A//light-city.github.io/stories_things/cpp-things/const/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">const那些事：深入理解常量的使用与最佳实践 - C++那些事</a>）<br/>③ 指针 typedef 要格外小心（关于指针，后面再说）</blockquote><p data-pid=\"1afPErki\">如果你看到了</p><div class=\"highlight\"><pre><code class=\"language-text\">typedef struct llama_context llama_context;</code></pre></div><p data-pid=\"IvfuWJhV\">这是：</p><ul><li data-pid=\"oxXQCxa_\"><b>不透明类型（opaque type）</b></li><li data-pid=\"8nnZJY1D\">C API 的黄金模式</li><li data-pid=\"Kur67PLb\">用来隐藏 C++ 实现细节</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h3>（8）extern</h3><p data-pid=\"xxFt8a1s\">可参考：</p><p data-pid=\"fn1CYiJa\"><a href=\"https://link.zhihu.com/?target=https%3A//light-city.github.io/stories_things/cpp-things/extern/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">extern C那些事：深入了解C语言与C++的链接技巧 - C++那些事</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（9）其他</h3><p data-pid=\"bGi7R5lG\">其他的语法我就不展开说了，整理起来到一个文档太困难了，知识点相互交杂。一入代码深似海，多用AI进行学习吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.2 源文件入门</h3><p data-pid=\"JsWeGKzX\">examples/simple/simple.cpp，这里也简单做个笔记，作为大家学习C++的引子。</p><p data-pid=\"pcc8COTf\">本文件执行流程（逐步）</p><ul><li data-pid=\"vg2s3qT7\">解析命令行参数</li><ul><li data-pid=\"Ea6Or6Vn\">支持 -m 模型路径，-n 生成 token 数量，-ngl GPU offload 层数；其余串联为 prompt。</li><li data-pid=\"7Rx39MdC\">使用 strcmp 比较 argv，std::stoi 转整数，try/catch 捕获转换错误，参数错误时 print_usage 并返回 1。</li></ul><li data-pid=\"l33iPS-6\">加载后端</li><ul><li data-pid=\"vzGcQzkN\">调用 ggml_backend_load_all() 动态注册/加载可用后端（Metal/CUDA/BLAS/CPU 等）。</li></ul><li data-pid=\"28TJuV9J\">初始化并加载模型</li><ul><li data-pid=\"cftL2L1M\">llama_model_params 取默认值并设置 n_gpu_layers（ngl）。</li><li data-pid=\"PCSX4GRH\">llama_model_load_from_file 加载模型文件（返回指针），失败返回错误。</li></ul><li data-pid=\"CCkyHS0F\">获取词表并 token 化 prompt</li><ul><li data-pid=\"LQRh4H9x\">先调用 llama_tokenize 取得需要的 token 数（通过传 NULL 得到负值），再分配 std::vector&lt;llama_token&gt; 存 token 并再次调用 llama_tokenize 填充数组。</li></ul><li data-pid=\"B6RatIo5\">初始化推理上下文</li><ul><li data-pid=\"kwnSI4sr\">用 llama_context_default_params 填充 ctx_params（设置 n_ctx、n_batch、no_perf）。</li><li data-pid=\"y3BE6sNO\">llama_init_from_model 创建 llama_context（返回指针），失败报错退出。</li></ul><li data-pid=\"v8qFyvAM\">初始化采样器（Sampler）</li><ul><li data-pid=\"YUWceG1q\">使用链式采样器 llama_sampler_chain_init，并加入 greedy 采样（可扩展更多采样策略）。</li></ul><li data-pid=\"w55IaTgU\">打印 prompt（逐 token 输出）</li><ul><li data-pid=\"4NbxXEHC\">遍历 prompt_tokens，用 llama_token_to_piece 将 token 转回字符串片段并 printf 输出。</li></ul><li data-pid=\"CFkbFtmO\">为 encoder-decoder 模型做预处理（如果模型有 encoder）</li><ul><li data-pid=\"1m7a-D0q\">若 llama_model_has_encoder(model) 为真：先 llama_encode 整个 prompt，然后用 decoder start token 作为下一批输入。</li></ul><li data-pid=\"tOj6I46Z\">主生成循环（decode + sample）</li><ul><li data-pid=\"-FI1tvJz\">循环条件基于已处理 token 数与目标 token 数（n_prompt + n_predict）。</li><li data-pid=\"MZ76J1hg\">每次 llama_decode(ctx, batch) 评估当前批次（模型前向），随后 llama_sampler_sample 采样下一个 token。</li><li data-pid=\"yoUb0b7k\">检查是否为结束标记（llama_vocab_is_eog），若是则退出；否则把新 token 转为字符串输出，并把它封装为新的 batch 继续下一步。</li></ul><li data-pid=\"4xt7b3oK\">打印统计与清理</li><ul><li data-pid=\"_6DBReOD\">用 ggml_time_us 和 llama_perf_* 打印性能统计，调用 llama_sampler_free、llama_free、llama_model_free 释放资源，返回 0。</li></ul></ul><p data-pid=\"ZAOOQwaI\">代码注释：</p><div class=\"highlight\"><pre><code class=\"language-text\">#include &#34;llama.h&#34;               // llama.cpp 库的主头文件，包含所有核心类型和函数声明\n#include &lt;cstdio&gt;                // C标准输入输出：printf, fprintf, fflush 等\n#include &lt;cstring&gt;               // C字符串函数：strcmp 等\n#include &lt;string&gt;                // C++ 标准字符串类 std::string\n#include &lt;vector&gt;                // C++ 标准动态数组 std::vector\n\n// 静态函数，只在本文件可见，用于打印程序用法说明\nstatic void print_usage(int, char ** argv) {\n    printf(&#34;\\nexample usage:\\n&#34;);\n    printf(&#34;\\n    %s -m model.gguf [-n n_predict] [-ngl n_gpu_layers] [prompt]\\n&#34;, argv[0]);\n    // argv[0] 是程序自身名称（如 ./main）\n    printf(&#34;\\n&#34;);\n}\n\nint main(int argc, char ** argv) {\n    // ====================== 变量定义与默认值 ======================\n    std::string model_path;                    // 模型文件路径（必填）\n    std::string prompt = &#34;Hello my name is&#34;;    // 默认提示词，如果命令行没提供就用这个\n    int ngl = 99;                              // GPU 层数，默认尽量全部卸载到 GPU（99 通常表示“全部”）\n    int n_predict = 32;                        // 要生成的 token 数量\n\n    // ====================== 解析命令行参数 ======================\n    {\n        // 用额外大括号创建一个局部作用域，限制变量 i 的生命周期\n        int i = 1;  // 从第1个参数开始（第0个是程序名）\n\n        // 遍历所有参数\n        for (; i &lt; argc; i++) {\n            if (strcmp(argv[i], &#34;-m&#34;) == 0) {               // -m 指定模型路径\n                if (i + 1 &lt; argc) {\n                    model_path = argv[++i];                // 取下一个参数作为路径\n                } else {\n                    print_usage(argc, argv);\n                    return 1;                              // 参数不完整，直接退出\n                }\n            }\n            else if (strcmp(argv[i], &#34;-n&#34;) == 0) {          // -n 指定生成 token 数\n                if (i + 1 &lt; argc) {\n                    try {\n                        n_predict = std::stoi(argv[++i]);  // 字符串转 int，失败会抛异常\n                    } catch (...) {\n                        print_usage(argc, argv);\n                        return 1;\n                    }\n                } else {\n                    print_usage(argc, argv);\n                    return 1;\n                }\n            }\n            else if (strcmp(argv[i], &#34;-ngl&#34;) == 0) {        // -ngl 指定 GPU 卸载层数\n                if (i + 1 &lt; argc) {\n                    try {\n                        ngl = std::stoi(argv[++i]);\n                    } catch (...) {\n                        print_usage(argc, argv);\n                        return 1;\n                    }\n                } else {\n                    print_usage(argc, argv);\n                    return 1;\n                }\n            }\n            else {\n                // 遇到第一个不是选项的参数，说明后面的都是 prompt\n                break;\n            }\n        }\n\n        // 必须提供模型路径\n        if (model_path.empty()) {\n            print_usage(argc, argv);\n            return 1;\n        }\n\n        // 如果还有剩余参数，把它们拼接成完整的 prompt\n        if (i &lt; argc) {\n            prompt = argv[i++];                  // 第一个非选项参数\n            for (; i &lt; argc; i++) {\n                prompt += &#34; &#34;;                   // 用空格连接多个词\n                prompt += argv[i];\n            }\n        }\n    }\n\n    // ====================== 加载动态后端（可选的加速后端） ======================\n    ggml_backend_load_all();  // 自动加载 CUDA、Metal、Vulkan 等可用后端\n\n    // ====================== 加载模型 ======================\n    llama_model_params model_params = llama_model_default_params();  // 获取默认参数\n    model_params.n_gpu_layers = ngl;                                 // 设置 GPU 层数\n\n    llama_model * model = llama_model_load_from_file(model_path.c_str(), model_params);\n    // .c_str() 把 std::string 转成 C 风格字符串（const char*）\n\n    if (model == NULL) {\n        fprintf(stderr, &#34;%s: error: unable to load model\\n&#34;, __func__);\n        return 1;\n    }\n\n    const llama_vocab * vocab = llama_model_get_vocab(model);  // 获取模型词汇表（只读）\n\n    // ====================== Tokenize 提示词 ======================\n    // 第一步：计算需要多少 token（传入 NULL 和 0，返回负的所需数量）\n    const int n_prompt = -llama_tokenize(vocab, prompt.c_str(), prompt.size(), NULL, 0, true, true);\n\n    // 第二步：分配空间并真正进行分词\n    std::vector&lt;llama_token&gt; prompt_tokens(n_prompt);  // 动态数组，大小正好够用\n    if (llama_tokenize(vocab, prompt.c_str(), prompt.size(),\n                       prompt_tokens.data(), prompt_tokens.size(), true, true) &lt; 0) {\n        fprintf(stderr, &#34;%s: error: failed to tokenize the prompt\\n&#34;, __func__);\n        return 1;\n    }\n\n    // ====================== 创建上下文（context） ======================\n    llama_context_params ctx_params = llama_context_default_params();\n    ctx_params.n_ctx    = n_prompt + n_predict - 1;   // 总上下文长度（prompt + 要生成的）\n    ctx_params.n_batch  = n_prompt;                   // 一次最多处理多少 token（这里先处理整个 prompt）\n    ctx_params.no_perf  = false;                     // 启用性能统计\n\n    llama_context * ctx = llama_init_from_model(model, ctx_params);\n    if (ctx == NULL) {\n        fprintf(stderr, &#34;%s: error: failed to create the llama_context\\n&#34;, __func__);\n        return 1;\n    }\n\n    // ====================== 初始化采样器（决定如何选下一个 token） ======================\n    auto sparams = llama_sampler_chain_default_params();\n    sparams.no_perf = false;                          // 也统计采样性能\n    llama_sampler * smpl = llama_sampler_chain_init(sparams);\n\n    // 使用贪婪采样（greedy）：永远选概率最高的 token（最确定性）\n    llama_sampler_chain_add(smpl, llama_sampler_init_greedy());\n\n    // ====================== 打印提示词（逐 token 转回文本，模拟实时输出） ======================\n    for (auto id : prompt_tokens) {  // C++11 范围 for 循环，非常简洁\n        char buf[128];\n        int n = llama_token_to_piece(vocab, id, buf, sizeof(buf), 0, true);\n        if (n &lt; 0) {\n            fprintf(stderr, &#34;%s: error: failed to convert token to piece\\n&#34;, __func__);\n            return 1;\n        }\n        std::string s(buf, n);      // 从缓冲区构造字符串（长度为 n）\n        printf(&#34;%s&#34;, s.c_str());\n    }\n\n    // ====================== 准备第一个 batch（包含整个 prompt） ======================\n    llama_batch batch = llama_batch_get_one(prompt_tokens.data(), prompt_tokens.size());\n\n    // ====================== 处理特殊的编码器-解码器模型（如 T5） ======================\n    if (llama_model_has_encoder(model)) {\n        if (llama_encode(ctx, batch)) {\n            fprintf(stderr, &#34;%s : failed to eval\\n&#34;, __func__);\n            return 1;\n        }\n        // 编码器处理完后，需要给解码器一个起始 token\n        llama_token decoder_start_token_id = llama_model_decoder_start_token(model);\n        if (decoder_start_token_id == LLAMA_TOKEN_NULL) {\n            decoder_start_token_id = llama_vocab_bos(vocab);  // 备用：用 BOS token\n        }\n        batch = llama_batch_get_one(&amp;decoder_start_token_id, 1);\n    }\n\n    // ====================== 主生成循环 ======================\n    const auto t_main_start = ggml_time_us();  // 记录开始时间（微秒）\n    int n_decode = 0;                           // 已生成 token 计数\n    llama_token new_token_id;\n\n    // 循环条件：已处理位置 + 当前 batch 长度 &lt; 总期望长度\n    for (int n_pos = 0; n_pos + batch.n_tokens &lt; n_prompt + n_predict; ) {\n        // 前向计算（推理）\n        if (llama_decode(ctx, batch)) {\n            fprintf(stderr, &#34;%s : failed to eval, return code %d\\n&#34;, __func__, 1);\n            return 1;\n        }\n\n        n_pos += batch.n_tokens;  // 更新已处理的位置\n\n        // ====================== 采样下一个 token ======================\n        new_token_id = llama_sampler_sample(smpl, ctx, -1);  // -1 表示采样最后一个位置\n\n        // 检查是否生成结束标记（如 &lt;eos&gt;）\n        if (llama_vocab_is_eog(vocab, new_token_id)) {\n            break;\n        }\n\n        // 把新 token 转成文字并打印\n        char buf[128];\n        int n = llama_token_to_piece(vocab, new_token_id, buf, sizeof(buf), 0, true);\n        if (n &lt; 0) {\n            fprintf(stderr, &#34;%s: error: failed to convert token to piece\\n&#34;, __func__);\n            return 1;\n        }\n        std::string s(buf, n);\n        printf(&#34;%s&#34;, s.c_str());\n        fflush(stdout);  // 立即刷新输出，看到实时生成效果（非常重要！）\n\n        // 准备下一个 batch：只包含刚刚生成的这个 token\n        batch = llama_batch_get_one(&amp;new_token_id, 1);\n\n        n_decode++;\n    }\n\n    printf(&#34;\\n&#34;);  // 生成完后换行\n\n    // ====================== 性能统计输出 ======================\n    const auto t_main_end = ggml_time_us();\n    float elapsed_s = (t_main_end - t_main_start) / 1000000.0f;\n    float speed = n_decode / elapsed_s;\n\n    fprintf(stderr, &#34;%s: decoded %d tokens in %.2f s, speed: %.2f t/s\\n&#34;,\n            __func__, n_decode, elapsed_s, speed);\n\n    fprintf(stderr, &#34;\\n&#34;);\n    llama_perf_sampler_print(smpl);   // 打印采样器性能数据\n    llama_perf_context_print(ctx);    // 打印上下文（模型推理）性能数据\n    fprintf(stderr, &#34;\\n&#34;);\n\n    // ====================== 资源清理（防止内存泄漏） ======================\n    llama_sampler_free(smpl);\n    llama_free(ctx);\n    llama_model_free(model);\n\n    return 0;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"F0bBrG0d\">下面是一些重点基础概念：</p><h3>（1）入口函数与命令行参数</h3><div class=\"highlight\"><pre><code class=\"language-text\">int main(int argc, char ** argv)</code></pre></div><p data-pid=\"lyHZrEVx\"><b>语法细节</b>:</p><ul><li data-pid=\"omiKTAm4\"><code>argc</code> (Argument Count): 参数的个数（包括程序名本身）。</li><li data-pid=\"5VtJRlFX\"><code>char ** argv</code> (Argument Vector): 这是一个<b>指向指针的指针</b>（可以理解为字符串数组）。</li><li data-pid=\"RHSIF1X3\"><code>argv[0]</code> 是程序本身的名字，<code>argv[1]</code> 是第一个参数。</li><li data-pid=\"7YQpt819\"><b>难点</b>: 在 C++ 中，命令行参数原声是 C 风格字符串（<code>char*</code>），不是 Python 的 <code>str</code> 对象，所以代码中经常需要转换。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h3>（2）指针与引用</h3><p data-pid=\"FZWd2ISj\">指针是C/C++最重要的概念，作用巨大，也十分复杂。而引用是C++的专属方法。这里给一些基础概念以及学习网址。</p><p data-pid=\"fqg4aKHI\">想象内存是这样：</p><div class=\"highlight\"><pre><code class=\"language-text\">地址:  0x1000   0x1004   0x1008   0x100C\n内容:   10        20       30       40</code></pre></div><p data-pid=\"21Jz2SMX\">每个地址指向一个位置。</p><p data-pid=\"ozMeU1Wl\"><b>如果是普通变量，在内存中是这样子的：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">int x = 10;\n\n\n内存里：\nx\n┌─────────┐\n│   10    │\n└─────────┘</code></pre></div><p data-pid=\"revnSxeE\">而指针变量，存储的是地址：</p><div class=\"highlight\"><pre><code class=\"language-text\">int *p = &amp;x;\n\n内存中：\n\nx           p\n┌──────┐   ┌─────────┐\n│ 10   │   │ 0x1000  │  ← p 里存的是 x 的地址\n└──────┘   └─────────┘</code></pre></div><p data-pid=\"3ucOYtPU\"><b>三大核心操作：</b></p><ol><li data-pid=\"SDFjUO6H\">&amp;：取地址</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">&amp;x   // 得到 x 的地址</code></pre></div><p data-pid=\"bpycy8G8\">2. *：解引用（访问地址里的内容）</p><div class=\"highlight\"><pre><code class=\"language-text\">*p   // 访问 p 指向的那块内存里的值</code></pre></div><p data-pid=\"Sy2kYnxz\">3. int *p：声明一个“指向int的指针”</p><p data-pid=\"_91w15Oi\">读法：p 是一个指针，指向 int</p><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"IcI5tP_I\">相关学习网址：</p><p data-pid=\"uFBf0kfq\"><a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cprogramming/c-pointers.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C 指针 | 菜鸟教程</a>，<a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cplusplus/cpp-pointers.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C++ 指针 | 菜鸟教程</a></p><p data-pid=\"Jmf5Xn1h\"><a href=\"https://link.zhihu.com/?target=https%3A//light-city.github.io/stories_things/cpp-things/pointer-vs-refer/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">引用与指针那些事</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（3）vector 容器</h3><p data-pid=\"TEX4gChY\">可参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.runoob.com/cplusplus/cpp-vector.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C++ vector 容器 | 菜鸟教程</a></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>（4）其他</h3><p data-pid=\"0IVbo5_K\">到这里为止，后续内容基本都可以借助 AI 辅助学习了。只要能看到这一部分，就已经不会再对 C++ 感到完全陌生，完全可以在实际项目中边看代码、边上手、边学习！🎉</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>3. 总结</h2><p data-pid=\"sk-inxEz\">本笔记，书写了怎么上手llama.cpp，怎么从完全对C++陌生，到大概知道项目的架构。</p><p data-pid=\"coNlUbXY\">其中可能有错误，欢迎大佬指正！</p>",
        "article_type": "normal",
        "is_navigator": false,
        "navigator_vote": false,
        "image_url": "https://pic1.zhimg.com/v2-e154c9b656615a1f0ac3f24c3fa40c30.jpg?source=7e7ef6e2&needBackground=1",
        "comment_permission": "all",
        "updated": 1767591651,
        "voteup_count": 84,
        "thumbnails": [
          "https://pic1.zhimg.com/v2-e154c9b656615a1f0ac3f24c3fa40c30.jpg?source=7e7ef6e2&needBackground=1",
          "https://pic1.zhimg.com/50/v2-d68d4e3e98e258736c767047d0dea7a4_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-003389f84fbf0a9035737cc41ae2af4d_720w.jpg?source=b6762063",
          "https://pica.zhimg.com/50/v2-dca733f7ed5db98003a1a92d424a38a6_720w.jpg?source=b6762063",
          "https://picx.zhimg.com/50/v2-99f30296ff3ea2a62150165d5f33ee9a_720w.jpg?source=b6762063"
        ],
        "title": "边用llama.cpp边学C++笔记（完全入门版）",
        "voting": 0,
        "linkbox": {
          "category": "",
          "pic": "",
          "title": "",
          "url": ""
        },
        "excerpt_new": "最近在学习C++，主要是看到大厂都要求搞AI的会这门语言——“熟练掌握C/C++”，而我只会一些python。但很奇怪的是github上也没几个C++的深度学习项目，而我又懒得从底层学C++，我一直坚信在场景中学习是最高效的。我也没那么多时间细究什么指针啥的高性能问题，然后看C++的书本、视频又感觉跟我深度学习没什么关系，感觉比较老，跟项目工程差了十万八千里。我只想先学会用一个C++项目，然后有时间再说其他的细节问题。 本笔记帮…",
        "preview_text": "",
        "is_labeled": true,
        "allow_segment_interaction": true
      },
      "brief": "{\"source\": \"TS\", \"type\": \"article\", \"id\": 1990373677397717730}",
      "attached_info": "Cs0LCICBzNa/lZS0qgEQBxoJMjY4NDcxOTA0IMyc7coGKFQwB0A1SjUKIFRTX1NPVVJDRV9GRUVEUkVfRklSU1RfU0NSRUVOX1YyEgEwGAAgADoKeyJyYXciOiIifWIgYTRlOTBjNTc5ODcxNTZiYTkxYjAyNWE5MzFhY2UxMDhyEzE5OTAzNzM2NzczOTc3MTc3MzCCAV9odHRwczovL3BpYzEuemhpbWcuY29tL3YyLWUxNTRjOWI2NTY2MTVhMWYwYWMzZjI0YzNmYTQwYzMwLmpwZz9zb3VyY2U9N2U3ZWY2ZTImbmVlZEJhY2tncm91bmQ9MaoBCXJlY29tbWVuZMIBIDg3MzM2ZDI2NmMyMjQ0YzFkOGRmNWQ0Nzk0ZmUxZWFh8gEKCAwSBk5vcm1hbPIBKAgKEiQyZmI2YzBmMS0yNjNhLTQxMWEtYjQ1NC1lZmY3MDEwMTA3OTbyAQUICxIBOYICAIgCzdLEm7kzkgIgODczMzZkMjY2YzIyNDRjMWQ4ZGY1ZDQ3OTRmZTFlYWGaAgDKAhRGaXJzdEJydXNoV2VpZ2h0UnVsZcoCFlNob3JJbnRlcmVzdFdlaWdodFJ1bGXKAhtJbnRlcmFjdGlvblNob3JJbnRlcmVzdFJ1bGXKAhxCYXllc0ZpcnN0TGV2ZWxJc29sYXRpb25SdWxl2gIgVFNfU09VUkNFX0ZFRURSRV9GSVJTVF9TQ1JFRU5fVjLoAgP6AgtOT1JNQUxfRkxPV4oDIDNkZjJiZDgyZDRhMDQzYWVhZGFjMGQ5MDE0ZTU0MzQ2mgMNCgJ2MhAAGgVvdGhlcqgDhxTYAwDqAxZmZWVkcmVfZmlyc3Rfc2NyZWVuX3Yy+gOvBRIMVU5LTk9XTl9NT0RFIAAqDU5PX0lNQUdFX01PREU6LQgCEMYPGKwEIiN2Mi1kYzMzZWU3MjgxYzA3N2I1MDg2MTg3N2VjZWJiZjJlZjotCAIQ7gQYiAYiI3YyLWMyN2E4YmVkMzFlZWQ5NTNlYzQyNTNmMWY4MGRlNjNkOi0IAhCVNRj8KyIjdjItZDY4ZDRlM2U5OGUyNTg3MzZjNzY3MDQ3ZDBkZWE3YTQ6LQgCELcwGIwhIiN2Mi0wMDMzODlmODRmYmYwYTkwMzU3MzdjYzQxYWUyYWY0ZDotCAIQ0gUY2AYiI3YyLWRjYTczM2Y3ZWQ1ZGI5ODAwM2ExYTkyZDQyNGEzOGE2Oi0IAhCABRjsASIjdjItYTNkMjhhZjYwMjIzMDA3MzMyZGNlZDJhY2QzMThhNjg6LQgCEOoEGK4CIiN2Mi0zNjI1YzJiZGYyZTkxZWI0NWM1Zjk5N2E1MTllYzJjMTotCAIQoAwY6gEiI3YyLTYwMWJmNDIyYWM4ZTM4ODU3ZDdhYTQwNmExNjE3OTZkOiwIAhD6DRh0IiN2Mi05YTBkNmU4ODE2NDUwZDhhMmVjYzYyOTkyOTUzNDU4ZTotCAIQvAQYkAUiI3YyLWVkZThiZTFlZmQ5OWE0YWFlZTljMjljMGFlYjRkNGI5Oi0IAhDCDhjQCyIjdjItOTlmMzAyOTZmZjNlYTJhNjIxNTAxNjVkNWYzM2VlOWE6LAgCELQMGHgiI3YyLWU5MjJjNTkzZDJjMTAwNjYxOGU1ZWUyOWY3NDQyMDc4Oi0IAhCSDxiyAiIjdjItYzFiYmJiNzg5NmI3MDc3NDUyMzVkNzU4OTc0NjhjNDY6LQgDEOQJGKoDIiN2Mi1lMTU0YzliNjU2NjE1YTFmMGFjM2YyNGMzZmE0MGMzMIAEAIgEAJIEBk5vcm1hbJoEATOgBACoBACwBAC6BAJhacIEAzQwMMgEANIED+aOqOiNkOW3suabtOaWsNgEAPAEAPkEAAAAIHckgj+BBQAAAAAAAAAAiQUZKK8TkbixP5IFAJoFA2RmdKIFA2RmdLIFATG5BQAAAAAAAAAA0AUA4AUA6AUA8AUJkAYAoAY1qAYAkgIuCgkyNjg0NzE5MDQSEzE5OTAzNzM2NzczOTc3MTc3MzAYByIKSU1BR0VfVEVYVA==",
      "action_card": false
    }
  ],
  "paging": {
    "is_end": false,
    "is_start": false,
    "next": "https://www.zhihu.com/api/v3/feed/topstory/recommend?action=down&ad_interval=-10&after_id=53&desktop=true&end_offset=53&page_number=10&session_token=a4e90c57987156ba91b025a931ace108",
    "previous": "https://www.zhihu.com/api/v3/feed/topstory/recommend?action=pull&ad_interval=-10&before_id=53&desktop=true&end_offset=53&page_number=10&session_token=a4e90c57987156ba91b025a931ace108",
    "totals": 0
  },
  "fresh_text": "推荐已更新"
}